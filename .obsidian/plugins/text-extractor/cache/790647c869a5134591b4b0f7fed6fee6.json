{"path":"robot-dynamics-control/Robot Dynamics and Control.pdf","text":"Robot Dynamics and Control Second Edition Mark W. Spong, Seth Hutchinson, and M. Vidyasagar January 28, 2004 2 Contents 1 INTRODUCTION 5 1.1 Robotics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 1.2 History of Robotics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 1.3 Components and Structure of Robots . . . . . . . . . . . . . . . . . . . . . 8 1.3.1 Symbolic Representation of Robots . . . . . . . . . . . . . . . . . . . 8 1.3.2 Degrees of Freedom and Workspace . . . . . . . . . . . . . . . . . . 9 1.3.3 Classiﬁcation of Robots . . . . . . . . . . . . . . . . . . . . . . . . . 10 1.3.4 Common Kinematic Arrangements . . . . . . . . . . . . . . . . . . . 11 1.3.5 Robotic Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 1.3.6 Accuracy and Repeatability . . . . . . . . . . . . . . . . . . . . . . 16 1.3.7 Wrists and End-Eﬀectors . . . . . . . . . . . . . . . . . . . . . . . . 18 1.4 Outline of the Text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 2 RIGID MOTIONS AND HOMOGENEOUS TRANSFORMATIONS 29 2.1 Representing Positions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 2.2 Representing Rotations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 2.2.1 Rotation in the plane . . . . . . . . . . . . . . . . . . . . . . . . . . 32 2.2.2 Rotations in three dimensions . . . . . . . . . . . . . . . . . . . . . . 34 2.3 Rotational Transformations . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 2.3.1 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 2.4 Composition of Rotations . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 2.4.1 Rotation with respect to the current coordinate frame . . . . . . . . 40 2.4.2 Rotation with respect to a ﬁxed frame . . . . . . . . . . . . . . . . . 42 2.4.3 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 2.5 Parameterizations of Rotations . . . . . . . . . . . . . . . . . . . . . . . . . 45 2.5.1 Euler Angles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 2.5.2 Roll, Pitch, Yaw Angles . . . . . . . . . . . . . . . . . . . . . . . . . 47 2.5.3 Axis/Angle Representation . . . . . . . . . . . . . . . . . . . . . . . 48 2.6 Homogeneous Transformations . . . . . . . . . . . . . . . . . . . . . . . . . 51 3 4 CONTENTS 3 FORWARD KINEMATICS: THE DENAVIT-HARTENBERG CONVEN- TION 57 3.1 Kinematic Chains . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 3.2 Denavit Hartenberg Representation . . . . . . . . . . . . . . . . . . . . . . 60 3.2.1 Existence and uniqueness issues . . . . . . . . . . . . . . . . . . . . 61 3.2.2 Assigning the coordinate frames . . . . . . . . . . . . . . . . . . . . 63 3.2.3 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66 3.3 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67 4 INVERSE KINEMATICS 79 4.1 The General Inverse Kinematics Problem . . . . . . . . . . . . . . . . . . . 79 4.2 Kinematic Decoupling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81 4.3 Inverse Position: A Geometric Approach . . . . . . . . . . . . . . . . . . . 83 4.4 Inverse Orientation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89 5 VELOCITY KINEMATICS – THE MANIPULATOR JACOBIAN 95 5.1 Angular Velocity: The Fixed Axis Case . . . . . . . . . . . . . . . . . . . . 96 5.2 Skew Symmetric Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97 5.3 Angular Velocity: The General Case . . . . . . . . . . . . . . . . . . . . . . 100 5.4 Addition of Angular Velocities . . . . . . . . . . . . . . . . . . . . . . . . . 101 5.5 Linear Velocity of a Point Attached to a Moving Frame . . . . . . . . . . . 102 5.6 Derivation of the Jacobian . . . . . . . . . . . . . . . . . . . . . . . . . . . 103 5.6.1 Angular Velocity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104 5.6.2 Linear Velocity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104 5.7 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109 5.8 The Analytical Jacobian . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111 5.9 Singularities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113 5.9.1 Decoupling of Singularities . . . . . . . . . . . . . . . . . . . . . . . 114 5.9.2 Wrist Singularities . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115 5.9.3 Arm Singularities . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115 5.10 Inverse Velocity and Acceleration . . . . . . . . . . . . . . . . . . . . . . . 119 5.11 Redundant Robots and Manipulability . . . . . . . . . . . . . . . . . . . . 120 5.11.1 Redundant Manipulators . . . . . . . . . . . . . . . . . . . . . . . . 120 5.11.2 The Inverse Velocity Problem for Redundant Manipulators . . . . . 121 5.11.3 Singular Value Decomposition (SVD) . . . . . . . . . . . . . . . . . 122 5.11.4 Manipulability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124 6 COMPUTER VISION 127 6.1 The Geometry of Image Formation . . . . . . . . . . . . . . . . . . . . . . 127 6.1.1 The Camera Coordinate Frame . . . . . . . . . . . . . . . . . . . . . 128 6.1.2 Perspective Projection . . . . . . . . . . . . . . . . . . . . . . . . . . 128 6.1.3 The Image Plane and the Sensor Array . . . . . . . . . . . . . . . . 129 6.2 Camera Calibration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130 CONTENTS 5 6.2.1 Extrinsic Camera Parameters . . . . . . . . . . . . . . . . . . . . . . 130 6.2.2 Intrinsic Camera Parameters . . . . . . . . . . . . . . . . . . . . . . 131 6.2.3 Determining the Camera Parameters . . . . . . . . . . . . . . . . . . 131 6.3 Segmentation by Thresholding . . . . . . . . . . . . . . . . . . . . . . . . . 134 6.3.1 A Brief Statistics Review . . . . . . . . . . . . . . . . . . . . . . . . 134 6.3.2 Automatic Threshold Selection . . . . . . . . . . . . . . . . . . . . . 136 6.4 Connected Components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140 6.5 Position and Orientation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143 6.5.1 Moments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143 6.5.2 The Centroid of an Object . . . . . . . . . . . . . . . . . . . . . . . 144 6.5.3 The Orientation of an Object . . . . . . . . . . . . . . . . . . . . . . 144 7 PATH PLANNING AND COLLISION AVOIDANCE 147 7.1 The Conﬁguration Space . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148 7.2 Path Planning Using Conﬁguration Space Potential Fields . . . . . . . . . 151 7.2.1 The Attractive Field . . . . . . . . . . . . . . . . . . . . . . . . . . . 152 7.2.2 The Repulsive ﬁeld . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153 7.2.3 Gradient Descent Planning . . . . . . . . . . . . . . . . . . . . . . . 154 7.3 Planning Using Workspace Potential Fields . . . . . . . . . . . . . . . . . . 155 7.3.1 Deﬁning Workspace Potential Fields . . . . . . . . . . . . . . . . . . 156 7.3.2 Mapping workspace forces to joint forces and torques . . . . . . . . . 158 7.3.3 Motion Planning Algorithm . . . . . . . . . . . . . . . . . . . . . . . 162 7.4 Using Random Motions to Escape Local Minima . . . . . . . . . . . . . . . 163 7.5 Probabilistic Roadmap Methods . . . . . . . . . . . . . . . . . . . . . . . . 164 7.5.1 Sampling the conﬁguration space . . . . . . . . . . . . . . . . . . . . 165 7.5.2 Connecting Pairs of Conﬁgurations . . . . . . . . . . . . . . . . . . . 165 7.5.3 Enhancement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167 7.5.4 Path Smoothing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167 7.6 Historical Perspective . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168 8 TRAJECTORY PLANNING 169 8.1 The Trajectory Planning Problem . . . . . . . . . . . . . . . . . . . . . . . 169 8.2 Trajectories for Point to Point Motion . . . . . . . . . . . . . . . . . . . . . 170 8.2.1 Cubic Polynomial Trajectories . . . . . . . . . . . . . . . . . . . . . 172 8.2.2 Multiple Cubics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175 8.2.3 Quintic Polynomial Trajectories . . . . . . . . . . . . . . . . . . . . . 175 8.2.4 Linear Segments with Parabolic Blends (LSPB) . . . . . . . . . . . 180 8.2.5 Minimum Time Trajectories . . . . . . . . . . . . . . . . . . . . . . 183 8.3 Trajectories for Paths Speciﬁed by Via Points . . . . . . . . . . . . . . . . 185 8.3.1 4-3-4 trajectories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186 6 CONTENTS 9 DYNAMICS 187 9.1 The Euler-Lagrange Equations . . . . . . . . . . . . . . . . . . . . . . . . . 187 9.1.1 One Dimensional System . . . . . . . . . . . . . . . . . . . . . . . . 188 9.1.2 The General Case . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190 9.2 General Expressions for Kinetic and Potential Energy . . . . . . . . . . . . 196 9.2.1 The Inertia Tensor . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197 9.2.2 Kinetic Energy for an n-Link Robot . . . . . . . . . . . . . . . . . . 198 9.2.3 Potential Energy for an n-Link Robot . . . . . . . . . . . . . . . . . 199 9.3 Equations of Motion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199 9.4 Some Common Conﬁgurations . . . . . . . . . . . . . . . . . . . . . . . . . 201 9.5 Properties of Robot Dynamic Equations . . . . . . . . . . . . . . . . . . . . 210 9.5.1 The Skew Symmetry and Passivity Properties . . . . . . . . . . . . . 211 9.5.2 Bounds on the Inertia Matrix . . . . . . . . . . . . . . . . . . . . . . 212 9.5.3 Linearity in the Parameters . . . . . . . . . . . . . . . . . . . . . . . 213 9.6 Newton-Euler Formulation . . . . . . . . . . . . . . . . . . . . . . . . . . . 214 9.7 Planar Elbow Manipulator Revisited . . . . . . . . . . . . . . . . . . . . . 221 10 INDEPENDENT JOINT CONTROL 225 10.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225 10.2 Actuator Dynamics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226 10.3 Set-Point Tracking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232 10.3.1 PD Compensator . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233 10.3.2 Performance of PD Compensators . . . . . . . . . . . . . . . . . . . 235 10.3.3 PID Compensator . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236 10.3.4 Saturation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237 10.4 Feedforward Control and Computed Torque . . . . . . . . . . . . . . . . . 238 10.5 Drive Train Dynamics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242 11 MULTIVARIABLE CONTROL 247 11.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247 11.2 PD Control Revisited . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248 11.3 Inverse Dynamics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250 11.3.1 Task Space Inverse Dynamics . . . . . . . . . . . . . . . . . . . . . . 253 11.4 Robust and Adaptive Motion Control . . . . . . . . . . . . . . . . . . . . . 254 11.4.1 Robust Feedback Linearization . . . . . . . . . . . . . . . . . . . . . 255 11.4.2 Passivity Based Robust Control . . . . . . . . . . . . . . . . . . . . . 259 11.4.3 Passivity Based Adaptive Control . . . . . . . . . . . . . . . . . . . 260 12 FORCE CONTROL 263 12.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263 12.2 Constrained Dynamics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264 12.2.1 Static Force/Torque Relationships . . . . . . . . . . . . . . . . . . . 266 12.2.2 Constraint Surfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . 267 CONTENTS 7 12.2.3 Natural and Artiﬁcial Constraints . . . . . . . . . . . . . . . . . . . 270 12.3 Network Models and Impedance . . . . . . . . . . . . . . . . . . . . . . . . 272 12.3.1 Impedance Operators . . . . . . . . . . . . . . . . . . . . . . . . . . 273 12.3.2 Classiﬁcation of Impedance Operators . . . . . . . . . . . . . . . . . 274 12.3.3 Th´evenin and Norton Equivalents . . . . . . . . . . . . . . . . . . . 275 12.4 Force Control Strategies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275 12.4.1 Impedance Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . 276 12.4.2 Hybrid Impedance Control . . . . . . . . . . . . . . . . . . . . . . . 277 13 FEEDBACK LINEARIZATION 281 13.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281 13.2 Background: The Frobenius Theorem . . . . . . . . . . . . . . . . . . . . . 283 13.3 Single-Input Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287 13.4 Feedback Linearization for N -Link Robots . . . . . . . . . . . . . . . . . . 295 8 CONTENTS Chapter 1 INTRODUCTION 1.1 Robotics Robotics is a relatively young ﬁeld of modern technology that crosses traditional engineer- ing boundaries. Understanding the complexity of robots and their applications requires knowledge of electrical engineering, mechanical engineering, systems and industrial engi- neering, computer science, economics, and mathematics. New disciplines of engineering, such as manufacturing engineering, applications engineering, and knowledge engineering have emerged to deal with the complexity of the ﬁeld of robotics and factory automation. This book is concerned with fundamentals of robotics, including kinematics, dynam- ics, motion planning, computer vision, and control. Our goal is to provide a complete introduction to the most important concepts in these subjects as applied to industrial robot manipulators. The science of robotics has grown tremendously over the past twenty years, fueled by rapid advances in computer and sensor technology as well as theoretical advances in control and computer vision. In addition to the topics listed above, robotics encompasses several areas not covered in this text such as locomotion, including wheeled and legged robots, ﬂying and swimming robots, grasping, artiﬁcial intelligence, computer architectures, programming languages, and computer-aided design. A complete treatment of the discipline of robotics would require several volumes. Nevertheless, at the present time, the vast majority of robot applications deal with industrial robot arms operating in structured factory environments so that a ﬁrst introduction to the subject of robotics must include a rigorous treatment of the topics in this text. 1.2 History of Robotics The term robot was ﬁrst introduced into our vocabulary by the Czech playwright Karel Capek in his 1920 play Rossum’s Universal Robots, the word robota being the Czech word for work. Since then the term has been applied to a great variety of mechanical devices, such as teleoperators, underwater vehicles, autonomous land rovers, etc. Virtually anything that 9 10 CHAPTER 1. INTRODUCTION operates with some degree of autonomy, usually under computer control, has at some point been called a robot. In this text the term robot will mean a computer controlled industrial manipulator of the type shown in Figure 1.1. This type of robot is essentially a mechanical arm operating under computer control. Such devices, though far from the robots of science ﬁction, are nevertheless extremely complex electro-mechanical systems whose analytical description requires advanced methods, and which present many challenging and interesting research problems. Figure 1.1: The ABB IRB6600 Robot. Photo courtesy of ABB An oﬃcial deﬁnition of such a robot comes from the Robot Institute of America (RIA): A robot is a reprogrammable multifunctional manipulator designed to move material, parts, tools, or specialized devices through variable programmed motions for the performance of a variety of tasks. The key element in the above deﬁnition is the reprogrammability of robots. It is the computer brain that gives the robot its utility and adaptability. The so-called robotics revolution is, in fact, part of the larger computer revolution. Even this restricted version of a robot has several features that make it attractive in an industrial environment. Among the advantages often cited in favor of the introduction of robots are decreased labor costs, increased precision and productivity, increased ﬂexi- bility compared with specialized machines, and more humane working conditions as dull, repetitive, or hazardous jobs are performed by robots. The robot, as we have deﬁned it, was born out of the marriage of two earlier technologies: that of teleoperators and numerically controlled milling machines. Teleoperators, or master-slave devices, were developed during the second world war to handle radioactive materials. Computer numerical control (CNC) was developed because of the high precision required in the machining of certain items, such as components of high performance aircraft. The ﬁrst robots essentially combined the mechanical linkages of the teleoperator with the autonomy and programmability of CNC machines. Several milestones on the road to present day robot technology are listed below. 1.2. HISTORY OF ROBOTICS 11 Milestones in the History of Robotics 1947 — the ﬁrst servoed electric powered teleoperator is developed 1948 — a teleoperator is developed incorporating force feedback 1949 — research on numerically controlled milling machine is initiated 1954 — George Devol designs the ﬁrst programmable robot 1956 — Joseph Engelberger, a Columbia University physics student, buys the rights to Devol’s robot and founds the Unimation Company 1961 — the ﬁrst Unimate robot is installed in a Trenton, New Jersey plant of General Motors to tend a die casting machine 1961 — the ﬁrst robot incorporating force feedback is developed 1963 — the ﬁrst robot vision system is developed 1971 — the Stanford Arm is developed at Stanford University 1973 — the ﬁrst robot programming language (WAVE) is developed at Stanford 1974 — Cincinnati Milacron introduced the T 3 robot with computer control 1975 — Unimation Inc. registers its ﬁrst ﬁnancial proﬁt 1976 — the Remote Center Compliance (RCC) device for part insertion in assembly is developed at Draper Labs in Boston 1976 — Robot arms are used on the Viking I and II space probes and land on Mars 1978 — Unimation introduces the PUMA robot, based on designs from a General Motors study 1979 — the SCARA robot design is introduced in Japan 1981 — the ﬁrst direct-drive robot is developed at Carnegie-Mellon University 1982 — Fanuc of Japan and General Motors form GM Fanuc to market robots in North America 1983 — Adept Technology is founded and successfully markets the direct drive robot 1986 — the underwater robot, Jason, of the Woods Hole Oceanographic Institute, explores the wreck of the Titanic, found a year earlier by Dr. Robert Barnard. 1988 — St¨aubli Group purchases Unimation from Westinghouse 1988 — the IEEE Robotics and Automation Society is formed 1993 — the experimental robot, ROTEX, of the German Aerospace Agency (DLR) was ﬂown aboard the space shuttle Columbia and performed a variety of tasks under both teleoperated and sensor-based oﬄine programmed modes 1996 — Honda unveils its Humanoid robot; a project begun in secret in 1986 12 CHAPTER 1. INTRODUCTION 1997 — the ﬁrst robot soccer competition, RoboCup-97, is held in Nagoya, Japan and draws 40 teams from around the world 1997 — the Sojourner mobile robot travels to Mars aboard NASA’s Mars PathFinder mission 2001 — Sony begins to mass produce the ﬁrst household robot, a robot dog named Aibo 2001 — the Space Station Remote Manipulation System (SSRMS) is launched in space on board the space shuttle Endeavor to facilitate continued construction of the space station 2001 — the ﬁrst telesurgery is performed when surgeons in New York performed a laparo- scopic gall bladder removal on a woman in Strasbourg, France 2001 — robots are used to search for victims at the World Trade Center site after the September 11th tragedy 2002 — Honda’s Humanoid Robot ASIMO rings the opening bell at the New York Stock Exchange on February 15th The ﬁrst successful applications of robot manipulators generally involved some sort of material transfer, such as injection molding or stamping where the robot merely attended a press to unload and either transfer or stack the ﬁnished part. These ﬁrst robots were capable of being programmed to execute a sequence of movements, such as moving to a location A, closing a gripper, moving to a location B, etc., but had no external sensor capability. More complex applications, such as welding, grinding, deburring, and assembly require not only more complex motion but also some form of external sensing such as vision, tactile, or force-sensing, due to the increased interaction of the robot with its environment. It should be pointed out that the important applications of robots are by no means limited to those industrial jobs where the robot is directly replacing a human worker. There are many other applications of robotics in areas where the use of humans is impractical or undesirable. Among these are undersea and planetary exploration, satellite retrieval and repair, the defusing of explosive devices, and work in radioactive environments. Finally, prostheses, such as artiﬁcial limbs, are themselves robotic devices requiring methods of analysis and design similar to those of industrial manipulators. 1.3 Components and Structure of Robots 1.3.1 Symbolic Representation of Robots Robot Manipulators are composed of links connected by joints into a kinematic chain. Joints are typically rotary (revolute) or linear (prismatic). A revolute joint is like a hinge and allows relative rotation between two links. A prismatic joint allows a linear relative motion between two links. We use the convention (R) for representing revolute joints and (P ) for prismatic joints and draw them as shown in Figure 1.2. 1.3. COMPONENTS AND STRUCTURE OF ROBOTS 13 Prismatic 2D 3D Revolute Figure 1.2: Symbolic representation of robot joints. Each joint represents the interconnection between two links, say ℓi and ℓi+1. We denote the axis of rotation of a revolute joint, or the axis along which a prismatic joint slides by zi if the joint is the interconnection of links i and i + 1. The joint variables, denoted by θi for a revolute joint and di for the prismatic joint, represent the relative displacement between adjacent links. We will make this precise in Chapter 3. 1.3.2 Degrees of Freedom and Workspace The number of joints determines the degrees-of-freedom (DOF) of the manipulator. Typ- ically, a manipulator should possess at least six independent DOF: three for positioning and three for orientation. With fewer than six DOF the arm cannot reach every point in its work environment with arbitrary orientation. Certain applications such as reaching around or behind obstacles require more than six DOF. The diﬃculty of controlling a ma- nipulator increases rapidly with the number of links. A manipulator having more than six links is referred to as a kinematically redundant manipulator. The workspace of a manipulator is the total volume swept out by the end-eﬀector as the manipulator executes all possible motions. The workspace is constrained by the geometry of the manipulator as well as mechanical constraints on the joints. For example, a revolute joint may be limited to less than a full 360◦ of motion. The workspace is often broken down into a reachable workspace and a dextrous workspace. The reachable workspace is the entire set of points reachable by the manipulator, whereas the dextrous workspace consists of those points that the manipulator can reach with an arbitrary orientation of the end- eﬀector. Obviously the dextrous workspace is a subset of the reachable workspace. The workspaces of several robots are shown later in this chapter. 14 CHAPTER 1. INTRODUCTION 1.3.3 Classiﬁcation of Robots Robot manipulators can be classiﬁed by several criteria, such as their power source, or way in which the joints are actuated, their geometry, or kinematic structure, their intended application area, or their method of control. Such classiﬁcation is useful primarily in order to determine which robot is right for a given task. For example, an hydraulic robot would not be suitable for food handling or clean room applications, whereas a SCARA robot would not be suitable for work in a foundry. We explain this in more detail below. Power Source Typically, robots are either electrically, hydraulically, or pneumatically powered. Hydraulic actuators are unrivaled in their speed of response and torque producing capability. Therefore hydraulic robots are used primarily for lifting heavy loads. The drawbacks of hydraulic robots are that they tend to leak hydraulic ﬂuid, require much more peripheral equipment, such as pumps, which also requires more maintenance, and they are noisy. Robots driven by DC- or AC-servo motors are increasingly popular since they are cheaper, cleaner and quieter. Pneumatic robots are inexpensive and simple but cannot be controlled precisely. As a result, pneumatic robots are limited in their range of applications and popularity. Application Area The largest projected area of future application of robots is in assembly. Therefore, robots are often classiﬁed by application into assembly and non-assembly robots. Assembly robots tend to be small, electrically driven and either revolute or SCARA (described below) in design. The main nonassembly application areas to date have been in welding, spray painting, material handling, and machine loading and unloading. Method of Control Robots are classiﬁed by control method into servo and non-servo robots. The earli- est robots were non-servo robots. These robots are essentially open-loop devices whose movement is limited to predetermined mechanical stops, and they are useful primarily for materials transfer. In fact, according to the deﬁnition given previously, ﬁxed stop robots hardly qualify as robots. Servo robots use closed-loop computer control to determine their motion and are thus capable of being truly multifunctional, reprogrammable devices. Servo controlled robots are further classiﬁed according to the method that the controller uses to guide the end-eﬀector. The simplest type of robot in this class is the point-to-point robot. A point-to-point robot can be taught a discrete set of points but there is no control on the path of the end-eﬀector in between taught points. Such robots are usually taught a series of points with a teach pendant. The points are then stored and played back. Point-to- point robots are severely limited in their range of applications. In continuous path robots, on the other hand, the entire path of the end-eﬀector can be controlled. For example, the robot end-eﬀector can be taught to follow a straight line between two points or even to 1.3. COMPONENTS AND STRUCTURE OF ROBOTS 15 follow a contour such as a welding seam. In addition, the velocity and/or acceleration of the end-eﬀector can often be controlled. These are the most advanced robots and require the most sophisticated computer controllers and software development. Geometry Most industrial manipulators at the present time have six or fewer degrees-of-freedom. These manipulators are usually classiﬁed kinematically on the basis of the ﬁrst three joints of the arm, with the wrist being described separately. The majority of these manipulators fall into one of ﬁve geometric types: articulate (RRR), spherical (RRP), SCARA (RRP), cylindrical (RPP), or cartesian (PPP). We discuss each of these in detail below. Each of these ﬁve conﬁgurations are serial link robots. A sixth and fundamentally distinct class of manipulators is the so-called parallel robot. In a parallel conﬁguration the links are arranged in a closed rather than open kinematic chain. We include a discussion of the parallel robot for completeness as parallel robots are becoming increasingly common. 1.3.4 Common Kinematic Arrangements Articulated Conﬁguration (RRR) The articulated manipulator is also called a revolute, or anthropomorphic manipulator. The ABB IRB1400 articulated arm is shown in Figure 1.3. A common revolute joint design Figure 1.3: The ABB IRB1400 Robot. Photo courtesy of ABB is the parallelogram linkage such as the Motoman SK16, shown in Figure 1.4. In both of these arrangements joint axis z2 is parallel to z1 and both z1 and z2 are perpendicular to z0. The structure and terminology associated with the elbow manipulator are shown in Figure 1.5. Its workspace is shown in Figure 1.6. The revolute conﬁguration provides for relatively large freedom of movement in a compact space. The parallelogram linkage, although less dextrous typically than the elbow manipulator conﬁguration, nevertheless 16 CHAPTER 1. INTRODUCTION Figure 1.4: The Motoman SK16 manipulator. z1 z0 z2 θ3θ2 θ1 Shoulder Forearm Elbow Base Body Figure 1.5: Structure of the elbow manipulator. has several advantages that make it an attractive and popular design. The most notable feature of the parallelogram linkage conﬁguration is that the actuator for joint 3 is located on link 1. Since the weight of the motor is born by link 1, links 2 and 3 can be made more lightweight and the motors themselves can be less powerful. Also the dynamics of the parallelogram manipulator are simpler than those of the elbow manipulator, thus making it easier to control. Spherical Conﬁguration (RRP) By replacing the third or elbow joint in the revolute conﬁguration by a prismatic joint one obtains the spherical conﬁguration shown in Figure 1.7. The term spherical conﬁguration derives from the fact that the spherical coordinates deﬁning the position of the end-eﬀector with respect to a frame whose origin lies at the intersection of the axes z1 and z2 are the same as the ﬁrst three joint variables. Figure 1.8 shows the Stanford Arm, one of the most well-known spherical robots. The workspace of a spherical manipulator is shown in 1.3. COMPONENTS AND STRUCTURE OF ROBOTS 17 θ3 θ2 SideTop θ1 Figure 1.6: Workspace of the elbow manipulator. z1 z0 θ2 θ1 d3 z2 Figure 1.7: The spherical manipulator conﬁguration. Figure 1.9. SCARA Conﬁguration (RRP) The so-called SCARA (for Selective Compliant Articulated Robot for Assembly) shown in Figure 1.10 is a popular conﬁguration, which, as its name suggests, is tailored for assembly operations. Although the SCARA has an RRP structure, it is quite diﬀerent from the spherical conﬁguration in both appearance and in its range of applications. Unlike the spherical design, which has z0, z1, z2 mutually perpendicular, the SCARA has z0, z1, z2 parallel. Figure 1.11 shows the Epson E2L653S, a manipulator of this type. The SCARA manipulator workspace is shown in Figure 1.12. Cylindrical Conﬁguration (RPP) The cylindrical conﬁguration is shown in Figure 1.13. The ﬁrst joint is revolute and produces a rotation about the base, while the second and third joints are prismatic. As the name 18 CHAPTER 1. INTRODUCTION Figure 1.8: The Stanford Arm. Photo courtesy of the Coordinated Science Lab, University of Illinois at Urbana-Champaign. suggests, the joint variables are the cylindrical coordinates of the end-eﬀector with respect to the base. A cylindrical robot, the Seiko RT3300, is shown in Figure 1.14, with its workspace shown in Figure 1.15. Cartesian conﬁguration (PPP) A manipulator whose ﬁrst three joints are prismatic is known as a cartesian manipulator, shown in Figure 1.16. For the Cartesian manipulator the joint variables are the Cartesian coordinates of the end-eﬀector with respect to the base. As might be expected the kinematic description of this manipulator is the simplest of all conﬁgurations. Cartesian conﬁgurations are useful for table-top assembly applications and, as gantry robots, for transfer of material or cargo. An example of a cartesian robot, from Epson-Seiko, is shown in Figure 1.17. The workspace of a Cartesian manipulator is shown in Figure 1.18. Parallel Manipulator A parallel manipulator is one in which the links form a closed chain. More speciﬁcally, a parallel manipulator has two or more independent kinematic chains connecting the base to the end-eﬀector. Figure 1.19 shows the ABB IRB 940 Tricept robot, which has a parallel conﬁguration. The closed chain kinematics of parallel robots can result in greater structural rigidity, and hence greater accuracy, than open chain robots. The kinematic description of parallel robots fundamentally diﬀerent from that of serial link robots and therefore requires diﬀerent methods of analysis. 1.3. COMPONENTS AND STRUCTURE OF ROBOTS 19 Figure 1.9: Workspace of the spherical manipulator. θ1 z0 z1 z2 θ2 d3 Figure 1.10: The SCARA (Selective Compliant Articulated Robot for Assembly). 1.3.5 Robotic Systems A robot manipulator should be viewed as more than just a series of mechanical linkages. The mechanical arm is just one component to an overall Robotic System, shown in Figure 1.20, which consists of the arm, external power source, end-of-arm tooling, external and internal sensors, computer interface, and control computer. Even the programmed software should be considered as an integral part of the overall system, since the manner in which the robot is programmed and controlled can have a major impact on its performance and subsequent range of applications. 20 CHAPTER 1. INTRODUCTION Figure 1.11: The Epson E2L653S SCARA Robot. Photo Courtesy of Epson. Figure 1.12: Workspace of the SCARA manipulator. 1.3.6 Accuracy and Repeatability The accuracy of a manipulator is a measure of how close the manipulator can come to a given point within its workspace. Repeatability is a measure of how close a manipu- lator can return to a previously taught point. Most present day manipulators are highly repeatable but not very accurate. The primary method of sensing positioning errors in most cases is with position encoders located at the joints, either on the shaft of the motor that actuates the joint or on the joint itself. There is typically no direct measurement of the end-eﬀector position and orientation. One must rely on the assumed geometry of the manipulator and its rigidity to infer (i.e., to calculate) the end-eﬀector position from the measured joint angles. Accuracy is aﬀected therefore by computational errors, machining accuracy in the construction of the manipulator, ﬂexibility eﬀects such as the bending of the links under gravitational and other loads, gear backlash, and a host of other static and dynamic eﬀects. It is primarily for this reason that robots are designed with extremely high rigidity. Without high rigidity, accuracy can only be improved by some sort of direct 1.3. COMPONENTS AND STRUCTURE OF ROBOTS 21 θ1 d3 z2 z0 z1 d2 Figure 1.13: The cylindrical manipulator conﬁguration. Figure 1.14: The Seiko RT3300 Robot. Photo courtesy of Seiko. sensing of the end-eﬀector position, such as with vision. Once a point is taught to the manipulator, however, say with a teach pendant, the above eﬀects are taken into account and the proper encoder values necessary to return to the given point are stored by the controlling computer. Repeatability therefore is aﬀected primarily by the controller resolution. Controller resolution means the smallest increment of motion that the controller can sense. The resolution is computed as the total distance traveled by the tip divided by 2n, where n is the number of bits of encoder accuracy. In this context, linear axes, that is, prismatic joints, typically have higher resolution than revolute joints, since the straight line distance traversed by the tip of a linear axis between two points is less than the corresponding arclength traced by the tip of a rotational link. In addition, as we will see in later chapters, rotational axes usually result in a large amount of kinematic and dynamic coupling among the links with a resultant accumulation of errors and a more diﬃcult control problem. One may wonder then what the advantages of revolute joints are in manipulator design. The answer lies primarily in the increased dexterity and compactness of revolute joint designs. For example, Figure 1.21 shows that 22 CHAPTER 1. INTRODUCTION Figure 1.15: Workspace of the cylindrical manipulator. d2 z1 z0 d1 d3 z2 Figure 1.16: The cartesian manipulator conﬁguration. for the same range of motion, a rotational link can be made much smaller than a link with linear motion. Thus manipulators made from revolute joints occupy a smaller working volume than manipulators with linear axes. This increases the ability of the manipulator to work in the same space with other robots, machines, and people. At the same time revolute joint manipulators are better able to maneuver around obstacles and have a wider range of possible applications. 1.3.7 Wrists and End-Eﬀectors The wrist of a manipulator refers to the joints in the kinematic chain between the arm and hand. The wrist joints are nearly always all revolute. It is increasingly common to design manipulators with spherical wrists, by which we mean wrists whose three joint axes intersect at a common point. The spherical wrist is represented symbolically in Figure 1.22. The spherical wrist greatly simpliﬁes the kinematic analysis, eﬀectively allowing one to decouple the positioning and orientation of an object to as great an extent as possible. 1.3. COMPONENTS AND STRUCTURE OF ROBOTS 23 Figure 1.17: The Epson Cartesian Robot. Photo courtesy of Epson. Figure 1.18: Workspace of the cartesian manipulator. Typically therefore, the manipulator will possess three positional degrees-of-freedom, which are produced by three or more joints in the arm. The number of orientational degrees-of- freedom will then depend on the degrees-of-freedom of the wrist. It is common to ﬁnd wrists having one, two, or three degrees-of-freedom depending of the application. For example, the SCARA robot shown in Figure 1.11 has four degrees-of-freedom: three for the arm, and one for the wrist, which has only a roll about the ﬁnal z-axis. It has been said that a robot is only as good as its hand or end-eﬀector. The arm and wrist assemblies of a robot are used primarily for positioning the end-eﬀector and any tool it may carry. It is the end-eﬀector or tool that actually performs the work. The simplest type of end-eﬀectors are grippers, such as shown in Figure 1.23 which usually are capable of only two actions, opening and closing. While this is adequate for materials transfer, some parts handling, or gripping simple tools, it is not adequate for other tasks such as welding, assembly, grinding, etc. A great deal of research is therefore being devoted to the design of special purpose end-eﬀectors as well as tools that can be rapidly changed as the task dictates. There is also much research being devoted to the development of anthropomorphic hands. 24 CHAPTER 1. INTRODUCTION Figure 1.19: The ABB IRB940 Tricept Parallel Robot. Photo courtesy of ABB. Power supply \u000f\u000f Input device or teach pendant oo // Computer controller oo // OO \u000f\u000f Mechanical arm OO \u000f\u000f Program storage or network End-of-arm tooling Figure 1.20: Components of a robotic system. Such hands are being developed both for prosthetic use and for use in manufacturing. Since we are concerned with the analysis and control of the manipulator itself and not in the particular application or end-eﬀector, we will not discuss end-eﬀector design or the study of grasping and manipulation. 1.4 Outline of the Text A typical application involving an industrial manipulator is shown in Figure 1.24. The manipulator is shown with a grinding tool which it must use to remove a certain amount of metal from a surface. In the present text we are concerned with the following question: d d Figure 1.21: Linear vs. rotational link motion. 1.4. OUTLINE OF THE TEXT 25 Yaw RollPitch Figure 1.22: Structure of a spherical wrist. Figure 1.23: Angular Jaw and Parallel Jaw Grippers. What are the basic issues to be resolved and what must we learn in order to be able to program a robot to perform tasks such as the above? The ability to answer this question for a full six degree-of-freedom manipulator repre- sents the goal of the present text. The answer itself is too complicated to be presented at this point. We can, however, use the simple two-link planar mechanism to illustrate some of the major issues involved and to preview the topics covered in this text. Suppose we wish to move the manipulator from its home position to position A, from which point the robot is to follow the contour of the surface S to the point B, at constant velocity, while maintaining a prescribed force F normal to the surface. In so doing the robot will cut or grind the surface according to a predetermined speciﬁcation. Problem 1: Forward Kinematics The ﬁrst problem encountered is to describe both the position of the tool and the locations A and B (and most likely the entire surface S) with respect to a common coordinate system. In Chapter 2 we give some background on representations of coordinate systems 26 CHAPTER 1. INTRODUCTION B F A S Home Camera Figure 1.24: Two-link planar robot example. and transformations among various coordinate systems. Typically, the manipulator will be able to sense its own position in some manner using internal sensors (position encoders) located at joints 1 and 2, which can measure directly the joint angles θ1 and θ2. We also need therefore to express the positions A and B in terms of these joint angles. This leads to the forward kinematics problem studied in Chapter 3, which is to determine the position and orientation of the end-eﬀector or tool in terms of the joint variables. It is customary to establish a ﬁxed coordinate system, called the world or base frame to which all objects including the manipulator are referenced. In this case we establish the base coordinate frame o0x0y0 at the base of the robot, as shown in Figure 1.25. The y0 x0 θ1 x1 x2 θ2 y1 y2 Figure 1.25: Coordinate frames for two-link planar robot. coordinates (x, y) of the tool are expressed in this coordinate frame as x = x2 = α1 cos θ1 + α2 cos(θ1 + θ2) (1.1) y = y2 = α1 sin θ1 + α2 sin(θ1 + θ2), (1.2) 1.4. OUTLINE OF THE TEXT 27 in which α1 and α2 are the lengths of the two links, respectively. Also the orientation of the tool frame relative to the base frame is given by the direction cosines of the x2 and y2 axes relative to the x0 and y0 axes, that is, x2 · x0 = cos(θ1 + θ2); x2 · y0 = sin(θ1 + θ2) (1.3) y2 · x0 = sin(θ1 + θ2); y2 · y0 = sin(θ1 + θ2) which we may combine into an orientation matrix [ x2 · x0 y2 · x0 x2 · y0 y2 · y0 ] = [ cos(θ1 + θ2) − sin(θ1 + θ2) sin(θ1 + θ2) cos(θ1 + θ2) ] . (1.4) These equations (1.1-1.4) are called the forward kinematic equations. For a six degree-of-freedom robot these equations are quite complex and cannot be written down as easily as for the two-link manipulator. The general procedure that we discuss in Chapter 3 establishes coordinate frames at each joint and allows one to transform systematically among these frames using matrix transformations. The procedure that we use is referred to as the Denavit-Hartenberg convention. We then use homogeneous coordinates and homogeneous transformations to simplify the transformation among coordinate frames. Problem 2: Inverse Kinematics Now, given the joint angles θ1, θ2 we can determine the end-eﬀector coordinates x and y. In order to command the robot to move to location B we need the inverse; that is, we need the joint variables θ1, θ2 in terms of the x and y coordinates of B. This is the problem of Inverse Kinematics. In other words, given x and y in the forward kinematic equations (1.1-1.2), we wish to solve for the joint angles. Since the forward kinematic equations are nonlinear, a solution may not be easy to ﬁnd nor is there a unique solution in general. We can see, for example, in the case of a two-link planar mechanism that there may be no solution, if the given (x, y) coordinates are out of reach of the manipulator. If the given (x, y) coordinates are within the manipulator’s reach there may be two solutions as shown in Figure 1.26, the so-called elbow up and elbow down conﬁgurations, or there may be exactly one solution if the manipulator must be fully extended to reach the point. There may even be an inﬁnite number of solutions in some cases (Problem 1.25). Consider the diagram of Figure 1.27. Using the Law of Cosines we see that the angle θ2 is given by cos θ2 = x2 + y2 − α2 1 − α2 2 2α1α2 := D. (1.5) We could now determine θ2 as θ2 = cos −1(D). (1.6) 28 CHAPTER 1. INTRODUCTION elbow up elbow down Figure 1.26: Multiple inverse kinematic solutions. x c α1 α2 θ1 θ2 y Figure 1.27: Solving for the joint angles of a two-link planar arm. However, a better way to ﬁnd θ2 is to notice that if cos(θ2) is given by (1.5) then sin(θ2) is given as sin(θ2) = ± √ 1 − D2 (1.7) and, hence, θ2 can be found by θ2 = tan −1 ± √1 − D2 D . (1.8) The advantage of this latter approach is that both the elbow-up and elbow-down solu- tions are recovered by choosing the positive and negative signs in (1.8), respectively. It is left as an exercise (Problem 1.19) to show that θ1 is now given as θ1 = tan −1(y/x) − tan −1 ( α2 sin θ2 α1 + α2 cos θ2 ) . (1.9) Notice that the angle θ1, depends on θ2. This makes sense physically since we would expect to require a diﬀerent value for θ1, depending on which solution is chosen for θ2. 1.4. OUTLINE OF THE TEXT 29 Problem 3: Velocity Kinematics In order to follow a contour at constant velocity, or at any prescribed velocity, we must know the relationship between the velocity of the tool and the joint velocities. In this case we can diﬀerentiate Equations (1.1) and (1.2) to obtain ˙x = −α1 sin θ1 · ˙θ1 − α2 sin(θ1 + θ2)( ˙θ1 + ˙θ2) (1.10) ˙y = α1 cos θ1 · ˙θ1 + α2 cos(θ1 + θ2)( ˙θ1 + ˙θ2). Using the vector notation x = [ x y ] and θ = [ θ1 θ2 ] we may write these equations as ˙x = [ −α1 sin θ1 − α2 sin(θ1 + θ2) −α2 sin(θ1 + θ2) α1 cos θ1 + α2 cos(θ1 + θ2) α2 cos(θ1 + θ2) ] ˙θ (1.11) = J ˙θ. The matrix J deﬁned by (1.11) is called the Jacobian of the manipulator and is a fundamental object to determine for any manipulator. In Chapter 5 we present a systematic procedure for deriving the Jacobian for any manipulator in the so-called cross-product form. The determination of the joint velocities from the end-eﬀector velocities is conceptually simple since the velocity relationship is linear. Thus the joint velocities are found from the end-eﬀector velocities via the inverse Jacobian ˙θ = J −1 ˙x (1.12) where J −1 is given by J −1 = 1 α1α2sθ2 [ α2cθ1+θ2 α2sθ1+θ2 −α1cθ1 − α2cθ1+θ2 −α1sθ1 − α2sθ1+θ2 ] (1.13) in which cθ and sθ denote respectively cos θ and sin θ. The determinant, det J, of the Ja- cobian in (1.11) is α1α2 sin θ2. The Jacobian does not have an inverse, therefore, when θ2 = 0 or π, in which case the manipulator is said to be in a singular conﬁguration, such as shown in Figure 1.28 for θ2 = 0. The determination of such singular conﬁgurations is important for several reasons. At singular conﬁgurations there are inﬁnitesimal motions that are unachievable; that is, the manipulator end-eﬀector cannot move in certain direc- tions. In the above cases the end eﬀector cannot move in the direction parallel to x2, from a singular conﬁguration. Singular conﬁgurations are also related to the non-uniqueness of solutions of the inverse kinematics. For example, for a given end-eﬀector position, there are in general two possible solutions to the inverse kinematics. Note that the singular conﬁgu- ration separates these two solutions in the sense that the manipulator cannot go from one conﬁguration to the other without passing through the singularity. For many applications it is important to plan manipulator motions in such a way that singular conﬁgurations are avoided. 30 CHAPTER 1. INTRODUCTION θ1 y0 x0 θ2 =0α1 α2 Figure 1.28: A singular conﬁguration. Problem 4: Path Planning and Trajectory Generation The robot control problem is typically decomposed heirarchically into three tasks: path planning, trajectory generation, and trajectory tracking. The path planning problem, con- sidered in Chapter 7, is to determine a path in task space (or conﬁguration space) to move the robot to a goal position while avoiding collisions with objects in its workspace. These paths are encode position information without timing considerations, i.e. without consider- ing velocities and accelerations along the planned paths. The tractory generation problem, considered in Chapter 8 is to generate reference trajectories that determine the time history of the manipulator along a given path or between initial and ﬁnal conﬁgurations. Problem 5: Vision Cameras have become reliable and relatively inexpensive sensors in many robotic applica- tions. Unlike joint sensors, which give information about the internal conﬁguration of the robot, cameras can be used not only to measure the position of the robot but also to locate objects external to the robot in its workspace. In Chapter 6 we discuss the use of cameras to obtain position and orientation of objects. Problem 6: Dynamics A robot manipulator is basically a positioning device. To control the position we must know the dynamic properties of the manipulator in order to know how much force to exert on it to cause it to move: too little force and the manipulator is slow to react; too much force and the arm may crash into objects or oscillate about its desired position. Deriving the dynamic equations of motion for robots is not a simple task due to the large number of degrees of freedom and nonlinearities present in the system. In Chapter 9 we develop techniques based on Lagrangian dynamics for systematically deriving the equations of motion of such a system. In addition to the rigid links, the complete description of 1.4. OUTLINE OF THE TEXT 31 robot dynamics includes the dynamics of the actuators that produce the forces and torques to drive the robot, and the dynamics of the drive trains that transmit the power from the actuators to the links. Thus, in Chapter 10 we also discuss actuator and drive train dynamics and their eﬀects on the control problem. Problem 7: Position Control Control theory is used in Chapters 10 and 11 to design control algorithms for the execution of programmed tasks. The motion control problem consists of the Tracking and Dis- turbance Rejection Problem, which is the problem of determining the control inputs necessary to follow, or track, a desired trajectory that has been planned for the manipula- tor, while simultaneously rejecting disturbances due to unmodelled dynamic eﬀects such as friction and noise. We detail the standard approaches to robot control based on fre- quency domain techniques. We also introduce the notion of feedforward control and the techniques of computed torque and inverse dynamics as a means for compensating the complex nonlinear interaction forces among the links of the manipulator. Robust control is introduced in Chapter 11 using the Second Method of Lyapunov. Chapter ?? pro- vides some additional advanced techniques from nonlinear control theory that are useful for controlling high performance robots. Problem 8: Force Control Once the manipulator has reached location A. it must follow the contour S maintaining a constant force normal to the surface. Conceivably, knowing the location of the object and the shape of the contour, we could carry out this task using position control alone. This would be quite diﬃcult to accomplish in practice, however. Since the manipulator itself possesses high rigidity, any errors in position due to uncertainty in the exact location of the surface or tool would give rise to extremely large forces at the end-eﬀector that could damage the tool, the surface, or the robot. A better approach is to measure the forces of interaction directly and use a force control scheme to accomplish the task. In Chapter 12 we discuss force control and compliance and discuss the two most common approaches to force control, hybrid control and impedance control. 32 CHAPTER 1. INTRODUCTION Chapter 2 RIGID MOTIONS AND HOMOGENEOUS TRANSFORMATIONS A large part of robot kinematics is concerned with the establishment of various coordinate systems to represent the positions and orientations of rigid objects and with transformations among these coordinate systems. Indeed, the geometry of three-dimensional space and of rigid motions plays a central role in all aspects of robotic manipulation. In this chapter we study the operations of rotation and translation and introduce the notion of homogeneous transformations.1 Homogeneous transformations combine the operations of rotation and translation into a single matrix multiplication, and are used in Chapter 3 to derive the so-called forward kinematic equations of rigid manipulators. We begin by examining representations of points and vectors in a Euclidean space equipped with multiple coordinate frames. Following this, we develop the concept of a rotation matrix, which can be used to represent relative orientations between coordinate frames. Finally, we combine these two concepts to build homogeneous transformation ma- trices, which can be used to simultaneously represent the position and orientation of one coordinate frame relative to another. Furthermore, homogeneous transformation matrices can be used to perform coordinate transformations. Such transformations allow us to easily move between diﬀerent coordinate frames, a facility that we will often exploit in subsequent chapters. 2.1 Representing Positions Before developing representation schemes for points and vectors, it is instructive to dis- tinguish between the two fundamental approaches to geometric reasoning: the synthetic 1Since we make extensive use of elementary matrix theory, the reader may wish to review Appendix A before beginning this chapter. 33 34 CHAPTER 2. RIGID MOTIONS AND HOMOGENEOUS TRANSFORMATIONS\u0000\u0002\u0001\u0003\u0001\u0004\u0006\u0005\u0004\u0001\u0000\u0006\u0007\u0003\u0007\b Figure 2.1: Two coordinate frames, a point p, and two vectors ⃗v1 and ⃗v2. approach and the analytic approach. In the former, one reasons directly about geomet- ric entities (e.g., points or lines), while in the latter, one represents these entities using coordinates or equations, and reasoning is performed via algebraic manipulations. Consider Figure 2.1. Using the synthetic approach, without ever assigning coordinates to points or vectors, one can say that x0 is perpendicular to y0, or that ⃗v1 × ⃗v2 deﬁnes a vector that is perpendicular to the plane containing ⃗v1 and ⃗v2, in this case pointing out of the page. In robotics, one typically uses analytic reasoning, since robot tasks are often deﬁned in a Cartesian workspace, using Cartesian coordinates. Of course, in order to assign coordinates it is necessary to specify a coordinate frame. Consider again Figure 2.1. We could specify the coordinates of the point p with respect to either frame o0x0y0 or frame o1x1y1. In the former case, we might assign to p the coordinate vector (5, 6)T , and in the latter case (−3, 4)T . So that the reference frame will always be clear, we will adopt a notation in which a superscript is used to denote the reference frame. Thus, we would write p0 = [ 5 6 ] , p 1 = [ −3 4 ] (2.1) Geometrically, a point corresponds to a speciﬁc location in space. We stress here that p ̸= p0 and p ̸= p1, i.e., p is a geometric entity, a point in space, while both p0 and p1 are coordinate vectors that represent the location of this point in space with respect to coordinate frames o0x0y0 and o1x1y1, respectively. Since the origin of a coordinate system is just a point in space, we can assign coordinates that represent the position of the origin of one coordinate system with respect to another. In Figure 2.1, for example, o 0 1 = [ 10 5 ] , o 1 0 = [ −10 5 ] . (2.2) In cases where there is only a single coordinate frame, or in which the reference frame is obvious, we will often omit the superscript. This is a slight abuse of notation, and the 2.2. REPRESENTING ROTATIONS 35 reader is advised to bear in mind the diﬀerence between the geometric entity called p and any particular coordinate vector that is assigned to represent p. The former is invariant with respect to the choice of coordinate systems, while the latter obviously depends on the choice of coordinate frames. While a point corresponds to a speciﬁc location in space, a vector speciﬁes a direction and a magnitude. Vectors can be used, for example, to represent displacements or forces. Therefore, while the point p is not equivalent to the vector ⃗v1, the displacement from the origin o0 to the point p is given by the vector ⃗v1. In this text, we will use the term vector to refer to what are sometimes called free vectors, i.e., vectors that are not constrained to be located at a particular point in space. Under this convention, it is clear that points and vectors are not equivalent, since points refer to speciﬁc locations in space, but a vector can be moved to any location in space. Under this convention, two vectors are equal if they have the same direction and the same magnitude. When assigning coordinates to vectors, we use the same notational convention that we used when assigning coordinates to points. Thus, ⃗v1 and ⃗v2 are geometric entities that are invariant with respect to the choice of coordinate systems, but the representation by coordinates of these vectors depends directly on the choice of reference coordinate frame. In the example of Figure 2.1, we would obtain v0 1 = [ 5 6 ] , v1 1 = [ 8 1 ] , v0 2 = [ −5 1 ] v1 2 = [ −3 4 ] . (2.3) In order to perform algebraic manipulations using coordinates, it is essential that all coordinate vectors be deﬁned with respect to the same coordinate frame. For example, an expression of the form v1 1 + v2 2 would make no sense geometrically. Thus, we see a clear need, not only for a representation system that allows points to be expressed with respect to various coordinate systems, but also for a mechanism that allows us to transform the coordinates of points that are expressed in one coordinate system into the appropriate coordinates with respect to some other coordinate frame. Such coordinate transformations and their derivations are the topic for much of the remainder of this chapter. 2.2 Representing Rotations In order to represent the relative position and orientation of one rigid body with respect to another, we will rigidly attach coordinate frames to each body, and then specify the geometric relationships between these coordinate frames. In Section 2.1 we have already seen how one can represent the position of the origin of one frame with respect to another frame. In this section, we address the problem of describing the orientation of one coordinate frame relative to another frame. We begin with the case of rotations in the plane, and then generalize our results to the case of orientations in a three dimensional space. 36 CHAPTER 2. RIGID MOTIONS AND HOMOGENEOUS TRANSFORMATIONS o0, o1 y0 y1 θ x1 sin θ cos θ x0 Figure 2.2: Coordinate frame o1x1y1 is oriented at an angle θ with respect to o0x0y0 2.2.1 Rotation in the plane Figure 2.2 shows two coordinate frames, with frame o1x1y1 being obtained by rotating frame o0x0y0 by an angle θ. Perhaps the most obvious way to represent the relative orientation of these two frames is to merely specify the angle of rotation, θ. There are two immediate disadvantages to such a representation. First, there is a discontinuity in the mapping from relative orientation to the value of θ in a neighborhood of θ = 0. In particular, for θ = 2π−ϵ, small changes in orientation can produce large changes in the value of θ (i.e., a rotation by ϵ causes θ to “wrap around” to zero). Second, this choice of representation does not scale well to the three dimensional case, with which we shall be primarily concerned in this text. A slightly less obvious way to specify the orientation is to specify the coordinate vectors for the axes of frame o1x1y1 with respect to coordinate frame o0x0y0. In particular, we can build a matrix of the form: R0 1 = [x 0 1|y0 1] . (2.4) A matrix in this form is called a rotation matrix. Rotation matrices have a number of special properties, which we will discuss below. In the two dimensional case, it is straightforward to compute the entries of this matrix. As illustrated in Figure 2.2, x 0 1 = [ cos θ sin θ ] , y0 1 = [ − sin θ cos θ ] , (2.5) which gives R0 1 = [ cos θ − sin θ sin θ cos θ ] . (2.6) Note that we have continued to use the notational convention of allowing the superscript to denote the reference frame. Thus, R0 1 is a matrix whose column vectors are the coordinates of the axes of frame o1x1y1 expressed relative to frame o0x0y0. 2.2. REPRESENTING ROTATIONS 37 Although we have derived the entries for R0 1 in terms of the angle θ, it is not necessary that we do so. An alternative approach, and one that scales nicely to the three dimensional case, is to build the rotation matrix by projecting the axes of frame o1x1y1 onto the coor- dinate axes of frame o0x0y0. Recalling that the dot product of two unit vectors gives the projection of one onto the other, we obtain x 0 1 = [ x1 · x0 x1 · y0 ] , y0 1 = [ y1 · x0 y1 · y0 ] , (2.7) which can be combined to obtain the rotation matrix R0 1 = [ x1 · x0 y1 · x0 x1 · y0 y1 · y0 ] . (2.8) Thus the columns of R0 1 specify the direction cosines of the coordinate axes of o1x1y1 relative to the coordinate axes of o0x0y0. For example, the ﬁrst column (x1·x0, x1·y0)T of R0 1 speciﬁes the direction of x1 relative to the frame o0x0y0. Note that the right hand sides of these equations are deﬁned in terms of geometric entities, and not in terms of their coordinates. Examining Figure 2.2 it can be seen that this method of deﬁning the rotation matrix by projection gives the same result as was obtained in equation (2.6). If we desired instead to describe the orientation of frame o0x0y0 with respect to the frame o1x1y1 (i.e., if we desired to use the frame o1x1y1 as the reference frame), we would construct a rotation matrix of the form R1 0 = [ x0 · x1 y0 · x1 x0 · y1 y0 · y1 ] . (2.9) Since the inner product is commutative, (i.e. xi · yj = yj · xi), we see that R1 0 = (R0 1) T . (2.10) In a geometric sense, the orientation of o0x0y0 with respect to the frame o1x1y1 is the inverse of the orientation of o1x1y1 with respect to the frame o0x0y0. Algebraically, using the fact that coordinate axes are always mutually orthogonal, it can readily be seen that (R0 1) T = (R0 1) −1. (2.11) Such a matrix is said to be orthogonal. The column vectors of R0 1 are of unit length and mutually orthogonal (Problem 2-1). It can also be shown (Problem 2-2) that det R0 1 = ±1. If we restrict ourselves to right-handed coordinate systems, as deﬁned in Appendix A, then det R0 1 = +1 (Problem 2-3). All rotation matrices have the properties of being orthogonal matrices with determinant +1. It is customary to refer to the set of all 2 × 2 rotation matrices by the symbol SO(2)2. The properties of such matrices are summarized in Figure 2.3. 2The notation SO(2) stands for Special Orthogonal group of order 2. 38 CHAPTER 2. RIGID MOTIONS AND HOMOGENEOUS TRANSFORMATIONS Every n × n rotation matrix R has the following properties (for n = 2, 3): • R ∈ SO(n) • R−1 ∈ SO(n) • R−1 = RT • The columns (and therefore the rows) of R are mutually orthogonal. • Each column (and therefore each row) of R is a unit vector. • det{R} = 1 Figure 2.3: Properties of Rotation Matrices To provide further geometric intuition for the notion of the inverse of a rotation matrix, note that in the two dimensional case, the inverse of the rotation matrix corresponding to a rotation by angle θ can also be easily computed simply by constructing the rotation matrix for a rotation by the angle −θ: [ cos(−θ) − sin(−θ) sin(−θ) cos(−θ) ] = [ cos θ sin θ − sin θ cos θ ] = [ cos θ − sin θ sin θ cos θ ]T . (2.12) 2.2.2 Rotations in three dimensions The projection technique described above scales nicely to the three dimensional case. In three dimensions, each axis of the frame o1x1y1z1 is projected onto coordinate frame o0x0y0z0. The resulting rotation matrix is given by R0 1 =   x1 · x0 y1 · x0 z1 · x0 x1 · y1 y1 · y0 z1 · y0 x1 · z1 y1 · z0 z1 · z0   . (2.13) As was the case for rotation matrices in two dimensions, matrices in this form are orthogonal, with determinant equal to 1. In this case, 3 × 3 rotation matrices belong to the group SO(3). The properties listed in Figure 2.3 also apply to rotation matrices in SO(3). Example 2.1 Suppose the frame o1x1y1z1 is rotated through an angle θ about the z0-axis, and it is desired to ﬁnd the resulting transformation matrix R0 1. Note that by convention the positive sense for the angle θ is given by the right hand rule; that is, a positive rotation of θ degrees about the z-axis would advance a right-hand threaded screw along the positive z-axis. From Figure 2.4 we see that 2.2. REPRESENTING ROTATIONS 39 y0 z0, z1 x0 y1 cos θ sin θ θ cos θ x1 sin θ Figure 2.4: Rotation about z0. x1 · x0 = cos θ y1 · x0 = − sin θ (2.14) x1 · y0 = sin θ y1 · y0 = cos θ z0 · z1 = 1 and all other dot products are zero. Thus the transformation R0 1 has a particularly simple form in this case, namely R0 1 =   cos θ − sin θ 0 sin θ cos θ 0 0 0 1   . (2.15) ⋄ The Basic Rotation Matrices The transformation (2.15) is called a basic rotation matrix (about the z-axis). In this case we ﬁnd it useful to use the more descriptive notation Rz,θ, instead of R0 1 to denote the matrix (2.15). It is easy to verify that the basic rotation matrix Rz,θ has the properties Rz,0 = I (2.16) Rz,θRz,φ = Rz,θ+φ (2.17) which together imply Rz,θ−1 = Rz,−θ. (2.18) 40 CHAPTER 2. RIGID MOTIONS AND HOMOGENEOUS TRANSFORMATIONS Similarly the basic rotation matrices representing rotations about the x and y-axes are given as (Problem 2-5) Rx,θ =   1 0 0 0 cos θ − sin θ 0 sin θ cos θ   (2.19) Ry,θ =   cos θ 0 sin θ 0 1 0 − sin θ 0 cos θ   (2.20) which also satisfy properties analogous to (2.16)-(2.18). Example 2.2 Consider the frames o0x0y0z0 and o1x1y1z1 shown in Figure 2.5. Pro- jecting the unit vectors x1, y1, z1 onto x0, y0, z0 gives the coordinates of x1, y1, z1 in the o0x0y0z0 frame. We see that the coordinates of x1 are ( 1√2 , 0, 1√2 )T , the coordinates of y1 are ( 1√2 , 0, −1√2 )T and the coordinates of z1 are (0, 1, 0)T . The rotation matrix R0 1 specifying the orientation of o1x1y1z1 relative to o0x0y0z0 has these as its column vectors, that is, R0 1 =    1√2 1√2 0 0 0 1 1√2 −1√2 0    . (2.21) z0 x1 y1 y0, z1 45◦x0 Figure 2.5: Deﬁning the relative orientation of two frames. ⋄ 2.3 Rotational Transformations Figure 2.6 shows a rigid object S to which a coordinate frame o1x1y1z1 is attached. Given the coordinates p1 of the point p (i.e., given the coordinates of p with respect to the frame 2.3. ROTATIONAL TRANSFORMATIONS 41 y1 z1 z0 x0 x1 oy0 S p Figure 2.6: Coordinate frame attached to a rigid body. o1x1y1z1), we wish to determine the coordinates of p relative to a ﬁxed reference frame o0x0y0z0. The coordinates p1 = (u, v, w)t satisfy the equation p = ux1 + vy1 + wz1. (2.22) In a similar way, we can obtain an expression for the coordinates p0 by projecting the point p onto the coordinate axes of the frame o0x0y0z0, giving p0 =   p · x0 p · y0 p · z0   . (2.23) Combining these two equations we obtain p0 =   (ux1 + vy1 + wz1) · x0 (ux1 + vy1 + wz1) · y0 (ux1 + vy1 + wz1) · z0   (2.24) =   ux1 · x0 + vy1 · x0 + wz1 · x0 ux1 · y0 + vy1 · y0 + wz1 · y0 ux1 · z0 + vy1 · z0 + wz1 · z0   (2.25) =   x1 · x0 y1 · x0 z1 · x0 x1 · y0 y1 · y0 z1 · y0 x1 · z0 y1 · z0 z1 · z0     u v w   . (2.26) But the matrix in this ﬁnal equation is merely the rotation matrix R0 1, which leads to p0 = R0 1p1. (2.27) 42 CHAPTER 2. RIGID MOTIONS AND HOMOGENEOUS TRANSFORMATIONS Thus, the rotation matrix R0 1 can be used not only to represent the orientation of coor- dinate frame o1x1y1z1 with respect to frame o0x0y0z0, but also to transform the coordinates of a point from one frame to another. Thus, if a given point is expressed relative to o1x1y1z1 by coordinates p1, then R0 1p1 represents the same point expressed relative to the frame o0x0y0z0. We have now seen how rotation matrices can be used to relate the orientation of one frame to another frame, and to assign coordinate representations to points and vectors. For example, given a point p in space, we have shown how a rotation matrix can be used to derive coordinates for p with respect to diﬀerent coordinate frames whose orientations are related by a rotation matrix. We can also use rotation matrices to represent rigid motions that correspond to pure rotation. Consider Figure 2.7. One corner of the block in Figure 2.7(a) is located at the point pa in space. Figure 2.7(b) shows the same block after it has been rotated about z0 by the angle π. In Figure 2.7(b), the same corner of the block is now located at point pb in space. It is possible to derive the coordinates for pb given only the coordinates for pa and the rotation matrix that corresponds to the rotation about z0. To see how this can be accomplished, imagine that a coordinate frame is rigidly attached to the block in Figure 2.7(a), such that it is coincident with the frame o0x0y0z0. After the rotation by π, the block’s coordinate frame, which is rigidly attached to the block, is also rotated by π. If we denote this rotated frame by o1x1y1z1, we obtain R0 1 = Rz,π =   −1 0 0 0 −1 0 0 0 1   . (2.28) In the local coordinate frame o1x1y1z1, the point pb has the coordinate representation p1 b. To obtain its coordinates with respect to frame o0x0y0z0, we merely apply the coordinate transformation equation (2.27), giving p0 b = Rz,πp1 b. (2.29) The key thing to notice is that the local coordinates, p1 b, of the corner of the block do not change as the block rotates, since they are deﬁned in terms of the block’s own coordinate frame. Therefore, when the block’s frame is aligned with the reference frame o0x0y0z0 (i.e., before the rotation is performed), the coordinates p1 b = p0 a, since before the rotation is performed, the point pa is coincident with the corner of the block. Therefore, we can substitute p0 a into the previous equation to obtain p0 b = Rz,πp0 a. (2.30) This equation shows us how to use a rotation matrix to represent a rotational motion. In particular, if the point pb is obtained by rotating the point pa as deﬁned by the rotation matrix R, then the coordinates of pb with respect to the reference frame are given by p0 b = Rp 0 a. (2.31) 2.3. ROTATIONAL TRANSFORMATIONS 43 z0 x0 x0 z0 pb y0 y0 (a) (b) pa Figure 2.7: The block in (b) is obtained by rotating the block in (a) by π about z0. y0 z0 x0 ⃗v1 ⃗v0 π 2 Figure 2.8: Rotating a vector about axis y0. 44 CHAPTER 2. RIGID MOTIONS AND HOMOGENEOUS TRANSFORMATIONS This same approach can be used to rotate vectors with respect to a coordinate frame, as the following example illustrates. Example 2.3 The vector ⃗v with coordinates v0 = (0, 1, 1)T is rotated about y0 by π 2 as shown in Figure 2.8. The resulting vector ⃗v1 has coordinates given by v0 1 = Ry, π 2 v0 (2.32) =   0 0 1 0 1 0 −1 0 0     0 1 1   =   1 1 0   . (2.33) ⋄ Thus, as we have now seen, a third interpretation of a rotation matrix R is as an operator acting on vectors in a ﬁxed frame. In other words, instead of relating the coordinates of a ﬁxed vector with respect to two diﬀerent coordinate frames, the expression (2.32) can represent the coordinates in o0x0y0z0 of a vector ⃗v1 which is obtained from a vector ⃗v by a given rotation. 2.3.1 Summary We have seen that a rotation matrix, either R ∈ SO(3) or R ∈ SO(2), can be interpreted in three distinct ways: 1. It represents a coordinate transformation relating the coordinates of a point p in two diﬀerent frames. 2. It gives the orientation of a transformed coordinate frame with respect to a ﬁxed coordinate frame. 3. It is an operator taking a vector and rotating it to a new vector in the same coordinate system. The particular interpretation of a given rotation matrix R that is being used must then be made clear by the context. 2.4 Composition of Rotations In this section we discuss the composition of rotations. It is important for subsequent chapters that the reader understand the material in this section thoroughly before moving on. 2.4.1 Rotation with respect to the current coordinate frame Recall that the matrix R0 1 in Equation (2.27) represents a rotational transformation between the frames o0x0y0z0 and o1x1y1z1. Suppose we now add a third coordinate frame o2x2y2z2 2.4. COMPOSITION OF ROTATIONS 45 related to the frames o0x0y0z0 and o1x1y1z1 by rotational transformations. As we saw above, a given point p can then be represented by coordinates speciﬁed with respect to any of these three frames: p0, p1 and p2. The relationship between these representations of p is p0 = R0 1p1 (2.34) p1 = R1 2p2 (2.35) p0 = R0 2p2 = R0 1R1 2p2 (2.36) where each Ri j is a rotation matrix, and equation (2.36) follows directly by substituting equation (2.35) into equation (2.34). Note that R0 1 and R0 2 represent rotations relative to the frame o0x0y0z0 while R1 2 represents a rotation relative to the frame o1x1y1z1. From equation (2.36) we can immediately infer the identity R0 2 = R0 1R1 2. (2.37) Equation (2.37) is the composition law for rotational transformations. It states that, in order to transform the coordinates of a point p from its representation p2 in the frame o2x2y2z2 to its representation p0 in the frame o0x0y0z0, we may ﬁrst transform to its coordinates p1 in the frame o1x1y1z1 using R1 2 and then transform p1 to p0 using R0 1. We may also interpret Equation (2.37) as follows. Suppose initially that all three of the coordinate frames coincide. We ﬁrst rotate the frame o2x2y2z2 relative to o0x0y0z0 according to the transformation R0 1. Then, with the frames o1x1y1z1 and o2x2y2z2 coincident, we rotate o2x2y2z2 relative to o1x1y1z1 according to the transformation R1 2. In each case we call the frame relative to which the rotation occurs the current frame. Example 2.4 Henceforth, whenever convenient we use the shorthand notation cθ = cos θ, sθ = sin θ for trigonometric functions. Suppose a rotation matrix R represents a rotation of φ degrees about the current y-axis followed by a rotation of θ degrees about the current z-axis. Refer to Figure 2.9. Then the matrix R is given by R = Ry,φRz,θ (2.38) =   cφ 0 sφ 0 1 0 −sφ 0 cφ     cθ −sθ 0 sθ cθ 0 0 0 1   =   cφcθ −cφsθ sφ sθ cθ 0 −sφcθ sφsθ cφ   . ⋄ It is important to remember that the order in which a sequence of rotations are carried out, and consequently the order in which the rotation matrices are multiplied together, is crucial. The reason is that rotation, unlike position, is not a vector quantity and is therefore not subject to the laws of vector addition, and so rotational transformations do not commute in general. 46 CHAPTER 2. RIGID MOTIONS AND HOMOGENEOUS TRANSFORMATIONS z0 x0 y0, y1x1 y2 φ += z0 x0 z1 x1 φ y1 x2 y2 x1 y0, y1 z1, z2z1, z2 x2 θθ Figure 2.9: Composition of rotations about current axes. Example 2.5 Suppose that the above rotations are performed in the reverse order, that is, ﬁrst a rotation about the current z-axis followed by a rotation about the current y-axis. Then the resulting rotation matrix is given by R′ = Rz,θRy,φ (2.39) =   cθ −sφ 0 sθ cθ 0 0 0 1     cφ 0 sφ 0 1 0 −sφ 0 cφ   =   cθcφ −sθ cθsφ sθcφ cθ sθsφ −sφ 0 cφ   . Comparing (2.38) and (2.39) we see that R ̸= R′. ⋄ 2.4.2 Rotation with respect to a ﬁxed frame Many times it is desired to perform a sequence of rotations, each about a given ﬁxed coordinate frame, rather than about successive current frames. For example we may wish to perform a rotation about x0 followed by a rotation about the y0 (and not y1!). We will refer to o0x0y0z0 as the ﬁxed frame. In this case the composition law given by equation (2.37) is not valid. It turns out that the correct composition law in this case is simply to multiply the successive rotation matrices in the reverse order from that given by (2.37). Note that the rotations themselves are not performed in reverse order. Rather they are performed about the ﬁxed frame instead of about the current frame. To see why this is so, consider the following argument. Let o0x0y0z0 be the reference frame. Let the frame o1x1y1z1 be obtained by performing a rotation with respect to the reference frame, and let this rotation be denoted by R0 1. Now let o2x2y2z2 be obtained 2.4. COMPOSITION OF ROTATIONS 47 by performing a rotation of frame o1x1y1z1 with respect to the reference frame (not with respect to o1x1y1z1 itself). We will, for the moment, denote this rotation about the ﬁxed frame by the matrix R. Finally, let R0 2 be the rotation matrix that denotes the orientation of frame o2x2y2z2 with respect to o0x0y0z0. We know that R0 2 ̸= R0 1R, since this equation applies for rotation about the current frame. Thus, we now seek to determine the matrix R1 2 such that R0 2 = R0 1R1 2. In order to ﬁnd this matrix, we shall proceed as follows. First, we will rotate frame o1x1y1z1 to align it with the reference frame. This can be done by postmultiplication of R0 1 by its inverse. Now, since the current frame is aligned with the reference frame, we can postmultiply by the rotation corresponding to R (i.e., now that the ﬁxed reference frame coincides with the current frame, rotation about the current frame is equivalent to rotation about the ﬁxed reference frame). Finally, we must undo the initial rotation, which corresponds to a postmultiplication of R0 1. When we concatenate these operations, we obtain the following: R0 2 = R0 1R1 2 (2.40) R0 2 = R0 1 [(R0 1) −1RR0 1] (2.41) R0 2 = RR0 1 (2.42) This procedure is an instance of a classical technique in engineering problem solving. When confronted with a diﬃcult problem, if one can transform the problem into an easier problem, it is often possible to transform the solution to this easier problem into a solution to the original, more diﬃcult problem. In our current case, we didn’t know how to solve the problem of rotating with respect to the ﬁxed reference frame. Therefore, we transformed the problem to the problem of rotating about the current frame (by using the rotation (R0 1) −1). We then transformed the solution for this simpler problem by applying the inverse of the rotation that we initially used to simplify the problem (i.e., we postmultiplied by R0 1). Example 2.6 Suppose that a rotation matrix R represents a rotation of φ degrees about y0 followed by a rotation of θ about the ﬁxed z0. Refer to Figure 2.10. Let p0, p1, and p2 be representations of a point p. Initially the ﬁxed and current axes are the same, namely o0x0y0z0 and therefore we can write as before p0 = Ry,φp1 (2.43) where Ry,φ is the basic rotation matrix about the y-axis. Now, since the second rotation is about the ﬁxed frame o0x0y0z0 and not the current frame o1x1y1z1, we cannot conclude that p1 = Rz,θp2 (2.44) since this would require that we interpret Rz,θ as being a rotation about z1. Applying the same process as above, we ﬁrst undo the previous rotation, then rotate about z0 and ﬁnally 48 CHAPTER 2. RIGID MOTIONS AND HOMOGENEOUS TRANSFORMATIONS y0 y1 θ z0 x0 x1 z0 x0 z0 x0 y0 z1z1 z2 x2 x1 y2 x1 φ θ φ += y0, y1 Figure 2.10: Composition of rotations about ﬁxed axes. reinstate the original transformation, that is, p1 = [ Ry,−φRz,θRy,φ] p2. (2.45) This is the correct expression, and not (2.44). Now, substituting (2.45) into (2.43) we obtain p0 = Ry,φp1 = Ry,φ [ Ry,−φRz,θRy,φ] p2 (2.46) = Rz,θRy,φp2. It is not necessary to remember the above derivation, only to note by comparing (2.46) with (2.38) that we obtain the same basic rotation matrices, but in the reverse order. ⋄ 2.4.3 Summary We can summarize the rule of composition of rotational transformations by the following recipe. Given a ﬁxed frame o0x0y0z0 a current frame o1x1y1z1, together with rotation matrix R0 1 relating them, if a third frame o2x2y2z2 is obtained by a rotation R performed relative to the current frame then postmultiply R0 1 by R = R1 2 to obtain R0 2 = R0 1R1 2. (2.47) If the second rotation is to be performed relative to the ﬁxed frame then it is both confusing and inappropriate to use the notation R1 2 to represent this rotation. Therefore, if we represent the rotation by R, we premultiply R0 1 by R to obtain R0 2 = RR0 1. (2.48) In each case R0 2 represents the transformation between the frames o0x0y0z0 and o2x2y2z2. The frame o2x2y2z2 that results in (2.47) will be diﬀerent from that resulting from (2.48). 2.5. PARAMETERIZATIONS OF ROTATIONS 49 ya ya, yb x0 φ zb θy0 za yb x1 y1 ψ zb, z1 xa z0, za xa xb (2)(1) (3) xb Figure 2.11: Euler angle representation. 2.5 Parameterizations of Rotations The nine elements rij in a general rotational transformation R are not independent quan- tities. Indeed a rigid body possesses at most three rotational degrees-of-freedom and thus at most three quantities are required to specify its orientation. This can be easily seen by examining the constraints that govern the matrices in SO(3): ∑ i r2 ij = 1, j ∈ {1, 2, 3} (2.49) r1ir1j + r2ir2j + r3ir3j = 0, i ̸= j. (2.50) Equation (2.49) follows from the fact the the columns of a rotation matrix are unit vectors, and (2.50) follows from the fact that columns of a rotation matrix are mutually orthogonal. Together, these constraints deﬁne six independent equations with nine unknowns, which implies that there are three free variables. In this section we derive three ways in which an arbitrary rotation can be represented using only three independent quantities: the Euler Angle representation, the roll-pitch- yaw representation, and the axis/angle representation. 2.5.1 Euler Angles A common method of specifying a rotation matrix in terms of three independent quantities is to use the so-called Euler Angles. Consider again the ﬁxed coordinate frame o0x0y0z0 and the rotated frame o1x1y1z1 shown in Figure 2.11. We can specify the orientation of the frame o1x1y1z1 relative to the frame o0x0y0z0 by three angles (φ, θ, ψ), known as Euler Angles, and obtained by three successive rotations as follows: First rotate about the z-axis by the angle φ. Next rotate about the current y-axis by the angle θ. Finally rotate about the current z-axis by the angle ψ. In Figure 2.11, frame oaxayaza represents the new coordinate frame after the rotation by φ, frame obxbybzb 50 CHAPTER 2. RIGID MOTIONS AND HOMOGENEOUS TRANSFORMATIONS represents the new coordinate frame after the rotation by θ, and frame o1x1y1z1 represents the ﬁnal frame, after the rotation by ψ. Frames oaxayaza and obxbybzb are shown in the ﬁgure only to help you visualize the rotations. In terms of the basic rotation matrices the resulting rotational transformation R0 1 can be generated as the product R0 1 = Rz,φRy,θRz,ψ (2.51) =   cφ −sφ 0 sφ cφ 0 0 0 1     cθ 0 sθ 0 1 0 −sθ 0 cθ     cψ −sψ 0 sψ cψ 0 0 0 1   =   cφcθcψ − sφsψ −cφcθsψ − sφcψ cφsθ sφcθcψ + cφsψ −sφcθsψ + cφcψ sφsθ −sθcψ sθsψ cθ   . (2.52) Consider now the problem of determining the angles φ, θ, and ψ, given the rotation matrix R =   r11 r12 r13 r21 r22 r23 r31 r32 r33   . (2.53) Suppose that not both of r13, r23 are zero. Then the above equations show that sθ ̸= 0, and hence that not both of r31, r32 are zero. If not both r13 and r23 are zero, then r33 ̸= ±1, and we have cθ = r33, sθ = ± √ 1 − r2 33 so θ = A tan (r33, √1 − r2 33 ) (2.54) or θ = A tan (r33, − √1 − r2 33 ) . (2.55) The function θ = A tan(x, y) computes the arc tangent function, where x and y are the cosine and sine, respectively, of the angle θ. This function uses the signs of x and y to select the appropriate quadrant for the angle θ. Note that if both x and y are zero, A tan is undeﬁned. If we choose the value for θ given by Equation (2.54), then sθ > 0, and φ = A tan(r13, r23) (2.56) ψ = A tan(−r31, r32). (2.57) If we choose the value for θ given by Equation (2.55), then sθ < 0, and φ = A tan(−r13, −r23) (2.58) ψ = A tan(r31, −r32). (2.59) 2.5. PARAMETERIZATIONS OF ROTATIONS 51 Thus there are two solutions depending on the sign chosen for θ. If r13 = r23 = 0, then the fact that R is orthogonal implies that r33 = ±1, and that r31 = r32 = 0. Thus R has the form R =   r11 r12 0 r21 r22 0 0 0 ±1.   (2.60) If r33 = 1, then cθ = 1 and sθ = 0, so that θ = 0. In this case (2.52) becomes   cφcψ − sφsψ −cφsψ − sφcψ 0 sφcψ + cφsψ −sφsψ + cφcψ 0 0 0 1   =   cφ+ψ −sφ+ψ 0 sφ+ψ cφ+ψ 0 0 0 1   =   r11 r12 0 r21 r22 0 0 0 1  (2.61) Thus the sum φ + ψ can be determined as φ + ψ = A tan(r11, r21) (2.62) = A tan(r11, −r12). Since only the sum φ + ψ can be determined in this case there are inﬁnitely many solutions. We may take φ = 0 by convention, and deﬁne ψ by (2.60). If r33 = −1, then cθ = −1 and sθ = 0, so that θ = π. In this case (2.52) becomes   −cφ−ψ −sφ−ψ 0 sφ−ψ cφ−ψ 0 0 0 1   =   r11 r12 0 r21 r22 0 0 0 −1   . (2.63) The solution is thus φ − ψ = A tan(−r11, −r12) = A tan(−r21, −r22). (2.64) As before there are inﬁnitely many solutions. 2.5.2 Roll, Pitch, Yaw Angles A rotation matrix R can also be described as a product of successive rotations about the principal coordinate axes x0, y0, and z0 taken in a speciﬁc order. These rotations deﬁne the roll, pitch, and yaw angles, which we shall also denote φ, θ, ψ, and which are shown in Figure 2.12. We specify the order of rotation as x − y − z, in other words, ﬁrst a yaw about x0 through an angle ψ, then pitch about the y0 by an angle θ, and ﬁnally roll about the z0 by an angle φ. Since the successive rotations are relative to the ﬁxed frame, the resulting 52 CHAPTER 2. RIGID MOTIONS AND HOMOGENEOUS TRANSFORMATIONS x0 Yaw Roll y0 z0 Pitch Figure 2.12: Roll, pitch, and yaw angles. transformation matrix is given by R0 1 = Rz,φRy,θRx,ψ (2.65) =   cφ −sφ 0 sφ cφ 0 0 0 1     cθ 0 sθ 0 1 0 −sθ 0 cθ     1 0 0 0 cψ −sψ 0 sψ cψ   =   cφcθ −sφcψ + cφsθsψ sφsψ + cφsθcψ sφcθ cφcψ + sφsθsψ −cφsψ + sφsθcψ −sθ cθsψ cθcψ   . Of course, instead of yaw-pitch-roll relative to the ﬁxed frames we could also interpret the above transformation as roll-pitch-yaw, in that order, each taken with respect to the current frame. The end result is the same matrix (2.65). The three angles, φ, θ, ψ, can be obtained for a given rotation matrix using a method that is similar to that used to derive the Euler angles above. We leave this as an exercise for the reader. 2.5.3 Axis/Angle Representation Rotations are not always performed about the principal coordinate axes. We are often interested in a rotation about an arbitrary axis in space. This provides both a convenient way to describe rotations, and an alternative parameterization for rotation matrices. Let k = (kx, ky, kz)T , expressed in the frame o0x0y0z0, be a unit vector deﬁning an axis. We wish to derive the rotation matrix Rk,θ representing a rotation of θ degrees about this axis. There are several ways in which the matrix Rk,θ can be derived. Perhaps the simplest way is to rotate the vector k into one of the coordinate axes, say z0, then rotate about z0 by θ and ﬁnally rotate k back to its original position. This is similar to the method that we employed above to derive the equation for rotation with respect to a ﬁxed reference frame. Referring to Figure 2.13 we see that we can rotate k into z0 by ﬁrst rotating about z0 by 2.5. PARAMETERIZATIONS OF ROTATIONS 53 β θ x0 y0 z0 kx ky kz k α Figure 2.13: Rotation about an arbitrary axis. −α, then rotating about y0 by −β. Since all rotations are performed relative to the ﬁxed frame o0x0y0z0 the matrix Rk,θ is obtained as Rk,θ = Rz,αRy,βRz,θRy,−βRz,−α. (2.66) From Figure 2.13, since k is a unit vector, we see that sin α = ky √k2 x + k2 y (2.67) cos α = kx√k2 x + k2 y (2.68) sin β = √k2 x + k2 y (2.69) cos β = kz. (2.70) Note that the ﬁnal two equations follow from the fact that k is a unit vector. Substituting (2.67)-(2.70) into (2.66) we obtain after some lengthy calculation (Problem 2.10) Rk,θ =   k2 xvθ + cθ kxkyvθ − kzsθ kxkzvθ + kysθ kxkyvθ + kzsθ k2 yvθ + cθ kykzvθ − kxsθ kxkzvθ − kysθ kykzvθ + kxsθ k2 z vθ + cθ   (2.71) where vθ = vers θ = 1 − cθ. In fact, any rotation matrix R ∈ S0(3) can be represented by a single rotation about a suitable axis in space by a suitable angle, R = Rk,θ (2.72) where k is a unit vector deﬁning the axis of rotation, and θ is the angle of rotation about k. Equation (2.72) is called the axis/angle representation of R. Given an arbitrary 54 CHAPTER 2. RIGID MOTIONS AND HOMOGENEOUS TRANSFORMATIONS rotation matrix R with components (rij), the equivalent angle θ and equivalent axis k are given by the expressions θ = cos −1 ( T r(R) − 1 2 ) (2.73) = cos −1 ( r11 + r22 + r33 − 1 2 ) where T r denotes the trace of R, and k = 1 2 sin θ   r32 − r23 r13 − r31 r21 − r12   . (2.74) These equations can be obtained by direct manipulation of the entries of the matrix given in equation (2.71). The axis/angle representation is not unique since a rotation of −θ about −k is the same as a rotation of θ about k, that is, Rk,θ = R−k,−θ. (2.75) If θ = 0 then R is the identity matrix and the axis of rotation is undeﬁned. Example 2.7 Suppose R is generated by a rotation of 90◦ about z0 followed by a rotation of 30◦ about y0 followed by a rotation of 60◦ about x0. Then R = Rx,60Ry,30Rz,90 (2.76) =    0 − √3 2 1 2 1 2 − √3 4 − 3 4√3 2 1 4 √3 4    . We see that T r(R) = 0 and hence the equivalent angle is given by (2.73) as θ = cos −1 (− 1 2 ) = 120 ◦. (2.77) The equivalent axis is given from (2.74) as k = ( 1 √3 , 1 2√3 − 1 2 , 1 2√3 + 1 2 )T . (2.78) ⋄ The above axis/angle representation characterizes a given rotation by four quantities, namely the three components of the equivalent axis k and the equivalent angle θ. However, since the equivalent axis k is given as a unit vector only two of its components are indepen- dent. The third is constrained by the condition that k is of unit length. Therefore, only 2.6. HOMOGENEOUS TRANSFORMATIONS 55 θ xA xB xC ⃗v1 ( ⃗v1) ( ⃗v2) ⃗v2 yB p2 p1 p3 yC ⃗v3 yA Figure 2.14: Homogeneous transformations in two dimensions. three independent quantities are required in this representation of a rotation R. We can represent the equivalent angle/axis by a single vector r as r = (rx, ry, rz) T = (θkx, θky, θkz) T . (2.79) Note, since k is a unit vector, that the length of the vector r is the equivalent angle θ and the direction of r is the equivalent axis k. 2.6 Homogeneous Transformations We have seen how to represent both positions and orientations. In this section we combine these two concepts to deﬁne homogeneous transformations. Consider Figure 2.14. In this ﬁgure, frame o1x1y1 is obtained by rotating frame o0x0y0 by angle θ, and frame o2x2y2 is obtained by subsequently translating frame o1x1y1 by the displacement ⃗v2. If we consider the point p1 as being rigidly attached to coordinate frame o0x0y0 as these transformations are performed, then p2 is the location of p1 after the rotation, and p3 is the location of p1 after the translation. If we are given the coordinates of the point p3 with respect to frame o2x2y2, and if we know the rotation and translation that are applied to obtain frame o2x2y2, it is straightforward to compute the coordinates of the point p3 with respect to o0x0y0. To see this, note the point p3 is displaced by the vector ⃗v3 from the origin of o0x0y0. Further, we see that ⃗v3 = ⃗v1 + ⃗v2. Therefore, to solve our problem, we need only ﬁnd coordinate assignments for the vectors ⃗v1 and ⃗v2 with respect to frame o0x0y0. Once we have these coordinate assignments, we can compute the coordinates for ⃗v3 with respect to o0x0y0 using the equation v0 3 = v0 1 + v0 2. We can obtain coordinates for the vector ⃗v1 by applying the rotation matrix to the coordinates that represent p2 in frame o1x1y1, 56 CHAPTER 2. RIGID MOTIONS AND HOMOGENEOUS TRANSFORMATIONS v0 1 = R0 1p1 2 (2.80) = R0 2p2 3, (2.81) where the second equality follows because the orientations of o1x1y1 and o2x2y2 are the same and because p1 2 = p2 3. If we denote the coordinate assignment for ⃗v2 by d0 2 (which denotes the displacement of the origin of o2x2y2, expressed relative to o0x0y0), we obtain p0 3 = R0 2p2 3 + d0 2. (2.82) Note that no part of the derivation above was dependent on the fact that we used a two-dimensional space. This same derivation can be applied in three dimensions to obtain the following rule for coordinate transformations. If frame o1x1y1z1 is obtained from frame o0x0y0z0 by ﬁrst applying a rotation speciﬁed by R0 1 followed by a translation given (with respect to o0x0y0z0) by d0 1, then the coordinates p0 are given by p0 = R0 1p1 + d0 1. (2.83) In this text, we will consider only geometric relationships between two coordinate sys- tems that can be expressed as the combination of a pure rotation and a pure translation. Deﬁnition 2.1 A transformation of the form given in Equation (2.83) is said to deﬁne a rigid motion if R is orthogonal. Note that the deﬁnition of a rigid motion includes reﬂections when det R = −1. In our case we will never have need for the most general rigid motion, so we assume always that R ∈ SO(3). If we have the two rigid motions p0 = R0 1p1 + d0 1 (2.84) and p1 = R1 2p2 + d1 2 (2.85) then their composition deﬁnes a third rigid motion, which we can describe by substituting the expression for p1 from (2.85) into (2.84) p0 = R0 1R1 2p2 + R0 1d1 2 + d0 1. (2.86) Since the relationship between p0 and p2 is also a rigid motion, we can equally describe it as p0 = R0 2p2 + d0 2. (2.87) 2.6. HOMOGENEOUS TRANSFORMATIONS 57 Comparing Equations (2.86) and (2.87) we have the relationships R0 2 = R0 1R1 2 (2.88) d0 2 = d0 1 + R0 1d1 2. (2.89) Equation (2.88) shows that the orientation transformations can simply be multiplied to- gether and Equation (2.89) shows that the vector from the origin o0 to the origin o2 has coordinates given by the sum of do 1 (the vector from o0 to o1 expressed with respect to o0x0y0z0) and R0 1d1 2 (the vector from o1 to o2, expressed in the orientation of the coordinate system o0x0y0z0). A comparison of this with the matrix identity [ R0 1 d0 1 0 1 ] [ R1 2 d2 1 0 1 ] = [ R0 1R1 2 R0 1d2 1 + d0 1 0 1 ] (2.90) where 0 denotes the row vector (0, 0, 0), shows that the rigid motions can be represented by the set of matrices of the form H = [ R d 0 1 ] ; R ∈ SO(3). (2.91) Using the fact that R is orthogonal it is an easy exercise to show that the inverse transfor- mation H −1 is given by H −1 = [ RT −RT d 0 1 ] . (2.92) Transformation matrices of the form (2.91) are called homogeneous transformations. In order to represent the transformation (2.83) by a matrix multiplication, one needs to augment the vectors p0 and p1 by the addition of a fourth component of 1 as follows. Set P 0 = [ p0 1 ] (2.93) P 1 = [ p1 1 ] . (2.94) The vectors P 0 and P 1 are known as homogeneous representations of the vectors p0 and p1, respectively. It can now be seen directly that the transformation (2.83) is equivalent to the (homogeneous) matrix equation P 0 = H 0 1 P 1 (2.95) The set of all 4 × 4 matrices H of the form (2.91) is denoted by E(3).3 A set of basic homogeneous transformations generating E(3) is given by Transx,a =     1 0 0 a 0 1 0 0 0 0 1 0 0 0 0 1     ; Rotx,α =     1 0 0 0 0 cα −sα 0 0 sα cα 0 0 0 0 1     (2.96) 3The notation E(3) stands for Euclidean group of order 3. 58 CHAPTER 2. RIGID MOTIONS AND HOMOGENEOUS TRANSFORMATIONS Transy,b =     1 0 0 0 0 1 0 b 0 0 1 0 0 0 0 1     ; Roty,β =     cβ 0 sβ 0 0 1 0 0 −sβ 0 cβ 0 0 0 0 1     (2.97) Transz,c =     1 0 0 0 0 1 0 0 0 0 1 c 0 0 0 1     ; Rotx,γ =     cγ −sγ 0 0 sγ cγ 0 0 0 0 1 0 0 0 0 1     (2.98) for translation and rotation about the x, y, z-axes, respectively. The most general homogeneous transformation that we will consider may be written now as H 0 1 =     nx sx ax dx ny sy ay dy nz sx az dz 0 0 0 1     = [ n s a d 0 0 0 1 ] . (2.99) In the above equation n = (nx, ny, nz)T is a vector representing the direction of x1 in the o0x0y0z0 system, s = (sx, sy, sz)T represents the direction of y1, and a = (ax, ay, az)T represents the direction of z1. The vector d = (dx, dy, dz)T represents the vector from the origin o0 to the origin o1 expressed in the frame o0x0y0z0. The rationale behind the choice of letters n, s and a is explained in Chapter 3. NOTE: The same interpretation regarding composition and ordering of transformations holds for 4 × 4 homogeneous transformations as for 3 × 3 rotations. Example 2.8 The homogeneous transformation matrix H that represents a rotation of α degrees about the current x-axis followed by a translation of b units along the current x-axis, followed by a translation of d units along the current z-axis, followed by a rotation of θ degrees about the current z-axis, is given by H = Rotx,αTransx,bTransz,dRotz,θ (2.100) =     1 0 0 0 0 cα −sα 0 0 sα cα 0 0 0 0 1         1 0 0 b 0 1 0 0 0 0 1 0 0 0 0 1         1 0 0 0 0 1 0 0 0 0 1 d 0 0 0 1         cθ −sθ 0 0 sθ cθ 0 0 0 0 1 0 0 0 0 1     =     cθ −sθ 0 b cαsα cαcθ −sα −sαd sαsθ sαcθ cα cαd 0 0 0 1     . ⋄ 2.6. HOMOGENEOUS TRANSFORMATIONS 59 The homogeneous representation (2.91) is a special case of homogeneous coordinates, which have been extensively used in the ﬁeld of computer graphics. There, one is, in addition, interested in scaling and/or perspective transformations. The most general ho- mogeneous transformation takes the form H = [ R3×3 d3×1 f 1×3 s1×1 ] = [ Rotation T ranslation perspective scale f actor ] . (2.101) For our purposes we always take the last row vector of H to be (0, 0, 0, 1), although the more general form given by (2.101) could be useful, for example, for interfacing a vision system into the overall robotic system or for graphic simulation. 60 CHAPTER 2. RIGID MOTIONS AND HOMOGENEOUS TRANSFORMATIONS Chapter 3 FORWARD KINEMATICS: THE DENAVIT-HARTENBERG CONVENTION In this chapter we develop the forward or conﬁguration kinematic equations for rigid robots. The forward kinematics problem is concerned with the relationship between the individual joints of the robot manipulator and the position and orientation of the tool or end-eﬀector. Stated more formally, the forward kinematics problem is to determine the position and orientation of the end-eﬀector, given the values for the joint variables of the robot. The joint variables are the angles between the links in the case of revolute or rotational joints, and the link extension in the case of prismatic or sliding joints. The forward kinematics problem is to be contrasted with the inverse kinematics problem, which will be studied in the next chapter, and which is concerned with determining values for the joint variables that achieve a desired position and orientation for the end-eﬀector of the robot. 3.1 Kinematic Chains As described in Chapter 1, a robot manipulator is composed of a set of links connected together by various joints. The joints can either be very simple, such as a revolute joint or a prismatic joint, or else they can be more complex, such as a ball and socket joint. (Recall that a revolute joint is like a hinge and allows a relative rotation about a single axis, and a prismatic joint permits a linear motion along a single axis, namely an extension or retraction.) The diﬀerence between the two situations is that, in the ﬁrst instance, the joint has only a single degree-of-freedom of motion: the angle of rotation in the case of a revolute joint, and the amount of linear displacement in the case of a prismatic joint. In contrast, a ball and socket joint has two degrees-of-freedom. In this book it is assumed throughout that all joints have only a single degree-of-freedom. Note that the assumption 61 62CHAPTER 3. FORWARD KINEMATICS: THE DENAVIT-HARTENBERG CONVENTION does not involve any real loss of generality, since joints such as a ball and socket joint (two degrees-of-freedom) or a spherical wrist (three degrees-of-freedom) can always be thought of as a succession of single degree-of-freedom joints with links of length zero in between. With the assumption that each joint has a single degree-of-freedom, the action of each joint can be described by a single real number: the angle of rotation in the case of a rev- olute joint or the displacement in the case of a prismatic joint. The objective of forward kinematic analysis is to determine the cumulative eﬀect of the entire set of joint variables. In this chapter we will develop a set of conventions that provide a systematic procedure for performing this analysis. It is, of course, possible to carry out forward kinematics analysis even without respecting these conventions, as we did for the two-link planar manipulator example in Chapter 1. However, the kinematic analysis of an n-link manipulator can be extremely complex and the conventions introduced below simplify the analysis consider- ably. Moreover, they give rise to a universal language with which robot engineers can communicate. A robot manipulator with n joints will have n + 1 links, since each joint connects two links. We number the joints from 1 to n, and we number the links from 0 to n, starting from the base. By this convention, joint i connects link i − 1 to link i. We will consider the location of joint i to be ﬁxed with respect to link i − 1. When joint i is actuated, link i moves. Therefore, link 0 (the ﬁrst link) is ﬁxed, and does not move when the joints are actuated. Of course the robot manipulator could itself be mobile (e.g., it could be mounted on a mobile platform or on an autonomous vehicle), but we will not consider this case in the present chapter, since it can be handled easily by slightly extending the techniques presented here. With the ith joint, we associate a joint variable, denoted by qi. In the case of a rev- olute joint, qi is the angle of rotation, and in the case of a prismatic joint, qi is the joint displacement: qi = { θi : joint i revolute di : joint i prismatic . (3.1) To perform the kinematic analysis, we rigidly attach a coordinate frame to each link. In particular, we attach oixiyizi to link i. This means that, whatever motion the robot executes, the coordinates of each point on link i are constant when expressed in the ith coordinate frame. Furthermore, when joint i is actuated, link i and its attached frame, oixiyizi, experience a resulting motion. The frame o0x0y0z0, which is attached to the robot base, is referred to as the inertial frame. Figure 3.1 illustrates the idea of attaching frames rigidly to links in the case of an elbow manipulator. Now suppose Ai is the homogeneous transformation matrix that expresses the position and orientation of oixiyizi with respect to oi−1xi−1yi−1zi−1. The matrix Ai is not constant, but varies as the conﬁguration of the robot is changed. However, the assumption that all joints are either revolute or prismatic means that Ai is a function of only a single joint variable, namely qi. In other words, Ai = Ai(qi). (3.2) 3.1. KINEMATIC CHAINS 63 θ1 θ3θ2 z2 z3 x0 z0 x1 x2 x3 y3 z1 y1 y2 y0 Figure 3.1: Coordinate frames attached to elbow manipulator. Now the homogeneous transformation matrix that expresses the position and orientation of ojxjyjzj with respect to oixiyizi is called, by convention, a transformation matrix, and is denoted by T i j . From Chapter 2 we see that T i j = Ai+1Ai+2 . . . Aj−1Aj if i < j T i j = I if i = j (3.3) T i j = (T j i ) −1 if j > i. By the manner in which we have rigidly attached the various frames to the corresponding links, it follows that the position of any point on the end-eﬀector, when expressed in frame n, is a constant independent of the conﬁguration of the robot. Denote the position and orientation of the end-eﬀector with respect to the inertial or base frame by a three-vector o 0 n (which gives the coordinates of the origin of the end-eﬀector frame with respect to the base frame) and the 3 × 3 rotation matrix R0 n, and deﬁne the homogeneous transformation matrix H = [ R0 n o 0 n 0 1 ] . (3.4) Then the position and orientation of the end-eﬀector in the inertial frame are given by H = T 0 n = A1(q1) · · · An(qn). (3.5) Each homogeneous transformation Ai is of the form Ai = [ Ri−1 i o i−1 i 0 1 ] . (3.6) Hence T i j = Ai+1 · · · Aj = [ Ri j o i j 0 1 ] . (3.7) 64CHAPTER 3. FORWARD KINEMATICS: THE DENAVIT-HARTENBERG CONVENTION The matrix Ri j expresses the orientation of ojxjyjzj relative to oixiyizi and is given by the rotational parts of the A-matrices as Ri j = Ri i+1 · · · Rj−1 j . (3.8) The coordinate vectors o i j are given recursively by the formula o i j = o i j−1 + Ri j−1o j−1 j , (3.9) These expressions will be useful in Chapter 5 when we study Jacobian matrices. In principle, that is all there is to forward kinematics! Determine the functions Ai(qi), and multiply them together as needed. However, it is possible to achieve a considerable amount of streamlining and simpliﬁcation by introducing further conventions, such as the Denavit-Hartenberg representation of a joint, and this is the objective of the remainder of the chapter. 3.2 Denavit Hartenberg Representation While it is possible to carry out all of the analysis in this chapter using an arbitrary frame attached to each link, it is helpful to be systematic in the choice of these frames. A commonly used convention for selecting frames of reference in robotic applications is the Denavit- Hartenberg, or D-H convention. In this convention, each homogeneous transformation Ai is represented as a product of four basic transformations Ai = Rotz,θiTransz,diTransx,aiRotx,αi (3.10) =     cθi −sθi 0 0 sθi cθi 0 0 0 0 1 0 0 0 0 1         1 0 0 0 0 1 0 0 0 0 1 di 0 0 0 1         1 0 0 ai 0 1 0 0 0 0 1 0 0 0 0 1         1 0 0 0 0 cαi −sαi 0 0 sαi cαi 0 0 0 0 1     =     cθi −sθicαi sθisαi aicθi sθi cθicαi −cθisαi aisθi 0 sαi cαi di 0 0 0 1     where the four quantities θi, ai, di, αi are parameters associated with link i and joint i. The four parameters ai, αi, di, and θi in (3.10) are generally given the names link length, link twist, link oﬀset, and joint angle, respectively. These names derive from speciﬁc aspects of the geometric relationship between two coordinate frames, as will become apparent below. Since the matrix Ai is a function of a single variable, it turns out that three of the above four quantities are constant for a given link, while the fourth parameter, θi for a revolute joint and di for a prismatic joint, is the joint variable. From Chapter 2 one can see that an arbitrary homogeneous transformation matrix can be characterized by six numbers, such as, for example, three numbers to specify the 3.2. DENAVIT HARTENBERG REPRESENTATION 65 z0x0θ a d y0 O0 x1 α y1z1 O1 Figure 3.2: Coordinate frames satisfying assumptions DH1 and DH2. fourth column of the matrix and three Euler angles to specify the upper left 3 × 3 rotation matrix. In the D-H representation, in contrast, there are only four parameters. How is this possible? The answer is that, while frame i is required to be rigidly attached to link i, we have considerable freedom in choosing the origin and the coordinate axes of the frame. For example, it is not necessary that the origin, oi, of frame i be placed at the physical end of link i. In fact, it is not even necessary that frame i be placed within the physical link; frame i could lie in free space — so long as frame i is rigidly attached to link i. By a clever choice of the origin and the coordinate axes, it is possible to cut down the number of parameters needed from six to four (or even fewer in some cases). In Section 3.2.1 we will show why, and under what conditions, this can be done, and in Section 3.2.2 we will show exactly how to make the coordinate frame assignments. 3.2.1 Existence and uniqueness issues Clearly it is not possible to represent any arbitrary homogeneous transformation using only four parameters. Therefore, we begin by determining just which homogeneous transfor- mations can be expressed in the form (3.10). Suppose we are given two frames, denoted by frames 0 and 1, respectively. Then there exists a unique homogeneous transformation matrix A that takes the coordinates from frame 1 into those of frame 0. Now suppose the two frames have two additional features, namely: (DH1) The axis x1 is perpendicular to the axis z0 (DH2) The axis x1 intersects the axis z0 as shown in Figure 3.2. Under these conditions, we claim that there exist unique numbers a, d, θ, α such that A = Rotz,θTransz,dTransx,aRotx,α. (3.11) 66CHAPTER 3. FORWARD KINEMATICS: THE DENAVIT-HARTENBERG CONVENTION Of course, since θ and α are angles, we really mean that they are unique to within a multiple of 2π. To show that the matrix A can be written in this form, write A as A = [ R0 1 o 0 1 0 1 ] (3.12) and let ri denote the ith column of the rotation matrix R0 1. We will now examine the implications of the two DH constraints. If (DH1) is satisﬁed, then x1 is perpendicular to z0 and we have x1 · z0 = 0. Expressing this constraint with respect to o0x0y0z0, using the fact that r1 is the representation of the unit vector x1 with respect to frame 0, we obtain 0 = x 0 1 · z0 0 (3.13) = [r11, r21, r31] T · [0, 0, 1] T (3.14) = r31. (3.15) Since r31 = 0, we now need only show that there exist unique angles θ and α such that R0 1 = Rx,θRx,α =   cθ −sθcα sθsα sθ cθcα −cθsα 0 sα cα   . (3.16) The only information we have is that r31 = 0, but this is enough. First, since each row and column of R0 1 must have unit length, r31 = 0 implies that r2 11 + r2 21 = 1, r2 32 + r2 33 = 1 (3.17) Hence there exist unique θ, α such that (r11, r21) = (cθ, sθ), (r33, r32) = (cα, sα). (3.18) Once θ and α are found, it is routine to show that the remaining elements of R0 1 must have the form shown in (3.16), using the fact that R0 1 is a rotation matrix. Next, assumption (DH2) means that the displacement between o0 and o1 can be ex- pressed as a linear combination of the vectors z0 and x1. This can be written as o1 = o0 + dz0 + ax1. Again, we can express this relationship in the coordinates of o0x0y0z0, and we obtain o 0 1 = o 0 0 + dz0 0 + ax 0 1 (3.19) =   0 0 0   + d   0 0 1   + a   cθ sθ 0   (3.20) =   acθ asθ d   . (3.21) 3.2. DENAVIT HARTENBERG REPRESENTATION 67 Combining the above results, we obtain (3.10) as claimed. Thus, we see that four param- eters are suﬃcient to specify any homogeneous transformation that satisﬁes the constraints (DH1) and (DH2). Now that we have established that each homogeneous transformation matrix satisfying conditions (DH1) and (DH2) above can be represented in the form (3.10), we can in fact give a physical interpretation to each of the four quantities in (3.10). The parameter a is the distance between the axes z0 and z1, and is measured along the axis x1. The angle α is the angle between the axes z0 and z1, measured in a plane normal to x1. The positive sense for α is determined from z0 to z1 by the right-hand rule as shown in Figure 3.3. The xi αi zi−1 xi θi zi−1 xi−1 zi Figure 3.3: Positive sense for αi and θi. parameter d is the distance between the origin o0 and the intersection of the x1 axis with z0 measured along the z0 axis. Finally, θ is the angle between x0 and x1 measured in a plane normal to z0. These physical interpretations will prove useful in developing a procedure for assigning coordinate frames that satisfy the constraints (DH1) and (DH2), and we now turn our attention to developing such a procedure. 3.2.2 Assigning the coordinate frames For a given robot manipulator, one can always choose the frames 0, . . . , n in such a way that the above two conditions are satisﬁed. In certain circumstances, this will require placing the origin oi of frame i in a location that may not be intuitively satisfying, but typically this will not be the case. In reading the material below, it is important to keep in mind that the choices of the various coordinate frames are not unique, even when constrained by the requirements above. Thus, it is possible that diﬀerent engineers will derive diﬀering, but equally correct, coordinate frame assignments for the links of the robot. It is very important to note, however, that the end result (i.e., the matrix T 0 n) will be the same, regardless of the assignment of intermediate link frames (assuming that the coordinate frames for link n coincide). We will begin by deriving the general procedure. We will then discuss various common special cases where it is possible to further simplify the homogeneous transformation matrix. 68CHAPTER 3. FORWARD KINEMATICS: THE DENAVIT-HARTENBERG CONVENTION To start, note that the choice of zi is arbitrary. In particular, from (3.16), we see that by choosing αi and θi appropriately, we can obtain any arbitrary direction for zi. Thus, for our ﬁrst step, we assign the axes z0, . . . , zn−1 in an intuitively pleasing fashion. Speciﬁcally, we assign zi to be the axis of actuation for joint i + 1. Thus, z0 is the axis of actuation for joint 1, z1 is the axis of actuation for joint 2, etc. There are two cases to consider: (i) if joint i + 1 is revolute, zi is the axis of revolution of joint i + 1; (ii) if joint i + 1 is prismatic, zi is the axis of translation of joint i + 1. At ﬁrst it may seem a bit confusing to associate zi with joint i + 1, but recall that this satisﬁes the convention that we established in Section 3.1, namely that joint i is ﬁxed with respect to frame i, and that when joint i is actuated, link i and its attached frame, oixiyizi, experience a resulting motion. Once we have established the z-axes for the links, we establish the base frame. The choice of a base frame is nearly arbitrary. We may choose the origin o0 of the base frame to be any point on z0. We then choose x0, y0 in any convenient manner so long as the resulting frame is right-handed. This sets up frame 0. Once frame 0 has been established, we begin an iterative process in which we deﬁne frame i using frame i − 1, beginning with frame 1. Figure 3.4 will be useful for understanding the process that we now describe. Figure 3.4: Denavit-Hartenberg frame assignment. In order to set up frame i it is necessary to consider three cases: (i) the axes zi−1, zi are not coplanar, (ii) the axes zi−1, zi intersect (iii) the axes zi−1, zi are parallel. Note that in both cases (ii) and (iii) the axes zi−1 and zi are coplanar. This situation is in fact quite common, as we will see in Section 3.3. We now consider each of these three cases. (i) zi−1 and zi are not coplanar: If zi−l and zi are not coplanar, then there exists a unique line segment perpendicular to both zi−1 and zi such that it connects both lines and it has minimum length. The line containing this common normal to zi−1 and zi deﬁnes xi, 3.2. DENAVIT HARTENBERG REPRESENTATION 69 and the point where this line intersects zi is the origin oi. By construction, both conditions (DH1) and (DH2) are satisﬁed and the vector from oi−1 to oi is a linear combination of zi−1 and xi. The speciﬁcation of frame i is completed by choosing the axis yi to form a right-hand frame. Since assumptions (DH1) and (DH2) are satisﬁed the homogeneous transformation matrix Ai is of the form (3.10). (ii) zi−1 is parallel to zi: If the axes zi−1 and zi are parallel, then there are inﬁnitely many common normals between them and condition (DH1) does not specify xi completely. In this case we are free to choose the origin oi anywhere along zi. One often chooses oi to simplify the resulting equations. The axis xi is then chosen either to be directed from oi toward zi−1, along the common normal, or as the opposite of this vector. A common method for choosing oi is to choose the normal that passes through oi−1 as the xi axis; oi is then the point at which this normal intersects zi. In this case, di would be equal to zero. Once xi is ﬁxed, yi is determined, as usual by the right hand rule. Since the axes zi−1 and zi are parallel, αi will be zero in this case. (iii) zi−1 intersects zi: In this case xi is chosen normal to the plane formed by zi and zi−1. The positive direction of xi is arbitrary. The most natural choice for the origin oi in this case is at the point of intersection of zi and zi−1. However, any convenient point along the axis zi suﬃces. Note that in this case the parameter ai equals 0. This constructive procedure works for frames 0, . . . , n−l in an n-link robot. To complete the construction, it is necessary to specify frame n. The ﬁnal coordinate system onxnynzn is commonly referred to as the end-eﬀector or tool frame (see Figure 3.5). The origin Note: currently rendering a 3D gripper... yn ≡ s On O0 z0 y0 x0 xn ≡ n zn ≡ a Figure 3.5: Tool frame assignment. on is most often placed symmetrically between the ﬁngers of the gripper. The unit vectors along the xn, yn, and zn axes are labeled as n, s, and a, respectively. The terminology arises from fact that the direction a is the approach direction, in the sense that the gripper typically approaches an object along the a direction. Similarly the s direction is the sliding direction, the direction along which the ﬁngers of the gripper slide to open and close, and n is the direction normal to the plane formed by a and s. 70CHAPTER 3. FORWARD KINEMATICS: THE DENAVIT-HARTENBERG CONVENTION In contemporary robots the ﬁnal joint motion is a rotation of the end-eﬀector by θn and the ﬁnal two joint axes, zn−1 and zn, coincide. In this case, the transformation between the ﬁnal two coordinate frames is a translation along zn−1 by a distance dn followed (or preceded) by a rotation of θn radians about zn−1. This is an important observation that will simplify the computation of the inverse kinematics in the next chapter. Finally, note the following important fact. In all cases, whether the joint in question is revolute or prismatic, the quantities ai and αi are always constant for all i and are characteristic of the manipulator. If joint i is prismatic, then θi is also a constant, while di is the ith joint variable. Similarly, if joint i is revolute, then di is constant and θi is the ith joint variable. 3.2.3 Summary We may summarize the above procedure based on the D-H convention in the following algorithm for deriving the forward kinematics for any manipulator. Step l: Locate and label the joint axes z0, . . . , zn−1. Step 2: Establish the base frame. Set the origin anywhere on the z0-axis. The x0 and y0 axes are chosen conveniently to form a right-hand frame. For i = 1, . . . , n − 1, perform Steps 3 to 5. Step 3: Locate the origin oi where the common normal to zi and zi−1 intersects zi. If zi intersects zi−1 locate oi at this intersection. If zi and zi−1 are parallel, locate oi in any convenient position along zi. Step 4: Establish xi along the common normal between zi−1 and zi through oi, or in the direction normal to the zi−1 − zi plane if zi−1 and zi intersect. Step 5: Establish yi to complete a right-hand frame. Step 6: Establish the end-eﬀector frame onxnynzn. Assuming the n-th joint is revolute, set zn = a along the direction zn−1. Establish the origin on conveniently along zn, preferably at the center of the gripper or at the tip of any tool that the manipulator may be carrying. Set yn = s in the direction of the gripper closure and set xn = n as s × a. If the tool is not a simple gripper set xn and yn conveniently to form a right-hand frame. Step 7: Create a table of link parameters ai, di, αi, θi. ai = distance along xi from oi to the intersection of the xi and zi−1 axes. di = distance along zi−1 from oi−1 to the intersection of the xi and zi−1 axes. di is variable if joint i is prismatic. αi = the angle between zi−1 and zi measured about xi (see Figure 3.3). 3.3. EXAMPLES 71 θi = the angle between xi−1 and xi measured about zi−1 (see Figure 3.3). θi is variable if joint i is revolute. Step 8: Form the homogeneous transformation matrices Ai by substituting the above pa- rameters into (3.10). Step 9: Form T 0 n = A1 · · · An. This then gives the position and orientation of the tool frame expressed in base coordinates. 3.3 Examples In the D-H convention the only variable angle is θ, so we simplify notation by writing ci for cos θi, etc. We also denote θ1 + θ2 by θ12, and cos(θ1 + θ2) by c12, and so on. In the following examples it is important to remember that the D-H convention, while systematic, still allows considerable freedom in the choice of some of the manipulator parameters. This is particularly true in the case of parallel joint axes or when prismatic joints are involved. Example 3.1 Planar Elbow Manipulator Consider the two-link planar arm of Figure 3.6. The joint axes z0 and z1 are normal to y0 x0 θ1 x1 x2 θ2 y1 y2 a1 a2 Figure 3.6: Two-link planar manipulator. The z-axes all point out of the page, and are not shown in the ﬁgure. the page. We establish the base frame o0x0y0z0 as shown. The origin is chosen at the point of intersection of the z0 axis with the page and the direction of the x0 axis is completely arbitrary. Once the base frame is established, the o1x1y1z1 frame is ﬁxed as shown by the D-H convention, where the origin o1 has been located at the intersection of z1 and the page. The ﬁnal frame o2x2y2z2 is ﬁxed by choosing the origin o2 at the end of link 2 as shown. The link parameters are shown in Table 3.1. The A-matrices are determined from (3.10) as 72CHAPTER 3. FORWARD KINEMATICS: THE DENAVIT-HARTENBERG CONVENTION Table 3.1: Link parameters for 2-link planar manipulator. Link ai αi di θi 1 a1 0 0 θ∗ 1 2 a2 0 0 θ∗ 2 ∗ variable A1 =     c1 −s1 0 a1c1 s1 c1 0 a1s1 0 0 1 0 0 0 0 1     . (3.22) A2 =     c2 −s2 0 a2c2 s2 c2 0 a2s2 0 0 1 0 0 0 0 1     (3.23) The T -matrices are thus given by T 0 1 = A1. (3.24) T 0 2 = A1A2 =     c12 −s12 0 a1c1 + a2c12 s12 c12 0 a1s1 + a2s12 0 0 1 0 0 0 0 1     . (3.25) Notice that the ﬁrst two entries of the last column of T 0 2 are the x and y components of the origin o2 in the base frame; that is, x = a1c1 + a2c12 (3.26) y = a1s1 + a2s12 are the coordinates of the end-eﬀector in the base frame. The rotational part of T 0 2 gives the orientation of the frame o2x2y2z2 relative to the base frame. ⋄ Example 3.2 Three-Link Cylindrical Robot Consider now the three-link cylindrical robot represented symbolically by Figure 3.7. We establish o0 as shown at joint 1. Note that the placement of the origin o0 along z0 as well as the direction of the x0 axis are arbitrary. Our choice of o0 is the most natural, but o0 could just as well be placed at joint 2. The axis x0 is chosen normal to the page. Next, since z0 and z1 coincide, the origin o1 is chosen at joint 1 as shown. The x1 axis is normal to the page when θ1 = 0 but, of course its direction will change since θ1 is variable. Since z2 and z1 intersect, the origin o2 is placed at this intersection. The direction of x2 is chosen 3.3. EXAMPLES 73 d3 d2 y3 x3 z3 O3 y2 y0 y1 O0 O1 O2 z1 z2 x2 x1 x0 z0 θ1 Figure 3.7: Three-link cylindrical manipulator. Table 3.2: Link parameters for 3-link cylindrical manipulator. Link ai αi di θi 1 0 0 d1 θ∗ 1 2 0 −90 d∗ 2 0 3 0 0 d∗ 3 0 ∗ variable parallel to x1 so that θ2 is zero. Finally, the third frame is chosen at the end of link 3 as shown. The link parameters are now shown in Table 3.2. The corresponding A and T matrices 74CHAPTER 3. FORWARD KINEMATICS: THE DENAVIT-HARTENBERG CONVENTION are A1 =     c1 −s1 0 0 s1 c1 0 0 0 0 1 d1 0 0 0 1     (3.27) A2 =     1 0 0 0 0 0 1 0 0 −1 0 d2 0 0 0 1     A3 =     1 0 0 0 0 1 0 0 0 0 1 d3 0 0 0 1     T 0 3 = A1A2A3 =     c1 0 −s1 −s1d3 s1 0 c1 c1d3 0 −1 0 d1 + d2 0 0 0 1     . (3.28) ⋄ Example 3.3 Spherical Wrist θ5 θ4 z5 x4 z4 θ6 To gripper x5 z3, Figure 3.8: The spherical wrist frame assignment. The spherical wrist conﬁguration is shown in Figure 3.8, in which the joint axes z3, z4, z5 intersect at o. The Denavit-Hartenberg parameters are shown in Table 3.3. The Stanford manipulator is an example of a manipulator that possesses a wrist of this type. In fact, the following analysis applies to virtually all spherical wrists. We show now that the ﬁnal three joint variables, θ4, θ5, θ6 are the Euler angles φ, θ, ψ, respectively, with respect to the coordinate frame o3x3y3z3. To see this we need only compute 3.3. EXAMPLES 75 Table 3.3: DH parameters for spherical wrist. Link ai αi di θi 4 0 −90 0 θ∗ 4 5 0 90 0 θ∗ 5 6 0 0 d6 θ∗ 6 ∗ variable the matrices A4, A5, and A6 using Table 3.3 and the expression (3.10). This gives A4 =     c4 0 −s4 0 s4 0 c4 0 0 −1 0 0 0 0 0 1     (3.29) A5 =     c5 0 s5 0 s5 0 −c5 0 0 −1 0 0 0 0 0 1     (3.30) A6 =     c6 −s6 0 0 s6 c6 0 0 0 0 1 d6 0 0 0 1     . (3.31) Multiplying these together yields T 3 6 = A4A5A6 = [ R3 6 o 3 6 0 1 ] (3.32) =     c4c5c6 − s4s6 −c4c5s6 − s4c6 c4s5 c4s5d6 s4c5c6 + c4s6 −s4c5s6 + c4c6 s4s5 s4s5d6 −s5c6 s5s6 c5 c5d6 0 0 0 1     . Comparing the rotational part R3 6 of T 3 6 with the Euler angle transformation (2.51) shows that θ4, θ5, θ6 can indeed be identiﬁed as the Euler angles φ, θ and ψ with respect to the coordinate frame o3x3y3z3. ⋄ Example 3.4 Cylindrical Manipulator with Spherical Wrist Suppose that we now attach a spherical wrist to the cylindrical manipulator of Exam- ple 3.3.2 as shown in Figure 3.9. Note that the axis of rotation of joint 4 is parallel to z2 and thus coincides with the axis z3 of Example 3.3.2. The implication of this is that we can 76CHAPTER 3. FORWARD KINEMATICS: THE DENAVIT-HARTENBERG CONVENTION d3 θ1 d2 θ5 θ4 θ6 n s a Figure 3.9: Cylindrical robot with spherical wrist. immediately combine the two previous expression (3.28) and (3.32) to derive the forward kinematics as T 0 6 = T 0 3 T 3 6 (3.33) with T 0 3 given by (3.28) and T 3 6 given by (3.32). Therefore the forward kinematics of this manipulator is described by T 0 6 =     c1 0 −s1 −s1d1 s1 0 c1 c1d3 0 −1 0 d1 + d2 0 0 0 1         c4c5c6 − s4s6 −c4c5s6 − s4c6 c4s5 c4s5d6 s4c5c6 + c4s6 −s4c5s6 + c4c6 s4s5 s4s5d6 −s5c6 s5c6 c5 c5d6 0 0 0 1    (3.34) =     r11 r12 r13 dx r21 r22 r23 dy r31 r32 r33 dz 0 0 0 1     3.3. EXAMPLES 77 where r11 = c1c4c5c6 − c1s4s6 + s1s5c6 r21 = s1c4c5c6 − s1s4s6 − c1s5c6 r31 = −s4c5c6 − c4s6 r12 = −c1c4c5s6 − c1s4c6 − s1s5c6 r22 = −s1c4c5s6 − s1s4s6 + c1s5c6 r32 = s4c5c6 − c4c6 r13 = c1c4s5 − s1c5 r23 = s1c4s5 + c1c5 r33 = −s4s5 dx = c1c4s5d6 − s1c5d6 − s1d3 dy = s1c4s5d6 + c1c5d6 + c1d3 dz = −s4s5d6 + d1 + d2. Notice how most of the complexity of the forward kinematics for this manipulator results from the orientation of the end-eﬀector while the expression for the arm position from (3.28) is fairly simple. The spherical wrist assumption not only simpliﬁes the derivation of the forward kinematics here, but will also greatly simplify the inverse kinematics problem in the next chapter. ⋄ Example 3.5 Stanford Manipulator Consider now the Stanford Manipulator shown in Figure 3.10. This manipulator is an z1 θ2 θ1 z0 a θ4 d3 z2 θ5 θ6 n s x0, x1 Note: the shoulder (prismatic joint) is mounted wrong. Figure 3.10: DH coordinate frame assignment for the Stanford manipulator. example of a spherical (RRP) manipulator with a spherical wrist. This manipulator has an oﬀset in the shoulder joint that slightly complicates both the forward and inverse kinematics problems. 78CHAPTER 3. FORWARD KINEMATICS: THE DENAVIT-HARTENBERG CONVENTION Table 3.4: DH parameters for Stanford Manipulator. Link di ai αi θi 1 0 0 −90 ⋆ 2 d2 0 +90 ⋆ 3 ⋆ 0 0 0 4 0 0 −90 ⋆ 5 0 0 +90 ⋆ 6 d6 0 0 ⋆ ∗ joint variable We ﬁrst establish the joint coordinate frames using the D-H convention as shown. The link parameters are shown in the Table 3.4. It is straightforward to compute the matrices Ai as A1 =     c1 0 −s1 0 s1 0 c1 0 0 −1 0 0 0 0 0 1     (3.35) A2 =     c2 0 s2 0 s2 0 −c2 0 0 1 0 d2 0 0 0 1     (3.36) A3 =     1 0 0 0 0 1 0 0 0 0 1 d3 0 0 0 1     (3.37) A4 =     c4 0 −s4 0 s4 0 c4 0 0 −1 0 0 0 0 0 1     (3.38) A5 =     c5 0 s5 0 s5 0 −c5 0 0 −1 0 0 0 0 0 1     (3.39) A6 =     c6 −s6 0 0 s6 c6 0 0 0 0 1 d6 0 0 0 1     (3.40) 3.3. EXAMPLES 79 T 0 6 is then given as T 0 6 = A1 · · · A6 (3.41) =     r11 r12 r13 dx r21 r22 r23 dy r31 r32 r33 dz 0 0 0 1     (3.42) where r11 = c1[c2(c4c5c6 − s4s6) − s2s5c6] − d2(s4c5c6 + c4s6) r21 = s1[c2(c4c5c6 − s4s6) − s2s5c6] + c1(s4c5c6 + c4s6) r31 = −s2(c4c5c6 − s4s6) − c2s5c6 r12 = c1[−c2(c4c5s6 + s4c6) + s2s5s6] − s1(−s4c5s6 + c4c6) r22 = −s1[−c2(c4c5s6 + s4c6) + s2s5s6] + c1(−s4c5s6 + c4c6) r32 = s2(c4c5s6 + s4c6) + c2s5s6 (3.43) r13 = c1(c2c4s5 + s2c5) − s1s4s5 r23 = s1(c2c4s5 + s2c5) + c1s4s5 r33 = −s2c4s5 + c2c5 dx = c1s2d3 − s1d2 + +d6(c1c2c4s5 + c1c5s2 − s1s4s5) dy = s1s2d3 + c1d2 + d6(c1s4s5 + c2c4s1s5 + c5s1s2) dz = c2d3 + d6(c2c5 − c4s2s5). (3.44) ⋄ Example 3.6 SCARA Manipulator As another example of the general procedure, consider the SCARA manipulator of Fig- ure 3.11. This manipulator, which is an abstraction of the AdeptOne robot of Figure 1.11, consists of an RRP arm and a one degree-of-freedom wrist, whose motion is a roll about the vertical axis. The ﬁrst step is to locate and label the joint axes as shown. Since all joint axes are parallel we have some freedom in the placement of the origins. The origins are placed as shown for convenience. We establish the x0 axis in the plane of the page as shown. This is completely arbitrary and only aﬀects the zero conﬁguration of the manipulator, that is, the position of the manipulator when θ1 = 0. The joint parameters are given in Table 3.5, and the A-matrices are as follows. 80CHAPTER 3. FORWARD KINEMATICS: THE DENAVIT-HARTENBERG CONVENTION z0 z1 d3 θ4 x2 y2 x0 y0 θ1 θ2 x1 y1 y3 y4 x3 x4 z2 z3, z4 Figure 3.11: DH coordinate frame assignment for the SCARA manipulator. Table 3.5: Joint parameters for SCARA. Link ai αi di θi 1 a1 0 0 ⋆ 2 a2 180 0 ⋆ 3 0 0 ⋆ 0 4 0 0 d4 ⋆ ∗ joint variable A1 =     c1 −s1 0 a1c1 s1 c1 0 a1s1 0 0 1 0 0 0 0 1     (3.45) A2 =     c2 s2 0 a2c2 s2 −c2 0 a2s2 0 0 −1 0 0 0 0 1     (3.46) A3 =     1 0 0 0 0 1 0 0 0 0 1 d3 0 0 0 1     (3.47) A4 =     c4 −s4 0 0 s4 c4 0 0 0 0 1 d4 0 0 0 1     . (3.48) 3.3. EXAMPLES 81 The forward kinematic equations are therefore given by T 0 4 = A1 · · · A4 =     c12c4 + s12s4 −c12s4 + s12c4 0 a1c1 + a2c12 s12c4 − c12s4 −s12s4 − c12c4 0 a1s1 + a2s12 0 0 −1 −d3 − d4 0 0 0 1     . (3.49) ⋄ 82CHAPTER 3. FORWARD KINEMATICS: THE DENAVIT-HARTENBERG CONVENTION Chapter 4 INVERSE KINEMATICS In the previous chapter we showed how to determine the end-eﬀector position and orien- tation in terms of the joint variables. This chapter is concerned with the inverse problem of ﬁnding the joint variables in terms of the end-eﬀector position and orientation. This is the problem of inverse kinematics, and it is, in general, more diﬃcult than the forward kinematics problem. In this chapter, we begin by formulating the general inverse kinematics problem. Fol- lowing this, we describe the principle of kinematic decoupling and how it can be used to simplify the inverse kinematics of most modern manipulators. Using kinematic decoupling, we can consider the position and orientation problems independently. We describe a ge- ometric approach for solving the positioning problem, while we exploit the Euler angle parameterization to solve the orientation problem. 4.1 The General Inverse Kinematics Problem The general problem of inverse kinematics can be stated as follows. Given a 4 × 4 homoge- neous transformation H = [ R o 0 1 ] ∈ SE(3) (4.1) with R ∈ SO(3), ﬁnd (one or all) solutions of the equation T 0 n(q1, . . . , qn) = H (4.2) where T 0 n(q1, . . . , qn) = A1(q1) · · · An(qn). (4.3) Here, H represents the desired position and orientation of the end-eﬀector, and our task is to ﬁnd the values for the joint variables q1, . . . , qn so that T 0 n(q1, . . . , qn) = H. 83 84 CHAPTER 4. INVERSE KINEMATICS Equation (4.2) results in twelve nonlinear equations in n unknown variables, which can be written as Tij(q1, . . . , qn) = hij, i = 1, 2, 3, j = 1, . . . , 4 (4.4) where Tij, hij refer to the twelve nontrivial entries of T 0 n and H, respectively. (Since the bottom row of both T 0 n and H are (0,0,0,1), four of the sixteen equations represented by (4.2) are trivial.) Example 4.1 Recall the Stanford manipulator of Example 3.3.5. Suppose that the desired position and orientation of the ﬁnal frame are given by H =     r11 r12 r13 ox r21 r22 r23 oy r31 r32 r33 oz 0 0 0 1     . (4.5) To ﬁnd the corresponding joint variables θ1, θ2, d3, θ4, θ5, and θ6 we must solve the following simultaneous set of nonlinear trigonometric equations (cf. (3.43) and (3.44)): c1[c2(c4c5c6 − s4s6) − s2s5c6] − s1(s4c5c6 + c4s6) = r11 s1[c2(c4c5c6 − s4s6) − s2s5c6] + c1(s4c5c6 + c4s6) = r21 −s2(c4c5c6 − s4s6) − c2s5s6 = r31 c1[−c2(c4c5s6 + s4c6) + s2s5s6] − s1(−s4c5s6 + c4c6) = r12 s1[−c2(c4c5s6 + s4c6) + s2s5s6] + c1(−s4c5s6 + c4c6) = r22 s2(c4c5s6 + s4c6) + c2s5s6 = r32 c1(c2c4s5 + s2c5) − s1s4s5 = r13 s1(c2c4s5 + s2c5) + c1s4s5 = r23 −s2c4s5 + c2c5 = r33 c1s2d3 − s1d2 + d6(c1c2c4s5 + c1c5s2 − s1s4s5) = ox s1s2d3 + c1d2 + d6(c1s4s5 + c2c4s1s5 + c5s1s2) = oy c2d3 + d6(c2c5 − c4s2s5) = oz. ⋄ The equations in the preceding example are, of course, much too diﬃcult to solve di- rectly in closed form. This is the case for most robot arms. Therefore, we need to develop eﬃcient and systematic techniques that exploit the particular kinematic structure of the manipulator. Whereas the forward kinematics problem always has a unique solution that can be obtained simply by evaluating the forward equations, the inverse kinematics problem may or may not have a solution. Even if a solution exists, it may or may not be unique. 4.2. KINEMATIC DECOUPLING 85 Furthermore, because these forward kinematic equations are in general complicated nonlin- ear functions of the joint variables, the solutions may be diﬃcult to obtain even when they exist. In solving the inverse kinematics problem we are most interested in ﬁnding a closed form solution of the equations rather than a numerical solution. Finding a closed form solution means ﬁnding an explicit relationship: qk = fk(h11, . . . , h34), k = 1, . . . , n. (4.6) Closed form solutions are preferable for two reasons. First, in certain applications, such as tracking a welding seam whose location is provided by a vision system, the inverse kinematic equations must be solved at a rapid rate, say every 20 milliseconds, and having closed form expressions rather than an iterative search is a practical necessity. Second, the kinematic equations in general have multiple solutions. Having closed form solutions allows one to develop rules for choosing a particular solution among several. The practical question of the existence of solutions to the inverse kinematics problem depends on engineering as well as mathematical considerations. For example, the motion of the revolute joints may be restricted to less than a full 360 degrees of rotation so that not all mathematical solutions of the kinematic equations will correspond to physically realizable conﬁgurations of the manipulator. We will assume that the given position and orientation is such that at least one solution of (4.2) exists. Once a solution to the mathematical equations is identiﬁed, it must be further checked to see whether or not it satisﬁes all constraints on the ranges of possible joint motions. For our purposes here we henceforth assume that the given homogeneous matrix H in (4.2) corresponds to a conﬁguration within the manipulator’s workspace with an attainable orientation. This then guarantees that the mathematical solutions obtained correspond to achievable conﬁgurations. 4.2 Kinematic Decoupling Although the general problem of inverse kinematics is quite diﬃcult, it turns out that for manipulators having six joints, with the last three joints intersecting at a point (such as the Stanford Manipulator above), it is possible to decouple the inverse kinematics problem into two simpler problems, known respectively, as inverse position kinematics, and inverse orientation kinematics. To put it another way, for a six-DOF manipulator with a spherical wrist, the inverse kinematics problem may be separated into two simpler problems, namely ﬁrst ﬁnding the position of the intersection of the wrist axes, hereafter called the wrist center, and then ﬁnding the orientation of the wrist. For concreteness let us suppose that there are exactly six degrees-of-freedom and that the last three joint axes intersect at a point oc. We express (4.2) as two sets of equations representing the rotational and positional equations R0 6(q1, . . . , q6) = R (4.7) o 0 6(q1, . . . , q6) = o (4.8) 86 CHAPTER 4. INVERSE KINEMATICS where o and R are the desired position and orientation of the tool frame, expressed with respect to the world coordinate system. Thus, we are given o and R, and the inverse kinematics problem is to solve for q1, . . . , q6. The assumption of a spherical wrist means that the axes z3, z4, and z5 intersect at oc and hence the origins o4 and o5 assigned by the DH-convention will always be at the wrist center oc. Often o3 will also be at oc, but this is not necessary for our subsequent development. The important point of this assumption for the inverse kinematics is that motion of the ﬁnal three links about these axes will not change the position of oc, and thus, the position of the wrist center is thus a function of only the ﬁrst three joint variables. The origin of the tool frame (whose desired coordinates are given by o) is simply obtained by a translation of distance d6 along z5 from oc (see Table 3.3). In our case, z5 and z6 are the same axis, and the third column of R expresses the direction of z6 with respect to the base frame. Therefore, we have o = o 0 c + d6R   0 0 1   . (4.9) Thus in order to have the end-eﬀector of the robot at the point with coordinates given by o and with the orientation of the end-eﬀector given by R = (rij), it is necessary and suﬃcient that the wrist center oc have coordinates given by o 0 c = o − d6R   0 0 1   . (4.10) and that the orientation of the frame o6x6y6z6 with respect to the base be given by R. If the components of the end-eﬀector position o are denoted ox, oy, oz and the components of the wrist center o 0 c are denoted xc, yc, zc then (4.10) gives the relationship   xc yc zc   =   ox − d6r13 oy − d6r23 oz − d6r33   . (4.11) Using Equation (4.11) we may ﬁnd the values of the ﬁrst three joint variables. This determines the orientation transformation R0 3 which depends only on these ﬁrst three joint variables. We can now determine the orientation of the end-eﬀector relative to the frame o3x3y3z3 from the expression R = R0 3R3 6 (4.12) as R3 6 = (R0 3) −1R = (R0 3) T R. (4.13) As we shall see in Section 4.4, the ﬁnal three joint angles can then be found as a set of Euler angles corresponding to R3 6. Note that the right hand side of (4.13) is completely known since R is given and R0 3 can be calculated once the ﬁrst three joint variables are known. The idea of kinematic decoupling is illustrated in Figure 4.1. 4.3. INVERSE POSITION: A GEOMETRIC APPROACH 87 d6Rk dc d6 Figure 4.1: Kinematic decoupling. Summary For this class of manipulators the determination of the inverse kinematics can be summarized by the following algorithm. Step 1: Find q1, q2, q3 such that the wrist center oc has coordinates given by o 0 c = o − d6R   0 0 1   . (4.14) Step 2: Using the joint variables determined in Step 1, evaluate R0 3. Step 3: Find a set of Euler angles corresponding to the rotation matrix R3 6 = (R0 3) −1R = (R0 3) T R. (4.15) 4.3 Inverse Position: A Geometric Approach For the common kinematic arrangements that we consider, we can use a geometric approach to ﬁnd the variables, q1, q2, q3 corresponding to o 0 c given by (4.10). We restrict our treatment to the geometric approach for two reasons. First, as we have said, most present manipulator designs are kinematically simple, usually consisting of one of the ﬁve basic conﬁgurations of Chapter 1 with a spherical wrist. Indeed, it is partly due to the diﬃculty of the general inverse kinematics problem that manipulator designs have evolved to their present state. Second, there are few techniques that can handle the general inverse kinematics problem for arbitrary conﬁgurations. Since the reader is most likely to encounter robot conﬁgurations 88 CHAPTER 4. INVERSE KINEMATICS of the type considered here, the added diﬃculty involved in treating the general case seems unjustiﬁed. The reader is directed to the references at the end of the chapter for treatment of the general case. In general the complexity of the inverse kinematics problem increases with the number of nonzero link parameters. For most manipulators, many of the ai, di are zero, the αi are 0 or ±π/2, etc. In these cases especially, a geometric approach is the simplest and most natural. We will illustrate this with several important examples. Articulated Conﬁguration Consider the elbow manipulator shown in Figure 4.2, with the components of o 0 c denoted by xc, yc, zc. We project oc onto the x0 − y0 plane as shown in Figure 4.3. θ1 θ2 z0 y0 x0 r d1 yc xc zc s θ3 Figure 4.2: Elbow manipulator. We see from this projection that θ1 = A tan(xc, yc), (4.16) in which A tan(x, y) denotes the two argument arctangent function. A tan(x, y) is deﬁned for all (x, y) ̸= (0, 0) and equals the unique angle θ such that cos θ = x (x2 + y2) 1 2 , sin θ = y (x2 + y2) 1 2 . (4.17) For example, A tan(1, −1) = − π 4 , while A tan(−1, 1) = + 3π 4 . Note that a second valid solution for θ1 is θ1 = π + A tan(xc, yc). (4.18) 4.3. INVERSE POSITION: A GEOMETRIC APPROACH 89 θ1 x0xc yc y0 r Figure 4.3: Projection of the wrist center onto x0 − y0 plane. Of course this will, in turn, lead to diﬀerent solutions for θ2 and θ3, as we will see below. These solutions for θ1, are valid unless xc = yc = 0. In this case (4.16) is undeﬁned and the manipulator is in a singular conﬁguration, shown in Figure 4.4. In this position the z0 Figure 4.4: Singular conﬁguration. wrist center oc intersects z0; hence any value of θ1 leaves oc ﬁxed. There are thus inﬁnitely many solutions for θ1 when oc intersects z0. If there is an oﬀset d ̸= 0 as shown in Figure 4.5 then the wrist center cannot intersect z0. In this case, depending on how the DH parameters have been assigned, we will have d2 = d or d3 = d. In this case, there will, in general, be only two solutions for θ1. These correspond to the so-called left arm and right arm conﬁgurations as shown in Figures 4.6 and 4.7. Figure 4.6 shows the left arm conﬁguration. From this ﬁgure, we see geometrically that θ1 = φ − α (4.19) 90 CHAPTER 4. INVERSE KINEMATICS d Figure 4.5: Elbow manipulator with shoulder oﬀset. where φ = A tan(xc, yc) (4.20) α = A tan (√r2 − d2, d) (4.21) = A tan (√x2 c + y2 c − d2, d) . The second solution, given by the right arm conﬁguration shown in Figure 4.7 is given by θ1 = A tan(xc, yc) + A tan (− √ r2 − d2, −d) . (4.22) To see this, note that θ1 = α + β (4.23) α = A tan(xc, yc) (4.24) β = γ + π (4.25) γ = A tan(√r2 − d2, d) (4.26) (4.27) which together imply that β = A tan (− √ r2 − d2, −d) (4.28) since cos(θ + π) = − cos(θ) and sin(θ + π) = − sin(θ). To ﬁnd the angles θ2, θ3 for the elbow manipulator, given θ1, we consider the plane formed by the second and third links as shown in Figure 4.8. Since the motion of links 4.3. INVERSE POSITION: A GEOMETRIC APPROACH 91 θ1 α yc y0 xc x0 r φd Figure 4.6: Left arm conﬁguration. two and three is planar, the solution is analogous to that of the two-link manipulator of Chapter 1. As in our previous derivation (cf. (1.8) and (1.9)) we can apply the law of cosines to obtain cos θ3 = r2 + s2 − a2 2 − a2 3 2a2a3 (4.29) = x2 c + y2 c − d2 + z2 c − a2 2 − a2 3 2a2a3 := D, since r2 = x2 c + y2 c − d2 and s = zc. Hence, θ3 is given by θ3 = A tan (D, ± √ 1 − D2) . (4.30) Similarly θ2 is given as θ2 = A tan(r, s) − A tan(a2 + a3c3, a3s3) (4.31) = A tan (√x2 c + y2 c − d2, zc) − A tan(a2 + a3c3, a3s3). The two solutions for θ3 correspond to the elbow-up position and elbow-down position, respectively. An example of an elbow manipulator with oﬀsets is the PUMA shown in Figure 4.9. There are four solutions to the inverse position kinematics as shown. These correspond to the situations left arm-elbow up, left arm–elbow down, right arm–elbow up and right arm–elbow down. We will see that there are two solutions for the wrist orientation thus giving a total of eight solutions of the inverse kinematics for the PUMA manipulator. 92 CHAPTER 4. INVERSE KINEMATICS d xc α θ1 β rγ yc x0 y0 Figure 4.7: Right arm conﬁguration. Spherical Conﬁguration We next solve the inverse position kinematics for a three degree of freedom spherical manip- ulator shown in Figure 4.10. As in the case of the elbow manipulator the ﬁrst joint variable is the base rotation and a solution is given as θ1 = A tan(xc, yc) (4.32) provided xc and yc are not both zero. If both xc and yc are zero, the conﬁguration is singular as before and θ1 may take on any value. The angle θ2 is given from Figure 4.10 as θ2 = A tan(r, s) + π 2 (4.33) where r2 = x2 c + y2 c , s = zc − d1. As in the case of the elbow manipulator a second solution for θ1 is given by θ1 = π + A tan(xc, yc); (4.34) The linear distance d3 is found as d3 = √ r2 + s2 = √x2 c + y2 c + (zc − d1)2. (4.35) The negative square root solution for d3 is disregarded and thus in this case we obtain two solutions to the inverse position kinematics as long as the wrist center does not intersect z0. If there is an oﬀset then there will be left and right arm conﬁgurations as in the case of the elbow manipulator (Problem 4-12). 4.4. INVERSE ORIENTATION 93 r θ2 θ3 s z0 a2 a3 Figure 4.8: Projecting onto the plane formed by links 2 and 3. 4.4 Inverse Orientation In the previous section we used a geometric approach to solve the inverse position problem. This gives the values of the ﬁrst three joint variables corresponding to a given position of the wrist origin. The inverse orientation problem is now one of ﬁnding the values of the ﬁnal three joint variables corresponding to a given orientation with respect to the frame o3x3y3z3. For a spherical wrist, this can be interpreted as the problem of ﬁnding a set of Euler angles corresponding to a given rotation matrix R. Recall that equation (3.32) shows that the rotation matrix obtained for the spherical wrist has the same form as the rotation matrix for the Euler transformation, given in (2.52). Therefore, we can use the method developed in Section 2.5.1 to solve for the three joint angles of the spherical wrist. In particular, we solve for the three Euler angles, φ, θ, ψ, using Equations (2.54) – (2.59), and then use the mapping θ4 = φ, θ5 = θ, θ6 = ψ. Example 4.2 Articulated Manipulator with Spherical Wrist The DH parameters for the frame assignment shown in Figure 4.2 are summarized in Table 4.1. Multiplying the corresponding Ai matrices gives the matrix R0 3 for the articulated or elbow manipulator as R0 3 =   c1c23 −c1s23 s1 s1c23 −s1s23 −c1 s23 c23 0   . (4.36) 94 CHAPTER 4. INVERSE KINEMATICS Figure 4.9: Four solutions of the inverse position kinematics for the PUMA manipulator. Table 4.1: Link parameters for the articulated manipulator of Figure 4.2. Link ai αi di θi 1 0 90 d1 θ∗ 1 2 a2 0 0 θ∗ 2 3 a3 0 0 θ∗ 3 ∗ variable 4.4. INVERSE ORIENTATION 95 θ1 θ2 z0 y0 x0 d3 r s1 yc xc zc Figure 4.10: Spherical manipulator. The matrix R3 6 = A4A5A6 is given as R3 6 =   c4c5c6 − s4s6 −c4c5s6 − s4c6 c4s5 s4c5c6 + c4s6 −s4c5s6 + c4c6 s4s5 −s5c6 s5s6 c5   . (4.37) The equation to be solved now for the ﬁnal three variables is therefore R3 6 = (R0 3) T R (4.38) and the Euler angle solution can be applied to this equation. For example, the three equations given by the third column in the above matrix equation are given by c4s5 = c1c23r13 + s1c23r23 + s23r33 (4.39) s4s5 = −c1s23r13 − s1s23r23 + c23r33 (4.40) c5 = s1r13 − c1r23. (4.41) Hence, if not both of the expressions (4.39), (4.40) are zero, then we obtain θ5 from (2.54) and (2.55) as θ5 = A tan (s1r13 − c1r23, ± √1 − (s1r13 − c1r23)2) . (4.42) If the positive square root is chosen in (4.42), then θ4 and θ6 are given by (2.56) and (2.57), respectively, as θ4 = A tan(c1c23r13 + s1c23r23 + s23r33, −c1s23r13 − s1s23r23 + c23r33) (4.43) θ6 = A tan(−s1r11 + c1r21, s1r12 − c1r22). (4.44) 96 CHAPTER 4. INVERSE KINEMATICS The other solutions are obtained analogously. If s5 = 0, then joint axes z3 and z5 are collinear. This is a singular conﬁguration and only the sum θ4 + θ6 can be determined. One solution is to choose θ4 arbitrarily and then determine θ6 using (2.62) or (2.64). ⋄ Example 4.3 Summary of Elbow Manipulator Solution To summarize the preceding development we write down one solution to the inverse kinematics of the six degree-of-freedom elbow manipulator shown in Figure 4.2 which has no joint oﬀsets and a spherical wrist. Given o =   ox oy oz   ; R =   r11 r12 r13 r21 r22 r23 r31 r32 r33   (4.45) then with xc = ox − d6r13 (4.46) yc = oy − d6r23 (4.47) zc = oz − d6r33 (4.48) a set of D-H joint variables is given by θ1 = A tan(xc, yc) (4.49) θ2 = A tan (√ x2 c + y2 c − d2, zc) − A tan(a2 + a3c3, a3s3) (4.50) θ3 = A tan (D, ± √ 1 − D2) , where D = x2 c + y2 c − d2 + z2 c − a2 2 − a2 3 2a2a3 (4.51) θ4 = A tan(c1c23r13 + s1c23r23 + s23r33, −c1s23r13 − s1s23r23 + c23r33) (4.52) θ5 = A tan (s1r13 − c1r23, ± √ 1 − (s1r13 − c1r23)2) . (4.53) θ6 = A tan(−s1r11 + c1r21, s1r12 − c1r22). (4.54) The other possible solutions are left as an exercise (Problem 4-11). ⋄ Example 4.4 SCARA Manipulator As another example, we consider the SCARA manipulator whose forward kinematics is deﬁned by T 0 4 from (3.49). The inverse kinematics is then given as the set of solutions of the equation     c12c4 + s12s4 s12c4 − c12s4 0 a1c1 + a2c12 s12c4 − c12s4 −c12c4 − s12s4 0 a1s1 + a2s12 0 0 −1 −d3 − d4 0 0 0 1     = [ R o 0 1 ] . (4.55) 4.4. INVERSE ORIENTATION 97 We ﬁrst note that, since the SCARA has only four degrees-of-freedom, not every possible H from SE(3) allows a solution of (4.55). In fact we can easily see that there is no solution of (4.55) unless R is of the form R =   cα sα 0 sα −cα 0 0 0 −1   (4.56) and if this is the case, the sum θ1 + θ2 − θ4 is determined by θ1 + θ2 − θ4 = α = A tan(r11, r12). (4.57) Projecting the manipulator conﬁguration onto the x0 − y0 plane immediately yields the situation of Figure 4.11. z0 y0 x0 yc xc d1 r zc θ1 Figure 4.11: SCARA manipulator. We see from this that θ2 = A tan (c2, ± √1 − c2) (4.58) where c2 = o2 x + o2 y − a2 1 − a2 2 2a1a2 (4.59) θ1 = A tan(ox, oy) − A tan(a1 + a2c2, a2s2). (4.60) We may then determine θ4 from (4.57) as θ4 = θ1 + θ2 − α (4.61) = θ1 + θ2 − A tan(r11, r12). Finally d3 is given as d3 = oz + d4. (4.62) ⋄ 98 CHAPTER 4. INVERSE KINEMATICS Chapter 5 VELOCITY KINEMATICS – THE MANIPULATOR JACOBIAN In the previous chapters we derived the forward and inverse position equations relating joint positions and end-eﬀector positions and orientations. In this chapter we derive the velocity relationships, relating the linear and angular velocities of the end-eﬀector (or any other point on the manipulator) to the joint velocities. In particular, we will derive the angular velocity of the end-eﬀector frame (which gives the rate of rotation of the frame) and the linear velocity of the origin. We will then relate these velocities to the joint velocities, ˙qi. Mathematically, the forward kinematic equations deﬁne a function between the space of cartesian positions and orientations and the space of joint positions. The velocity rela- tionships are then determined by the Jacobian of this function. The Jacobian is a matrix- valued function and can be thought of as the vector version of the ordinary derivative of a scalar function. This Jacobian or Jacobian matrix is one of the most important quantities in the analysis and control of robot motion. It arises in virtually every aspect of robotic manipulation: in the planning and execution of smooth trajectories, in the determination of singular conﬁgurations, in the execution of coordinated anthropomorphic motion, in the derivation of the dynamic equations of motion, and in the transformation of forces and torques from the end-eﬀector to the manipulator joints. Since the Jacobian matrix encodes relationships between velocities, we begin this chap- ter with an investigation of velocities, and how to represent them. We ﬁrst consider angular velocity about a ﬁxed axis, and then generalize this with the aid of skew symmetric matri- ces. Equipped with this general representation of angular velocities, we are able to derive equations for both the angular velocity, and the linear velocity for the origin, of a moving frame. We then proceed to the derivation of the manipulator Jacobian. For an n-link manip- ulator we ﬁrst derive the Jacobian representing the instantaneous transformation between the n-vector of joint velocities and the 6-vector consisting of the linear and angular ve- locities of the end-eﬀector. This Jacobian is then a 6 × n matrix. The same approach is used to determine the transformation between the joint velocities and the linear and 99 100 CHAPTER 5. VELOCITY KINEMATICS – THE MANIPULATOR JACOBIAN angular velocity of any point on the manipulator. This will be important when we dis- cuss the derivation of the dynamic equations of motion in Chapter 9. We then discuss the notion of singular conﬁgurations. These are conﬁgurations in which the manipu- lator loses one or more degrees-of-freedom. We show how the singular conﬁgurations are determined geometrically and give several examples. Following this, we brieﬂy discuss the inverse problems of determining joint velocities and accelerations for speciﬁed end-eﬀector velocities and accelerations. We end the chapter by considering redundant manipulators. This includes discussions of the inverse velocity problem, singular value decomposition and manipulability. 5.1 Angular Velocity: The Fixed Axis Case When a rigid body moves in a pure rotation about a ﬁxed axis, every point of the body moves in a circle. The centers of these circles lie on the axis of rotation. As the body rotates, a perpendicular from any point of the body to the axis sweeps out an angle θ, and this angle is the same for every point of the body. If k is a unit vector in the direction of the axis of rotation, then the angular velocity is given by ω = ˙θk (5.1) in which ˙θ is the time derivative of θ. Given the angular velocity of the body, one learns in introductory dynamics courses that the linear velocity of any point on the body is given by the equation v = ω × r (5.2) in which r is a vector from the origin (which in this case is assumed to lie on the axis of rotation) to the point. In fact, the computation of this velocity v is normally the goal in introductory dynamics courses, and therefore, the main role of an angular velocity is to induce linear velocities of points in a rigid body. In our applications, we are interested in describing the motion of a moving frame, including the motion of the origin of the frame through space and also the rotational motion of the frame’s axes. Therefore, for our purposes, the angular velocity will hold equal status with linear velocity. As in previous chapters, in order to specify the orientation of a rigid object, we rigidly attach a coordinate frame to the object, and then specify the orientation of the coordinate frame. Since every point on the object experiences the same angular velocity (each point sweeps out the same angle θ in a given time interval), and since each point of the body is in a ﬁxed geometric relationship to the body-attached frame, we see that the angular velocity is a property of the attached coordinate frame itself. Angular velocity is not a property of individual points. Individual points may experience a linear velocity that is induced by an angular velocity, but it makes no sense to speak of a point itself rotating. Thus, in equation (5.2) v corresponds to the linear velocity of a point, while ω corresponds to the angular velocity associated with a rotating coordinate frame. 5.2. SKEW SYMMETRIC MATRICES 101 In this ﬁxed axis case, the problem of specifying angular displacements is really a planar problem, since each point traces out a circle, and since every circle lies in a plane. Therefore, it is tempting to use ˙θ to represent the angular velocity. However, as we have already seen in Chapter 2, this choice does not generalize to the three-dimensional case, either when the axis of rotation is not ﬁxed, or when the angular velocity is the result of multiple rotations about distinct axes. For this reason, we will develop a more general representation for angular velocities. This is analogous to our development of rotation matrices in Chapter 2 to represent orientation in three dimensions. The key tool that we will need to develop this representation is the skew symmetric matrix, which is the topic of the next section. 5.2 Skew Symmetric Matrices In the Section 5.3 we will derive properties of rotation matrices that can be used to com- puting relative velocity transformations between coordinate frames. Such transformations involve derivatives of rotation matrices. By introducing the notion of a skew symmetric matrix it is possible to simplify many of the computations involved. Deﬁnition 5.1 A matrix S is said to be skew symmetric if and only if ST + S = 0. (5.3) We denote the set of all 3 × 3 skew symmetric matrices by SS(3) 1. If S ∈ SS(3) has components sij, i, j = 1, 2, 3 then (5.3) is equivalent to the nine equations sij + sji = 0 i, j = 1, 2, 3. (5.4) From (5.4) we see that sii = 0; that is, the diagonal terms of S are zero and the oﬀ diagonal terms sij, i ̸= j satisfy sij = −sji. Thus S contains only three independent entries and every 3 × 3 skew symmetric matrix has the form S =   0 −s3 s2 s3 0 −s1 −s2 s1 0   . (5.5) If a = (ax, ay, az)T is a 3-vector, we deﬁne the skew symmetric matrix S(a) as S(a) =   0 −az ay az 0 −ax −ay ax 0   . (5.6) Example 5.1 We denote by i, j and k the three unit basis coordinate vectors, i = (1, 0, 0) T j = (0, 1, 0) T k = (0, 0, 1) T . 1In the mathematical literature this set is typically denoted as so(3). 102 CHAPTER 5. VELOCITY KINEMATICS – THE MANIPULATOR JACOBIAN The skew symmetric matrices S(i), S(j), and S(k) are given by S(i) =   0 0 0 0 0 −1 0 1 0   ; S(j) =   0 0 1 0 0 0 −1 0 0   ; S(k) =   0 −1 0 1 0 0 0 0 0   . (5.7) ⋄ Properties of Skew Symmetric Matrices Skew symmetric matrices possess several properties that will prove useful for subsequent derivations 2 Among these properties are 1. Linearity: S(αa + βb) = αS(a) + βS(b). (5.8) for any vectors a and b belonging to IR3 and scalars α and β. 2. S(a)p = a × p (5.9) for any vectors a and p, where a × p denotes the vector cross product. Equation (5.9) can be veriﬁed by direct calculation. 3. If R ∈ SO(3) and a, b are vectors in IR3 it can also be shown by direct calculation that R(a × b) = Ra × Rb. (5.10) Equation (5.10) is not true in general unless R is orthogonal. Equation (5.10) says that if we ﬁrst rotate the vectors a and b using the rotation transformation R and then form the cross product of the rotated vectors Ra and Rb, the result is the same as that obtained by ﬁrst forming the cross product a × b and then rotating to obtain R(a × b). 4. RS(a)RT = S(Ra) (5.11) for R ∈ SO(3) and a ∈ IR3. This property follows easily from (5.9) and (5.10) as follows. Let b ∈ IR3 be an arbitrary vector. Then RS(a)RT b = R(a × RT b) = (Ra) × (RRT b) = (Ra) × b = S(Ra)b. and the result follows. 2These properties are consequences of the fact that SS(3) is a Lie Algebra, a vector space with a suitably deﬁned product operation. 5.2. SKEW SYMMETRIC MATRICES 103 As we will see, (5.11) is one of the most useful expressions that we will derive. The left hand side of Equation (5.11) represents a similarity transformation of the matrix S(a). The equation says therefore that the matrix representation of S(a) in a coordinate frame rotated by R is the same as the skew symmetric matrix S(Ra) corresponding to the vector a rotated by R. Suppose now that a rotation matrix R is a function of the single variable θ. Hence R = R(θ) ∈ SO(3) for every θ. Since R is orthogonal for all θ it follows that R(θ)R(θ) T = I. (5.12) Diﬀerentiating both sides of (5.12) with respect to θ using the product rule gives dR dθ R(θ) T + R(θ) dRT dθ = 0. (5.13) Let us deﬁne the matrix S := dR dθ R(θ) T . (5.14) Then the transpose of S is ST = ( dR dθ R(θ) T )T = R(θ) dRT dθ . (5.15) Equation (5.13) says therefore that S + ST = 0. (5.16) In other words, the matrix S deﬁned by (5.14) is skew symmetric. Multiplying both sides of (5.14) on the right by R and using the fact that RT R = I yields dR dθ = SR(θ). (5.17) Equation (5.17) is very important. It says that computing the derivative of the rotation matrix R is equivalent to a matrix multiplication by a skew symmetric matrix S. The most commonly encountered situation is the case where R is a basic rotation matrix or a product of basic rotation matrices. Example 5.2 If R = Rx,θ, the basic rotation matrix given by (2.19), then direct computa- tion shows that S = dR dθ RT =   0 0 0 0 − sin θ − cos θ 0 cos θ − sin θ     1 0 0 0 cos θ sin θ 0 − sin θ cos θ   (5.18) =   0 0 0 0 0 −1 0 1 0   = S(i). (5.19) 104 CHAPTER 5. VELOCITY KINEMATICS – THE MANIPULATOR JACOBIAN Thus we have shown that dRx,θ dθ = S(i)Rx,θ. (5.20) Similar computations show that dRy,θ dθ = S(j)Ry,θ; dRz,θ dθ = S(k)Rz,θ. (5.21) ⋄ Example 5.3 Let Rk,θ be a rotation about the axis deﬁned by k as in (2.71). Note that in this example k is not the unit coordinate vector (0, 0, 1)T . It is easy to check that S(k)3 = −S(k). Using this fact together with Problem ?? it follows that dRk,θ dθ = S(k)Rk,θ. (5.22) ⋄ 5.3 Angular Velocity: The General Case We now consider the general case of angular velocity about an arbitrary, possibly moving, axis. Suppose that a rotation matrix R is time varying, so that R = R(t) ∈ SO(3) for every t ∈ IR. Assuming that R(t) is continuously diﬀerentiable as a function of t an argument identical to the one in the previous section shows that the time derivative ˙R(t) of R(t) is given by ˙R(t) = S(t)R(t) (5.23) where the matrix S(t) is skew symmetric. Now, since S(t) is skew symmetric, it can be represented as S(ω(t)) for a unique vector ω(t). This vector ω(t) is the angular velocity of the rotating frame with respect to the ﬁxed frame at time t. Thus, the time derivative ˙R(t) is given by ˙R(t) = S(ω(t))R(t) (5.24) in which ω(t) is the angular velocity. Example 5.4 Suppose that R(t) = Rx,θ(t). Then ˙R(t) = dR dt is computed using the chain rule as ˙R = dR dθ dθ dt = ˙θS(i)R(t) = S(ω(t))R(t) (5.25) where ω = i ˙θ is the angular velocity. Note, here i = (1, 0, 0)T . ⋄ 5.4. ADDITION OF ANGULAR VELOCITIES 105 5.4 Addition of Angular Velocities We are often interested in ﬁnding the resultant angular velocity due to the relative rotation of several coordinate frames. We now derive the expressions for the composition of angular velocities of two moving frames o1x1y1z1 and o2x2y2z2 relative to the ﬁxed frame o0x0y0z0. For now, we assume that the three frames share a common origin. Let the relative orien- tations of the frames o1x1y1z1 and o2x2y2z2 be given by the rotation matrices R0 1(t) and R1 2(t) (both time varying). As in Chapter 2, R0 2(t) = R0 1(t)R1 2(t). (5.26) Taking derivatives of both sides of (5.26) with respect to time yields ˙R0 2 = ˙R0 1R1 2 + R0 1 ˙R1 2. (5.27) Using (5.24), the term ˙R0 2 on the left-hand side of (5.27) can be written ˙R0 2 = S(ω0 2)R0 2. (5.28) In this expression, ω0 2 denotes the total angular velocity experienced by frame o2x2y2z2. This angular velocity results from the combined rotations expressed by R0 1 and R1 2. The ﬁrst term on the right-hand side of (5.27) is simply ˙R0 1R1 2 = S(ω0 a)R0 1R1 2 = S(ω0 a)R0 2. (5.29) Note that in this equation, ω0 a denotes the angular velocity of frame o1x1y1z1 that results from the changing R0 1, and this angular velocity vector is expressed relative to the coordinate system o0x0y0z0. Let us examine the second term on the right hand side of (5.27). Using the expression (5.11) we have R0 1 ˙R1 2 = R0 1S(ω1 b)R1 2 (5.30) = R0 1S(ω1 b)R0 1T R0 1R1 2 = S(R0 1ω1 b)R0 1R1 2 = S(R0 1ω1 b)R0 2. (5.31) Note that in this equation, ω1 b denotes the angular velocity of frame o2x2y2z2 that corre- sponds to the changing R1 2, expressed relative to the coordinate system o1x1y1z1. Thus, the product R0 1ω1 b expresses this angular velocity relative to the coordinate system o0x0y0z0. Now, combining the above expressions we have shown that S(ω0 2)R0 2 = {S(ω0 a) + S(R0 1ω1 b)}R0 2. (5.32) Since S(a) + S(b) = S(a + b), we see that ω0 2 = ω0 a + R0 1ω1 b. (5.33) 106 CHAPTER 5. VELOCITY KINEMATICS – THE MANIPULATOR JACOBIAN In other words, the angular velocities can be added once they are expressed relative to the same coordinate frame, in this case o0x0y0z0. The above reasoning can be extended to any number of coordinate systems. In partic- ular, suppose that we are given R0 n = R0 1R1 2 · · · Rn−1 n . (5.34) Although it is a slight abuse of notation, let us represent by ωi−1 i the angular velocity due to the rotation given by Ri−1 i , expressed relative to frame oi−1xi−1yi−1zi−1. Extending the above reasoning we obtain ˙R0 n = S(ω0 n)R0 n (5.35) where ω0 n = ω0 1 + R0 1ω1 2 + R0 2ω2 3 + R0 3ω3 4 + · · · + R0 n−1ωn−1 n . (5.36) 5.5 Linear Velocity of a Point Attached to a Moving Frame We now consider the linear velocity of a point that is rigidly attached to a moving frame. Suppose the point p is rigidly attached to the frame o1x1y1z1, and that o1x1y1z1 is rotating relative to the frame o0x0y0z0. Then the coordinates of p with respect to the frame o0x0y0z0 are given by p0 = R0 1(t)p1. (5.37) The velocity ˙p0 is then given as ˙p0 = ˙R0 1(t)p1 + R0 1(t) ˙p1 (5.38) = S(ω0)R0 1(t)p1 (5.39) = S(ω0)p0 = ω0 × p0 which is the familiar expression for the velocity in terms of the vector cross product. Note that (5.39) follows from that fact that p is rigidly attached to frame o1x1y1z1, and therefore its coordinates relative to frame o1x1y1z1 do not change, giving ˙p1 = 0. Now suppose that the motion of the frame o1x1y1z1 relative to o0x0y0z0 is more general. Suppose that the homogeneous transformation relating the two frames is time-dependent, so that H 0 1 (t) = [ R0 1(t) o 0 1(t) 0 1 ] . (5.40) For simplicity we omit the argument t and the subscripts and superscripts on R0 1 and o 0 1, and write p0 = Rp 1 + o. (5.41) 5.6. DERIVATION OF THE JACOBIAN 107 Diﬀerentiating the above expression using the product rule gives ˙p0 = ˙Rp 1 + ˙o (5.42) = S(ω)Rp 1 + ˙o = ω × r + v where r = Rp 1 is the vector from o1 to p expressed in the orientation of the frame o0x0y0z0, and v is the rate at which the origin o1 is moving. If the point p is moving relative to the frame o1x1y1z1, then we must add to the term v the term R(t) ˙p1, which is the rate of change of the coordinates p1 expressed in the frame o0x0y0z0. 5.6 Derivation of the Jacobian Consider an n-link manipulator with joint variables q1, . . . , qn . Let T 0 n(q) = [ R0 n(q) o 0 n(q) 0 1 ] (5.43) denote the transformation from the end-eﬀector frame to the base frame, where q = (q1, . . . , qn)T is the vector of joint variables. As the robot moves about, both the joint variables qi and the end-eﬀector position o 0 n and orientation R0 n will be functions of time. The objective of this section is to relate the linear and angular velocity of the end-eﬀector to the vector of joint velocities ˙q(t). Let S(ω0 n) = ˙R0 n(R0 n) T (5.44) deﬁne the angular velocity vector ω0 n of the end-eﬀector, and let v0 n = ˙o 0 n (5.45) denote the linear velocity of the end eﬀector. We seek expressions of the form v0 n = Jv ˙q (5.46) ω0 n = Jω ˙q (5.47) where Jv and Jω are 3 × n matrices. We may write (5.46) and (5.47) together as [ v0 n ω0 n ] = J 0 n ˙q (5.48) where J 0 n is given by J 0 n = [ Jv Jω ] . (5.49) The matrix J 0 n is called the Manipulator Jacobian or Jacobian for short. Note that J 0 n is a 6 × n matrix where n is the number of links. We next derive a simple expression for the Jacobian of any manipulator. 108 CHAPTER 5. VELOCITY KINEMATICS – THE MANIPULATOR JACOBIAN 5.6.1 Angular Velocity Recall from Equation (5.36) that angular velocities can be added vectorially provided that they are expressed relative to a common coordinate frame. Thus we can determine the angular velocity of the end-eﬀector relative to the base by expressing the angular velocity contributed by each joint in the orientation of the base frame and then summing these. If the i-th joint is revolute, then the i-th joint variable qi equals θi and the axis of rotation is zi−1. Following the convention that we introduced above, let ωi−1 i represent the angular velocity of link i that is imparted by the rotation of joint i, expressed relative to frame oi−1xi−1yi−1zi−1. This angular velocity is expressed in the frame i − 1 by ωi−1 i = ˙qizi−1 i−1 = ˙qik (5.50) in which, as above, k is the unit coordinate vector (0, 0, 1)T . If the i-th joint is prismatic, then the motion of frame i relative to frame i − 1 is a translation and ωi−1 i = 0. (5.51) Thus, if joint i is prismatic, the angular velocity of the end-eﬀector does not depend on qi, which now equals di. Therefore, the overall angular velocity of the end-eﬀector, ω0 n, in the base frame is determined by Equation (5.36) as ω0 n = ρ1 ˙q1k + ρ2 ˙q2R0 1k + · · · + ρn ˙qnR0 n−1k (5.52) = n∑ i−1 ρi ˙qiz0 i−1 in which ρi is equal to 1 if joint i is revolute and 0 if joint i is prismatic, since z0 i−1 = R0 i−1k. (5.53) Of course z0 0 = k = (0, 0, 1)T . The lower half of the Jacobian Jω, in (5.49) is thus given as Jω = [ρ1z0 · · · ρnzn−1] . (5.54) Note that in this equation, we have omitted the superscripts for the unit vectors along the z-axes, since these are all referenced to the world frame. In the remainder of the chapter we will follow this convention when there is no ambiguity concerning the reference frame. 5.6.2 Linear Velocity The linear velocity of the end-eﬀector is just ˙o 0 n. By the chain rule for diﬀerentiation ˙o 0 n = n∑ i=1 ∂o0 n ∂qi ˙qi. (5.55) 5.6. DERIVATION OF THE JACOBIAN 109 Thus we see that the i-th column of Jv, which we denote as Jvi is given by Jvi = ∂o0 n ∂qi . (5.56) Furthermore this expression is just the linear velocity of the end-eﬀector that would result if ˙qi were equal to one and the other ˙qj were zero. In other words, the i-th column of the Jacobian can be generated by holding all joints ﬁxed but the i-th and actuating the i-th at unit velocity. We now consider the two cases (prismatic and revolute joints) separately. (i) Case 1: Prismatic Joints If joint i is prismatic, then it imparts a pure translation to the end-eﬀector. From our study of the DH convention in Chapter 3, we can write the T 0 n as the product of three transformations as follows [ R0 n o 0 n 0 1 ] = T 0 n (5.57) = T 0 i−1T i−1 i T i n (5.58) = [ R0 i−1 o 0 i−1 0 1 ] [ Ri−1 i o i−1 i 0 1 ] [ Ri n o i n 0 1 ] (5.59) = [ R0 n R0 i o i n + R0 i−1o i−1 i + o 0 i−1 0 1 ] , (5.60) which gives o 0 n = R0 i o i n + R0 i−1o i−1 i + o 0 i−1. (5.61) If only joint i is allowed to move, then both of o i n and o 0 i−1 are constant. Furthermore, if joint i is prismatic, then the rotation matrix R0 i−1 is also constant (again, assuming that only joint i is allowed to move). Finally, recall from Chapter 3 that, by the DH convention, o i−1 i = (aici, aisi, di)T . Thus, diﬀerentiation of o 0 n gives ∂o0 n ∂qi = ∂ ∂di R0 i−1o i−1 i (5.62) = R0 i−1 ∂ ∂di   aici aisi di   (5.63) = ˙diR0 i−1   0 0 1   (5.64) = ˙diz0 i−1, (5.65) 110 CHAPTER 5. VELOCITY KINEMATICS – THE MANIPULATOR JACOBIAN in which di is the joint variable for prismatic joint i. Thus, (again, dropping the zero superscript on the z-axis) for the case of prismatic joints we have Jvi = zi−1. (5.66) (ii) Case 2: Revolute Joints If joint i is revolute, then we have qi = θi. Starting with (5.61), and letting qi = θi, since R0 i is not constant with respect to θi, we obtain ∂ ∂θi o 0 n = ∂ ∂θi [ R0 i o i n + R0 i−1o i−1 i ] (5.67) = ∂ ∂θi R0 i o i n + R0 i−1 ∂ ∂θi o i−1 i (5.68) = ˙θiS(z0 i−1)R0 i o i n + ˙θiS(z0 i−1)R0 i−1o i−1 i (5.69) = ˙θiS(z0 i−1) [ R0 i o i n + R0 i−1o i−1 i ] (5.70) = ˙θiS(z0 i−1)(o 0 n − o 0 i−1) (5.71) = ˙θiz0 i−1 × (o 0 n − o 0 i−1). (5.72) The second term in (5.69) is derived as follows: R0 i−1 ∂ ∂θi   aici aisi di   = R0 i−1   −aisi aici 0   ˙θi (5.73) = R0 i−1S(k ˙θi)o i−1 i (5.74) = R0 i−1S(k ˙θi) (R0 i−1)T R0 i−1o i−1 i (5.75) = S(R0 i−1k ˙θi)R0 i−1o i−1 i (5.76) = ˙θiS(z0 i−1)R0 i−1o i−1 i . (5.77) Equation (5.74) follows by straightforward computation. Thus Jvi = zi−1 × (on − oi−1), (5.78) in which we have, following our convention, omitted the zero superscripts. Figure 5.1 illustrates a second interpretation of (5.78). As can be seen in the ﬁgure, on − oi−1 = r and zi−1 = ω in the familiar expression v = ω × r. Combining the Angular and Linear Jacobians As we have seen in the preceding section, the upper half of the Jacobian Jv is given as Jv = [Jv1 · · · Jvn] (5.79) 5.6. DERIVATION OF THE JACOBIAN 111 Oi−1 y0 x0 z0 On θi d0−1 r ≡ di−1 n ω ≡ zi−1 Figure 5.1: Motion of the end-eﬀector due to link i. where the i-th column Jvi is Jvi = zi−1 × (on − oi−1) (5.80) if joint i is revolute and Jvi = zi−1 (5.81) if joint i is prismatic. The lower half of the Jacobian is given as Jω = [Jω1 · · · Jωn] (5.82) where the i-th column Jωi is Jωi = zi−1 (5.83) if joint i is revolute and Jωi = 0 (5.84) if joint i is prismatic. Now putting the upper and lower halves of the Jacobian together we have shown that the Jacobian for an n-link manipulator is of the form J = [J1J2 · · · Jn] (5.85) where the i-th column Ji is given by Ji = [ zi−1 × (on − oi−1) zi−1 ] (5.86) 112 CHAPTER 5. VELOCITY KINEMATICS – THE MANIPULATOR JACOBIAN if joint i is revolute and Ji = [ zi−1 0 ] (5.87) if joint i is prismatic. The above formulas make the determination of the Jacobian of any manipulator simple since all of the quantities needed are available once the forward kinematics are worked out. Indeed the only quantities needed to compute the Jacobian are the unit vectors zi and the coordinates of the origins o1, . . . , on. A moment’s reﬂection shows that the coordinates for zi w.r.t. the base frame are given by the ﬁrst three elements in the third column of T 0 i while oi is given by the ﬁrst three elements of the fourth column of T 0 i . Thus only the third and fourth columns of the T matrices are needed in order to evaluate the Jacobian according to the above formulas. The above procedure works not only for computing the velocity of the end-eﬀector but also for computing the velocity of any point on the manipulator. This will be important in Chapter 9 when we will need to compute the velocity of the center of mass of the various links in order to derive the dynamic equations of motion. Example 5.5 Consider the three-link planar manipulator of Figure 5.2. Suppose we wish v ω z0 x0 z1 x1 y0 y1 Oc Figure 5.2: Finding the velocity of link 2 of a 3-link planar robot. to compute the linear velocity v and the angular velocity ω of the center of link 2 as shown. In this case we have that [ v ω ] = [J1 J2 J3] ˙q (5.88) where the columns of the Jacobian are determined using the above formula with oc in place of on. Thus we have J1 = z0 × (oc − o0) (5.89) J2 = z1 × (oc − o1) 5.7. EXAMPLES 113 and J3 = 0 since the velocity of the second link is unaﬀected by motion of link 33. Note that in this case the vector oc must be computed as it is not given directly by the T matrices (Problem 5-1). ⋄ 5.7 Examples Example 5.6 Consider the two-link planar manipulator of Example 3.1. Since both joints are revolute the Jacobian matrix, which in this case is 6 × 2, is of the form J(q) = [ z0 × (o2 − o0) z1 × (o2 − o1) z0 z1 ] . (5.90) The various quantities above are easily seen to be o0 =   0 0 0   o1 =   a1c1 a1s1 0   o2 =   a1c1 + a2c12 a1s1 + a2s12 0   (5.91) z0 = z1 =   0 0 1   . (5.92) Performing the required calculations then yields J =         −a1s1 − a2s12 −a2s12 a1c1 + a2c12 a2c12 0 0 0 0 0 0 1 1         . (5.93) It is easy to see how the above Jacobian compares with the expression (1.1) derived in Chapter 1. The ﬁrst two rows of (5.92) are exactly the 2 × 2 Jacobian of Chapter 1 and give the linear velocity of the origin o2 relative to the base. The third row in (5.93) is the linear velocity in the direction of z0, which is of course always zero in this case. The last three rows represent the angular velocity of the ﬁnal frame, which is simply a rotation about the vertical axis at the rate ˙θ1 + ˙θ2. 3Note that we are treating only kinematic eﬀects here. Reaction forces on link 2 due to the motion of link 3 will inﬂuence the motion of link 2. These dynamic eﬀects are treated by the methods of Chapter 9. 114 CHAPTER 5. VELOCITY KINEMATICS – THE MANIPULATOR JACOBIAN ⋄ Example 5.7 Stanford Manipulator Consider the Stanford manipulator of Exam- ple 3.3.5 with its associated Denavit-Hartenberg coordinate frames. Note that joint 3 is prismatic and that o3 = o4 = o5 as a consequence of the spherical wrist and the frame assignment. Denoting this common origin by o we see that the Jacobian is of the form J = [ z0 × (o6 − o0) z1 × (o6 − o1) z2 z3 × (o6 − o) z4 × (o6 − o) z5 × (o6 − o) z0 z1 0 z3 z4 z5 ] . Now, using the A-matrices given by the expressions (3.35)-(3.40) and the T -matrices formed as products of the A-matrices, these quantities are easily computed as follows: First, oj is given by the ﬁrst three entries of the last column of T 0 j = A1 · · · Aj, with o0 = (0, 0, 0)T = o1. The vector zj is given as zj = R0 j k (5.94) where R0 j is the rotational part of T 0 j . Thus it is only necessary to compute the matrices T 0 j to calculate the Jacobian. Carrying out these calculations one obtains the following expressions for the Stanford manipulator: o6 = (dx, dy, dz) T =   c1s2d3 − s1d2 + d6(c1c2c4s5 + c1c5s2 − s1s4s5) s1s2d3 − c1d2 + d6(c1s4s5 + c2c4s1s5 + c5s1s2) c2d3 + d6(c2c5 − c4s2s5)   (5.95) o3 =   c1s2d3 − s1d2 s1s2d3 + c1d2 c2d3   . (5.96) The zi are given as z0 =   0 0 1   z1 =   −s1 c1 0   (5.97) z2 =   c1s2 s1s2 c2   z3 =   c1s2 s1s2 c2   (5.98) z4 =   −c1c2s4 − s1c4 −s1c2s4 + c1c4 s2s4   (5.99) z5 =   c1c2c4s5 − s1s4s5 + c1s2c5 s1c2c4s5 + c1s4s5 + s1s2c5 −s2c4s5 + c2c5   . (5.100) The Jacobian of the Stanford Manipulator is now given by combining these expressions according to the given formulae (Problem ??). 5.8. THE ANALYTICAL JACOBIAN 115 ⋄ Example 5.8 SCARA Manipulator We will now derive the Jacobian of the SCARA manipulator of Example 3.3.6. This Jacobian is a 6 × 4 matrix since the SCARA has only four degrees-of-freedom. As before we need only compute the matrices T 0 j = A1 . . . Aj, where the A-matrices are given by (3.45)-(3.48). Since joints 1,2, and 4 are revolute and joint 3 is prismatic, and since o4 − o3 is parallel to z3 (and thus, z3 × (o4 − o3) = 0), the Jacobian is of the form J = [ z0 × (o4 − o0) z1 × (o4 − o1) z2 0 z0 z1 0 z3 ] . (5.101) Performing the indicated calculations, one obtains o1 =   a1c1 a1s1 0   o2 =   a1c1 + a2c12 a1s1 + a2s12 0   (5.102) o4 =   a1c1 + a2c12 a1s2 + a2s12 d3 − d4   . (5.103) Similarly z0 = z1 = k, and z2 = z3 = −k. Therefore the Jacobian of the SCARA Manipulator is J =         −a1s1 − a2s12 −a2s12 0 0 a1c1 + a2c12 a2c12 0 0 0 0 −1 0 0 0 0 0 0 0 0 0 1 1 0 −1         . (5.104) ⋄ 5.8 The Analytical Jacobian The Jacobian matrix derived above is sometimes called the Geometric Jacobian to distin- guish it from the Analytical Jacobian, denoted Ja(q), considered in this section, which is based on a minimal representation for the orientation of the end-eﬀector frame. Let X = [ d(q) α(q) ] (5.105) denote the end-eﬀector pose, where d(q) is the usual vector from the origin of the base frame to the origin of the end-eﬀector frame and α denotes a minimal representation for the orientation of the end-eﬀector frame relative to the base frame. For example, let α = 116 CHAPTER 5. VELOCITY KINEMATICS – THE MANIPULATOR JACOBIAN [φ, θ, ψ]T be a vector of Euler angles as deﬁned in Chapter 2. Then we look for an expression of the form ˙X = [ ˙d ˙α ] = Ja(q) ˙q (5.106) to deﬁne the analytical Jacobian. It can be shown (Problem X) that, if R = Rz,ψRy,θRz,φ is the Euler angle transformation then ˙R = S(ω)R (5.107) where ω, deﬁning the angular velocity is given by ω =   cψsθ ˙φ − sψ ˙θ sψsθ ˙ψ + cψθ ˙ψ + cθ ˙ψ   (5.108) =   cψsθ −sψ 0 sψsθ cψ 0 cθ 0 1     ˙φ ˙θ ˙ψ   = T (α) ˙α (5.109) The components of ω are called the nutation, spin, and precession. Combining the above relationship with the previous deﬁnition of the Jacobian, i.e. [ v ω ] = [ ˙d ω ] = J(q) ˙q (5.110) yields J(q) ˙q = [ v ω ] = [ ˙d T (α) ˙α ] (5.111) = [ I 0 0 T (α) ] [ ˙d ˙α ] (5.112) = [ I 0 0 T (α) ] Ja (5.113) Thus the analytical Jacobian, Ja(q), may be computed from the geometric Jacobian as Ja(q) = [ I 0 0 T (α)−1 ] J(q) (5.114) provided det(T (α)) ̸= 0. In the next section we discuss the notion of Jacobian singularities, which are conﬁg- urations where the Jacobian loses rank. Singularities of the matrix T (α) are called rep- resentational singularities. It can easily be shown (Problem X) that T (α) is invertible provided sθ ̸= 0. This means that the singularities of the analytical Jacobian include the singularities of the geometric Jacobian, J, as deﬁned in the next section, together with the representational singularities. 5.9. SINGULARITIES 117 5.9 Singularities The 6 × n Jacobian J(q) deﬁnes a mapping ˙X = J(q) ˙q (5.115) between the vector ˙q of joint velocities and the vector ˙X = (v, ω)T of end-eﬀector velocities. Inﬁnitesimally this deﬁnes a linear transformation dX = J(q)dq (5.116) between the diﬀerentials dq and dX. These diﬀerentials may be thought of as deﬁning directions in IR 6, and IR n, respectively. Since the Jacobian is a function of the conﬁguration q, those conﬁgurations for which the rank of J decreases are of special signiﬁcance. Such conﬁgurations are called singularities or singular conﬁgurations. Identifying manipulator singularities is important for several reasons. 1. Singularities represent conﬁgurations from which certain directions of motion may be unattainable. 2. At singularities, bounded end-eﬀector velocities may correspond to unbounded joint velocities. 3. At singularities, bounded end-eﬀector forces and torques may correspond to unbounded joint torques. (We will see this in Chapter 12). 4. Singularities usually (but not always) correspond to points on the boundary of the manipulator workspace, that is, to points of maximum reach of the manipulator. 5. Singularities correspond to points in the manipulator workspace that may be unreachable under small perturbations of the link parameters, such as length, oﬀset, etc. 6. Near singularities there will not exist a unique solution to the inverse kinematics problem. In such cases there may be no solution or there may be inﬁnitely many solutions. Example 5.9 Consider the two-dimensional system of equations dX = Jdq = [ 1 1 0 0 ] dq (5.117) that corresponds to the two equations dx = dq1 + dq2 (5.118) dy = 0. (5.119) In this case the rank of J is one and we see that for any values of the variables dq1 and dq2 there is no change in the variable dy. Thus any vector dX having a nonzero second component represents an unattainable direction of instantaneous motion. ⋄ 118 CHAPTER 5. VELOCITY KINEMATICS – THE MANIPULATOR JACOBIAN 5.9.1 Decoupling of Singularities We saw in Chapter 3 that a set of forward kinematic equations can be derived for any manipulator by attaching a coordinate frame rigidly to each link in any manner that we choose, computing a set of homogeneous transformations relating the coordinate frames, and multiplying them together as needed. The D-H convention is merely a systematic way to do this. Although the resulting equations are dependent on the coordinate frames chosen, the manipulator conﬁgurations themselves are geometric quantities, independent of the frames used to describe them. Recognizing this fact allows us to decouple the determination of singular conﬁgurations, for those manipulators with spherical wrists, into two simpler problems. The ﬁrst is to determine so-called arm singularities, that is, singularities resulting from motion of the arm, which consists of the ﬁrst three or more links, while the second is to determine the wrist singularities resulting from motion of the spherical wrist. For the sake of argument, suppose that n = 6, that is, the manipulator consists of a 3-DOF arm with a 3-DOF spherical wrist. In this case the Jacobian is a 6 × 6 matrix and a conﬁguration q is singular if and only if det J(q) = 0. (5.120) If we now partition the Jacobian J into 3 × 3 blocks as J = [JP | JO] = [ J11 J21 J12 J22 ] (5.121) then, since the ﬁnal three joints are always revolute JO = [ z3 × (o6 − o3) z4 × (o6 − o4) z5 × (o6 − o5) z3 z4 z5 ] . (5.122) Since the wrist axes intersect at a common point o, if we choose the coordinate frames so that o3 = o4 = o5 = o6 = o, then JO becomes JO = [ 0 0 0 z3 z4 z5 ] (5.123) and the i-th column Ji of Jp is Ji = [ zi−1 × (o − oi−1) zi−1 ] (5.124) if joint i is revolute and Ji = [ zi−1 0 ] (5.125) if joint i is prismatic. In this case the Jacobian matrix has the block triangular form J = [ J11 0 J21 J22 ] (5.126) 5.9. SINGULARITIES 119 with determinant det J = det J11 det J22 (5.127) where J11 and J22 are each 3 × 3 matrices. J11 has i-th column zi−1 × (o − oi−1) if joint i is revolute, and zi−1 if joint i is prismatic, while J22 = [z3 z4 z5]. (5.128) Therefore the set of singular conﬁgurations of the manipulator is the union of the set of arm conﬁgurations satisfying det J11 = 0 and the set of wrist conﬁgurations satisfying det J22 = 0. Note that this form of the Jacobian does not necessarily give the correct relation between the velocity of the end-eﬀector and the joint velocities. It is intended only to simplify the determination of singularities. 5.9.2 Wrist Singularities We can now see from (5.128) that a spherical wrist is in a singular conﬁguration whenever the vectors z3, z4 and z5 are linearly dependent. Referring to Figure 5.3 we see that this z4 θ6θ4 θ5 = 0 z3 z5 Figure 5.3: Spherical wrist singularity. happens when the joint axes z3 and z5 are collinear. In fact, whenever two revolute joint axes anywhere are collinear, a singularity results since an equal and opposite rotation about the axes results in no net motion of the end-eﬀector. This is the only singularity of the spherical wrist, and is unavoidable without imposing mechanical limits on the wrist design to restrict its motion in such a way that z3 and z5 are prevented from lining up. 5.9.3 Arm Singularities In order to investigate arm singularities we need only to compute J11 according to (5.124) and (5.125), which is the same formula derived previously with the wrist center o in place of o6. Example 5.10 Elbow Manipulator Singularities Consider the three-link articulated manipulator with coordinate frames attached as shown in Figure 5.4. It is left as an exercise 120 CHAPTER 5. VELOCITY KINEMATICS – THE MANIPULATOR JACOBIAN z2 x0 z0 x1 x2 z1 y1 y2 y0 Oc d0 Figure 5.4: Elbow manipulator. (Problem ??) to show that J11 =   −a2s1c2 − a3s1c23 −a2s2c1 − a3s23c1 −a3c1s23 a2c1c2 + a3c1c23 −a2s1s2 − a3s1s23 −a3s1s23 0 a2c2 + a3c23 a3c23   (5.129) and that the determinant of J11 is det J11 = a2a3s3(a2c2 + a3c23). (5.130) We see from (5.130) that the elbow manipulator is in a singular conﬁguration whenever s3 = 0, that is, θ3 = 0 or π (5.131) and whenever a2c2 + a3c23 = 0. (5.132) The situation of (5.131) is shown in Figure 5.5 and arises when the elbow is fully ex- θ3 = 0◦θ3 = 180◦ Figure 5.5: Elbow singularities of the elbow manipulator. tended or fully retracted as shown. The second situation (5.132) is shown in Figure 5.6. 5.9. SINGULARITIES 121 z0 θ1 Figure 5.6: Singularity of the elbow manipulator with no oﬀsets. This conﬁguration occurs when the wrist center intersects the axis of the base rotation, z0. As we saw in Chapter 4, there are inﬁnitely many singular conﬁgurations and inﬁnitely many solutions to the inverse position kinematics when the wrist center is along this axis. For an elbow manipulator with an oﬀset, as shown in Figure 5.7, the wrist center cannot z0 d Figure 5.7: Elbow manipulator with shoulder oﬀset. intersect z0, which corroborates our earlier statement that points reachable at singular con- ﬁgurations may not be reachable under arbitrarily small perturbations of the manipulator parameters, in this case an oﬀset in either the elbow or the shoulder. ⋄ 122 CHAPTER 5. VELOCITY KINEMATICS – THE MANIPULATOR JACOBIAN Example 5.11 Spherical Manipulator Consider the spherical arm of Figure 5.8. This θ1 z0 Figure 5.8: Singularity of spherical manipulator with no oﬀsets. manipulator is in a singular conﬁguration when the wrist center intersects z0 as shown since, as before, any rotation about the base leaves this point ﬁxed. ⋄ Example 5.12 SCARA Manipulator We have already derived the complete Jacobian for the the SCARA manipulator. This Jacobian is simple enough to be used directly rather than deriving the modiﬁed Jacobian from this section. Referring to Figure 5.9 we can see z0 z1 z2 θ2 = 0◦ Figure 5.9: SCARA manipulator singularity. geometrically that the only singularity of the SCARA arm is when the elbow is fully extended or fully retracted. Indeed, since the portion of the Jacobian of the SCARA governing arm 5.10. INVERSE VELOCITY AND ACCELERATION 123 singularities is given as J11 =   α1 α3 0 α2 α4 0 0 0 −1   (5.133) where α1 = −a1s1 − a2s12 (5.134) α2 = a1c1 + a2c12 α3 = −a1s12 α4 = a1c12 (5.135) we see that the rank of J11 will be less than three precisely whenever α1α4 − α2α3 = 0. It is easy to compute this quantity and show that it is equivalent to (Problem ??) s2 = 0, which implies θ2 = 0, π. (5.136) ⋄ 5.10 Inverse Velocity and Acceleration It is perhaps a bit surprising that the inverse velocity and acceleration relationships are conceptually simpler than inverse position. Recall from (5.115) that the joint velocities and the end-eﬀector velocities are related by the Jacobian as ˙X = J(q) ˙q. (5.137) Thus the inverse velocity problem becomes one of solving the system of linear equations (5.137), which is conceptually simple. Diﬀerentiating (5.137) yields the acceleration equations ¨X = J(q)¨q + ( d dt J(q) ) ˙q. (5.138) Thus, given a vector ¨X of end-eﬀector accelerations, the instantaneous joint acceleration vector q is given as a solution of b = J(q)¨q (5.139) where b = ¨X − d dt J(q) ˙q (5.140) 124 CHAPTER 5. VELOCITY KINEMATICS – THE MANIPULATOR JACOBIAN For 6-DOF manipulators the inverse velocity and acceleration equations can therefore be written as ˙q = J(q) −1 ˙X (5.141) and ¨q = J(q) −1b (5.142) provided det J(q) ̸= 0. In the next section, we address the case of manipulators with more than 6-DOF. 5.11 Redundant Robots and Manipulability In this section we brieﬂy address the topic of redundant manipulators. Informally, a redun- dant manipulator is one that is equipped with more internal degrees of freedom than are required to perform a speciﬁed task. For example, a three link planar arm is redundant for the task of positioning in the plane. As we have brieﬂy seen in Chapter 4, in such cases there in no unique solution for the inverse kinematics problem. Further, the Jacobian matrix for a redundant manipulator is not square, and thus cannot be inverted to solve the inverse velocity problem. In this section, we begin by giving a brief and general introduction to the subject of redundant manipulators. We then turn our attention to the inverse velocity problem. To address this problem, we will introduce the concept of a pseudoinverse and the Singular Value Decomposition. We end the section by introducing manipulability, a measure that can be used to quantify the quality of the internal conﬁguration of a manipulator, and can therefore be used in an optimization framework to aid in the solution for the inverse kinematics problem. 5.11.1 Redundant Manipulators A precise deﬁnition of what is meant by the term redundant requires that we specify a task, and the number of degrees of freedom required to perform that task. In previous chapters, we have dealt primarily with positioning tasks. In these cases, the task was determined by specifying the position, orientation or both for the end eﬀector or some tool mounted at the end eﬀector. For these kinds of positioning tasks, the number of degrees of freedom for the task is equal to the number of parameters required to specify the position and orientation information. For example, if the task involves positioning the end eﬀector in a 3D workspace, then the task can be speciﬁed by an element of ℜ3 × SO(3). As we have seen in Chapter 2, ℜ3 × SO(3) can be parameterized by (x, y, z, φ, θ, ψ), i.e., using six parameters. Thus, for this task, the task space is six-dimensional. A manipulator is said to be redundant when its number of internal degrees of freedom (or joints) is greater than the dimension of the task space. Thus, for the 3D position and orientation task, any manipulator with more than six joints would be redundant. 5.11. REDUNDANT ROBOTS AND MANIPULABILITY 125 A simpler example is a three-link planar arm performing the task of positioning the end eﬀector in the plane. Here, the task can be speciﬁed by (x, y) ∈ ℜ2, and therefore the task space is two-dimensional. The forward kinematic equations for this robot are given by x = a1c1 + a2c12 + a3c123 y = a1s1 + a2s12 + a3s123. Clearly, since there are three variables (θ1, θ2, θ3) and only two equations, it is not possible to solve uniquely for θ1, θ2, θ3 given a speciﬁc (x, y). The Jacobian for this manipulator is given by J = [ −a1s1 − a2s12 −a2s12 −a3s123 a1c1 + a2c12 a2c12 a3c123 ] . (5.143) When using the relationship ˙x = J ˙q to for ˙q, we have a system of two linear equations in three unknowns. Thus there are also inﬁnitely many solutions to this system, and the inverse velocity problem cannot be solved uniquely. We now turn our attention to the speciﬁcs of dealing with these inverse problems. 5.11.2 The Inverse Velocity Problem for Redundant Manipulators We have seen in Section 5.10 that the inverse velocity problem is easily solved when the Jacobian is square with nonzero determinant. However, when the Jacobian is not square, as is the case for redundant manipulators, the method of Section 5.10 cannot be used, since a nonsquare matrix cannot be inverted. To deal with the case when m < n, we use the following result from linear algebra. Proposition: For J ∈ ℜm×n, if m < n and rank J = m, then (JJT )−1 exists. In this case (JJT ) ∈ ℜm×m, and has rank m. Using this result, we can regroup terms to obtain (JJT )(JJT ) −1 = I J [ JT (JJT ) −1] = I JJ+ = I. Here, J+ = JT (JJT )−1 is called a right pseudoinverse of J, since JJ+ = I. Note that, J+J ∈ ℜn×n, and that in general, J+J ̸= I (recall that matrix multiplication is not commutative). It is now easy to demonstrate that a solution to (5.137) is given by ˙q = J+ ˙x + (I − J+J)b (5.144) in which b ∈ ℜn is an arbitrary vector. To see this, multiply this solution by J: 126 CHAPTER 5. VELOCITY KINEMATICS – THE MANIPULATOR JACOBIAN J ˙q = J [J+ ˙x + (I − J+J)b] = JJ+ ˙x + J(I − J+J)b = JJ+ ˙x + (J − JJ+J)b = ˙x + (J − J)b = ˙x. In general, for m < n, (I − J+J) ̸= 0, and all vectors of the form (I − J+J)b lie in the null space of J, i.e., if ˙qn is a joint velocity vector such that ˙qn = (I − J+J)b, then when the joints move with velocity ˙qn, the end eﬀector will remain ﬁxed since J ˙qn = 0. Thus, if ˙q is a solution to (5.137), then so is ˙q + ˙qn with ˙qn = (I − J+J)b, for any value of b. If the goal is to minimize the resulting joint velocities, we choose b = 0. To see this, apply the triangle inequality to obtain || ˙q || = || J+ ˙x + (I − J+J)b || ≤ || J+ ˙x || + || (I − J+J)b ||. 5.11.3 Singular Value Decomposition (SVD) For robots that are not redundant, the Jacobian matrix is square, and we can use tools such as the determinant, eigenvalues and eigenvectors to analyze its properties. However, for redundant robots, the Jacobian matrix is not square, and these tools simply do not apply. Their generalizations are captured by the Singular Value Decomposition (SVD) of a matrix, which we now introduce. As we described above, for J ∈ ℜm×n, we have JJT ∈ ℜm×m. This square matrix has eigenvalues and eigenvectors that satisfy JJT ui = λiui (5.145) in which λi and ui are corresponding eigenvalue and eigenvector pairs for JJT . We can rewrite this equation to obtain JJT ui − λiui = 0 (JJT − λiI)ui = 0. (5.146) The latter equation implies that the matrix (JJT − λiI) is singular, and we can express this in terms of its determinant as det(JJT − λiI) = 0. (5.147) We can use (5.147) to ﬁnd the eigenvalues λ1 ≥ λ2 · · · ≥ λm ≥ 0 for JJT . The singular values for the Jacobian matrix J are given by the square roots of the eigenvalues of JJT , σi = √λi. (5.148) 5.11. REDUNDANT ROBOTS AND MANIPULABILITY 127 The singular value decomposition of the matrix J is then given by J = UΣVT , (5.149) in which U = [u1u2 . . . um] , V = [v1v2 . . . vn] (5.150) are orthogonal matrices, and Σ ∈ Rm×n. Σ =       σ1 σ2 . . σm ∣ ∣ ∣ ∣ ∣ ∣ ∣ ∣ ∣ ∣ 0       . (5.151) We can compute the SVD of J as follows. We begin by ﬁnding the singular values, σi, of J using (5.147) and (5.148). These singular values can then be used to ﬁnd the eigenvectors u1, · · · um that satisfy JJT ui = σ2 i ui. (5.152) These eigenvectors comprise the matrix U = [u1u2 . . . um]. The system of equations (5.152) can be written as JJT U = UΣ2 m (5.153) if we deﬁne the matrix Σm as Σm =       σ1 σ2 . . σm       . Now, deﬁne Vm = JT UΣ−1 m (5.154) and let V be any orthogonal matrix that satisﬁes V = [Vm | Vn−m] (note that here Vn−m contains just enough columns so that the matrix V is an n × n matrix). It is a simple 128 CHAPTER 5. VELOCITY KINEMATICS – THE MANIPULATOR JACOBIAN matter to combine the above equations to verify (5.149): UΣVT = U [Σm | 0] [ VT m VT n−m ] (5.155) = UΣmVT m (5.156) = UΣm (JT UΣ−1 m )T (5.157) = UΣm(Σ−1 m ) T U T J (5.158) = UΣmΣ−1 m U T J (5.159) = UU T J (5.160) = J. (5.161) Here, (5.155) follows immediately from our construction of the matrices U, V and Σm. Equation (5.157) is obtained by substituting (5.154) into (5.156). Equation (5.159) follows because Σ−1 m is a diagonal matrix, and thus symmetric. Finally, (5.161) is obtained using the fact that UT = U−1, since U is orthogonal. It is a simple matter construct the right pseudoinverse of J using the SVD, J+ = VΣ+U T in which Σ+ =       σ−1 1 σ−1 2 . . σ−1 m ∣ ∣ ∣ ∣ ∣ ∣ ∣ ∣ ∣ ∣ 0       T . 5.11.4 Manipulability For a speciﬁc value of q, the Jacobian relationship deﬁnes the linear system given by ˙x = J ˙q. We can think of J a scaling the input, ˙q, to produce the output, ˙x. It is often useful to characterize quantitatively the eﬀects of this scaling. Often, in systems with a single input and a single output, this kind of characterization is given in terms of the so called impulse response of a system, which essentially characterizes how the system responds to a unit input. In this multidimensional case, the analogous concept is to characterize the output in terms of an input that has unit norm. Consider the set of all robot tool velocities ˙q such that ∥ ˙q∥ = ( ˙q2 1 + ˙q2 2 + . . . ˙q2 m) 1/2 ≤ 1. (5.162) 5.11. REDUNDANT ROBOTS AND MANIPULABILITY 129 If we use the minimum norm solution ˙q = J+ ˙x, we obtain ∥ ˙q∥ = ˙qT ˙q = (J+ ˙x) T J+ ˙x = ˙x T (J+) T J+ ˙x = ˙x T (JT (JJT ) −1) T JT (JJT ) −1 ˙x = ˙x T [(JJT ) −1] T JJT (JJT ) −1 ˙x = ˙x T (JJT ) −1 ˙x ≤ 1. (5.163) This ﬁnal inequality gives us a quantitative characterization of the scaling that is eﬀected by the Jacobian. In particular, if the manipulator Jacobian is full rank, i.e., rank J = m, then (5.163) deﬁnes an m-dimensional ellipsoid that is known as the manipulability ellipsoid. If the input (i.e., joint velocity) vector has unit norm, then the output (i.e., task space velocity) will lie within the ellipsoid given by (5.163). We can more easily see that (5.163) deﬁnes an ellipsoid by replacing J by its SVD to obtain ˙x T (JJT ) −1 ˙x T = ˙x T [UΣVT (UΣVT ) T ] −1 ˙x = ˙x T [UΣVT VΣT U T ] −1 ˙x = ˙x T [UΣΣT U T ] −1 ˙x = ˙x T [UΣ2 mU T ] −1 ˙x = ˙x T [UΣ−2 m U T ] ˙x = ( ˙x T U)Σ−2 m (U T ˙x) = (U T ˙x) T Σ−2 m (U T ˙x) (5.164) in which Σ−2 m =       σ−2 1 σ−2 2 . . σ−2 m       . If we make the substation w = UT ˙x, then (5.164) can be written as wT Σ−2 m w = ∑ σ−2 i w2 i ≤ 1 (5.165) and it is clear that this is the equation for an axis-aligned ellipse in a new coordinate system that is obtained by rotation according to the orthogonal matrix U. In the original coordinate system, the axes of the ellipsoid are given by the vectors σiui. The volume of the ellipsoid is given by volume = Kσ1σ2 · · · σm, in which K is a constant that depends only on the dimension, m, of the ellipsoid. The manipulability measure, as deﬁned by Yoshikawa [?], is given by ω = σ1σ2 · · · σm. (5.166) 130 CHAPTER 5. VELOCITY KINEMATICS – THE MANIPULATOR JACOBIAN Note that the constant K is not included in the deﬁnition of manipulability, since it is ﬁxed once the task has been deﬁned (i.e., once the dimension of the task space has been ﬁxed). Now, consider the special case that the robot is not redundant, i.e., J ∈ ℜm×m. Recall that the determinant of a product is equal to the product of the determinants, and that a matrix and its transpose have the same determinant. Thus, we have det JJT = det J det JT = det J det J = (λ1λ2 · · · λm)(λ1λ2 · · · λm) = λ2 1λ2 2 · · · λ2 m (5.167) in which λ1 ≥ λ2 · · · ≤ λm are the eigenvalues of J. This leads to ω = √ det JJT = |λ1λ2 · · · λm| = |det J|. (5.168) The manipulability, ω, has the following properties. • In general, ω = 0 holds if and only if rank(J) < m, (i.e., when J is not full rank). • Suppose that there is some error in the measured velocity, ∆ ˙x. We can bound the corresponding error in the computed joint velocity, ∆ ˙q, by (σ1) −1 ≤ ||∆ ˙q|| ||∆ ˙x|| ≤ (σm) −1. (5.169) Example 5.13 Two-link Planar Arm. We can use manipulability to determine the optimal conﬁgurations in which to perform certain tasks. In some cases it is desirable to perform a task in the conﬁguration for which the end eﬀector has the maximum dexterity. We can use manipulability as a measure of dexterity. Consider the two-link planar arm and the task of positioning in the plane. For the two link arm, the Jacobian is given by J = [ −a1s1 − a2s12 −a2s12 a1c1 + a2c12 a2c12 ] . (5.170) and the manipulability is given by ω = |det J| = a1a2|s2| Thus, for the two-link arm, the maximum manipulability is obtained for θ2 = ±π/2. Manipulability can also be used to aid in the design of manipulators. For example, suppose that we wish to design a two-link planar arm whose total link length, a1 + a2, is ﬁxed. What values should be chosen for a1 and a2? If we design the robot to maximize the maximum manipulability, the we need to maximize ω = a1a2|s2|. We have already seen that the maximum is obtained when θ2 = ±π/2, so we need only ﬁnd a1 and a2 to maximize the product a1a2. This is achieved when a1 = a2. Thus, to maximize manipulability, the link lengths should be chosen to be equal. ⋄ Chapter 6 COMPUTER VISION If a robot is to interact with its environment, then the robot must be able to sense its environment. Computer vision is one of the most powerful sensing modalities that currently exist. Therefore, in this chapter we present a number of basic concepts from the ﬁeld of computer vision. It is not our intention here to cover the now vast ﬁeld of computer vision. Rather, we aim to present a number of basic techniques that are applicable to the highly constrained problems that often present themselves in industrial applications. The material in this chapter, when combined with the material of previous chapters, should enable the reader to implement a rudimentary vision-based robotic manipulation system. For example, using techniques presented in this chapter, one could design a system that locates objects on a conveyor belt, and determines the positions and orientations of those objects. This information could then be used in conjunction with the inverse kinematic solution for the robot, along with various coordinate transformations, to command the robot to grasp these objects. We begin by examining the geometry of the image formation process. This will provide us with the fundamental geometric relationships between objects in the world and their pro- jections in an image. We then describe a calibration process that can be used to determine the values for the various camera parameters that appear in these relationships. We then consider image segmentation, the problem of dividing the image into distinct regions that correspond to the background and to objects in the scene. When there are multiple objects in the scene, it is often useful to deal with them individually; therefore, we next present an approach to component labelling. Finally, we describe how to compute the positions and orientations of objects in the image. 6.1 The Geometry of Image Formation A digital image is a two-dimensional array of pixels that is formed by focusing light onto a two-dimensional array of sensing elements. A lens with focal length λ is used to focus the light onto the sensing array, which is often composed of CCD (charge-coupled device) sensors. The lens and sensing array are packaged together in a camera, which is connected to 131 132 CHAPTER 6. COMPUTER VISION a digitizer or frame grabber. In the case of analog cameras, the digitizer converts the analog video signal that is output by the camera into discrete values that are then transferred to the pixel array by the frame grabber. In the case of digital cameras, a frame grabber merely transfers the digital data from the camera to the pixel array. Associated with each pixel in the digital image is a gray level value, typically between 0 and 255, which encodes the intensity of the light incident on the corresponding sensing element. In robotics applications, it is often suﬃcient to consider only the geometric aspects of image formation. Therefore in this section we will describe only the geometry of the image formation process. We will not deal with the photometric aspects of image formation (e.g., we will not address issues related to depth of ﬁeld, lens models, or radiometry). We will begin the section by assigning a coordinate frame to the imaging system. We then discuss the popular pinhole model of image formation, and derive the corresponding equations that relate the coordinates of a point in the world to its image coordinates. Finally, we describe camera calibration, the process by which all of the relevant parameters associated with the imaging process can be determined. 6.1.1 The Camera Coordinate Frame In order to simplify many of the equations of this chapter, it often will be useful to express the coordinates of objects relative to a camera centered coordinate frame. For this purpose, we deﬁne the camera coordinate frame as follows. Deﬁne the image plane, π, as the plane that contains the sensing array. The axes xc and yc form a basis for the image plane, and are typically taken to be parallel to the horizontal and vertical axes (respectively) of the image. The axis zc is perpendicular to the image plane and aligned with the optic axis of the lens (i.e., it passes through the focal center of the lens). The origin of the camera frame is located at a distance λ behind the image plane. This point is also referred to as the center of projection. The point at which the optical axis intersects the image plane is known as the principal point. This coordinate frame is illustrated in Figure 6.1. With this assignment of the camera frame, any point that is contained in the image plane will have coordinates (u, v, λ). Thus, we can use (u, v) to parameterize the image plane, and we will refer to (u, v) as image plane coordinates. 6.1.2 Perspective Projection The image formation process is often modeled by the pinhole lens approximation. With this approximation, the lens is considered to be an ideal pinhole, and the pinhole is located at the focal center of the lens1. Light rays pass through this pinhole, and intersect the image plane. Let P be a point in the world with coordinates x, y, z (relative to the camera frame). Let p denote the projection of P onto the image plane with coordinates (u, v, λ). Under the 1Note that in our mathematical model, illustrated in Figure 6.1, we have placed the pinhole behind the image plane in order to simplify the model. 6.1. THE GEOMETRY OF IMAGE FORMATION 133 Z Y object X Image plane image center of projection (u,v) P = (x,y,z) l Figure 6.1: Camera coordinate frame. pinhole assumption, P , p and the origin of the camera frame will be collinear. This can is illustrated in Figure 6.1. Thus, for some unknown positive k we have k   x y z   =   u v λ   (6.1) which can be rewritten as the system of equations: kx = u, (6.2) ky = v, (6.3) kz = λ. (6.4) This gives k = λ/z, which can be substituted into (6.2) and (6.3) to obtain u = λ x z , v = λ y z . (6.5) These are the well-known equations for perspective projection. 6.1.3 The Image Plane and the Sensor Array As described above, the image is a discrete array of gray level values. We will denote the row and column indices for a pixel by the coordinates (r, c). In order to relate digital images to the 3D world, we must determine the relationship between the image plane coordinates, (u, v), and indices into the pixel array of pixels, (r, c). We typically deﬁne the origin of this pixel array to be located at a corner of the image (rather than the center of the image). Let the pixel array coordinates of the pixel that 134 CHAPTER 6. COMPUTER VISION contains the principal point be given by (or, oc). In general, the sensing elements in the camera will not be of unit size, nor will they necessarily be square. Denote the sx and sy the horizontal and vertical dimensions (respectively) of a pixel. Finally, it is often the case that the horizontal and vertical axes of the pixel array coordinate system point in opposite directions from the horizontal and vertical axes of the camera coordinate frame2. Combining these, we obtain the following relationship between image plane coordinates and pixel array coordinates, − u sx = (r − or), − v sy = (c − oc). (6.6) which gives, u = −sx(r − or), v = −sy(c − oc). (6.7) Note that the coordinates (r, c) will be integers, since they are the discrete indices into an array that is stored in computer memory. Therefore, it is not possible to obtain the exact image plane coordinates for a point from the (r, c) coordinates. 6.2 Camera Calibration The objective of camera calibration is to determine all of the parameters that are necessary to predict the image pixel coordinates (r, c) of the projection of a point in the camera’s ﬁeld of view, given that the coordinates of that point with respect to the world coordinate frame are know. In other words, given the coordinates of P relative to the world coordinate frame, after we have calibrated the camera we will be able to predict (r, c), the image pixel coordinates for the projection of this point. 6.2.1 Extrinsic Camera Parameters To this point, in our derivations of the equations for perspective projection, we have dealt only with coordinates expressed relative to the camera frame. In typical robotics applica- tions, tasks will be expressed in terms of the world coordinate frame, and it will therefore be necessary to perform coordinate transformations. If we know the position and orientation of the camera frame relative to the world coordinate frame we have x w = Rw c x c + Ow c (6.8) or, if we know x w and wish to solve for x c, x c = Rc w(x w − Ow c ) (6.9) In the remainder of this section, to simplify notation we will deﬁne R = Rc w, T = −Rc wOw c . (6.10) 2This is an artifact of our choice to place the center of projection behind the image plane. The directions of the pixel array axes may vary, depending on the frame grabber. 6.2. CAMERA CALIBRATION 135 Thus, x c = Rx w + T (6.11) Cameras are typically mounted on tripods, or on mechanical positioning units. In the latter case, a popular conﬁguration is the pan/tilt head. A pan/tilt head has two degrees of freedom: a rotation about the world z axis and a rotation about the pan/tilt head’s x axis. These two degrees of freedom are analogous to the those of a human head, which can easily look up or down, and can turn from side to side. In this case, the rotation matrix R is given by R = Rz,θRx,α, (6.12) where θ is the pan angle and α is the tilt angle. More precisely, θ is the angle between the world x-axis and the camera x-axis, about the world z-axis, while α is the angle between the world z-axis and the camera z-axis, about the camera x-axis. 6.2.2 Intrinsic Camera Parameters Using the pinhole model, we obtained the following equations that map the coordinates of a point expressed with respect to the camera frame to the corresponding pixel coordinates: r = − u sx + or, c = − v sy + oc, u = λ x z v = λ y z . (6.13) These equations can be combined to give r = − λ sx x z + or, c = − λ sy y z + oc, (6.14) Thus, once we know the values of the parameters λ, sx, or, sy, oc we can determine (r, c) from (x, y, z), where (x, y, z) are coordinates relative to the camera frame. In fact, we don’t need to know all of λ, sx, sy; it is suﬃcient to know the ratios fx = − λ sx fy = − λ sy . (6.15) These parameters, fx, or, fy, oc are known as the intrinsic parameters of the camera. They are constant for a given camera, and do not change when the camera moves. 6.2.3 Determining the Camera Parameters The task of camera calibration is to determine the intrinsic and extrinsic parameters of the camera. We will proceed by ﬁrst determining the parameters associated with the image center, and then solving for the remaining parameters. Of all the camera parameters, or, oc (the image pixel coordinates of the principal point) are the easiest to determine. This can be done by using the idea of vanishing points. Although a full treatment of vanishing points is beyond the scope of this text, the idea is simple: a set of parallel lines in the world will project onto image lines that intersect at a 136 CHAPTER 6. COMPUTER VISION single point, and this intersection point is known as a vanishing point. The vanishing points for three mutually orthogonal sets of lines in the world will deﬁne a triangle in the image. The orthocenter of this triangle (i.e., the point at which the three altitudes intersect) is the image principal point (a proof of this is beyond the scope of this text). Thus, a simple way to compute the principal point is to position a cube in the workspace, ﬁnd the edges of the cube in the image (this will produce the three sets of mutually orthogonal parallel lines), compute the intersections of the image lines that correspond to each set of parallel lines in the world, and determine the orthocenter for the resulting triangle. Once we know the principal point, we proceed to determine the remaining camera param- eters. This is done by constructing a linear system of equations in terms of the known coordi- nates of points in the world and the pixel coordinates of their projections in the image. The unknowns in this system are the camera parameters. Thus, the ﬁrst step in this stage of cali- bration is to acquire a data set of the form r1, c1, x1, y1, z1, r2, c2, x2, y2, z2, · · · rN , cN , xN , yN , zN , in which ri, ci are the image pixel coordinates of the projection of a point in the world with coordinates xi, yi, zi relative to the world coordinate frame. This acquisition is often done manually, e.g., by having a robot move a small bright light to known x, y, z coordinates in the world, and then hand selecting the corresponding image point. Once we have acquired the data set, we proceed to set up the linear system of equations. The extrinsic parameters of the camera are given by R =   r11 r12 r13 r21 r22 r23 r31 r32 r33   , T =   Tx Ty Tz   . (6.16) With respect to the camera frame, the coordinates of a point in the world are thus given by x c = r11x + r12y + r13z + Tx (6.17) yc = r21x + r22y + r23z + Ty (6.18) zc = r31x + r32y + r33z + Tz. (6.19) Combining this with (6.14) we obtain r − or = −fx xc zc = −fx r11x + r12y + r13z + Tx r31x + r32y + r33z + Tz (6.20) c − oc = −fy yc zc = −fy r21x + r22y + r23z + Ty r31x + r32y + r33z + Tz . (6.21) Since we know the coordinates of the principal point, we an simplify these equations by using the simple coordinate transformation r ← r − or, c ← c − oc. (6.22) We now write the two transformed projection equations as functions of the unknown vari- ables: rij, Tx, Ty, Tz, fx, fy. This is done by solving each of these equations for zc, and 6.2. CAMERA CALIBRATION 137 setting the resulting equations to be equal to one another. In particular, for the data points ri, ci, xi, yi, zi we have rify(r21xi + r22yi + r23zi + Ty) = cifx(r11xi + r12yi + r13zi + Tx). (6.23) We deﬁne α = fx/fy and rewrite this as: rir21xi + rir22yi + rir23zi + riTy − αcir11xi − αcir12yi − αcir13zi − αciTx = 0. (6.24) We can combine the N such equations into the matrix equation              r1x1 r1y1 r1z1 r1 −c1x1 −c1y1 −c1z1 −c1 r2x2 r2y2 r2z2 r2 −c2x2 −c2y2 −c2z2 −c2 ... ... ... ... ... ... ... ... rN xN rN yN rN zN rN −cN xN −cN yN −cN zN −cN                          r21 r22 r23 Ty αr11 αr12 αr13 αTx             = 0 (6.25) This is an equation of the form Ax = 0. As such, if ¯x = [¯x1, · · · , ¯x8]T is a solution, for (6.25) we only know that this solution is some scalar multiple of the desired solution, x, i.e., ¯x = k[r21, r22, r23, Ty, αr11, αr12, αr13, αTx] T , (6.26) in which k is an unknown scale factor. In order to solve for the true values of the camera parameters, we can exploit constraints that arise from the fact that R is a rotation matrix. In particular, (¯x 2 1 + ¯x 2 2 + ¯x 2 3) 1 2 = (k2(r2 21 + r2 22 + r2 23)) 1 2 = |k|, (6.27) and likewise (¯x 2 5 + ¯x 2 6 + ¯x 2 7) 1 2 = (α2k2(r2 21 + r2 22 + r2 23)) 1 2 = α|k| (6.28) (note that by deﬁnition, α > 0). Our next task is to determine the sign of k. Using equations (6.14) we see that r ×xc < 0 (recall that we have used the coordinate transformation r ← r−or). Therefore, to determine the sign of k, we ﬁrst assume that k > 0. If r(r11x + r12y + r13z + Tx) < 0, then we know that we have made the right choice and k > 0; otherwise, we know that k < 0. At this point, we know the values for k, α, r21, r22, r23, r11, r12, r13, Tx, TY , and all that remains is to determine Tz, fx, fy. Since α = fx/fy, we need only determine Tz and fx. Returning again to the projection equations, we can write r = −fx xc zc = −fx r11x + r12y + r13z + Tx r31x + r32y + r33z + Tz (6.29) 138 CHAPTER 6. COMPUTER VISION Using an approach similar to that used above to solve for the ﬁrst eight parameters, we can write this as the linear system r(r31x + r32y + r33z + Tz) = −fx(r11x + r12y + r13z + Tx) (6.30) which can easily be solved for TZ and fx. 6.3 Segmentation by Thresholding Segmentation is the process by which an image is divided into meaningful components. Segmentation has been the topic of computer vision research since its earliest days, and the approaches to segmentation are far too numerous to survey here. These approaches are sometimes concerned with ﬁnding features in an image (e.g., edges), and sometimes con- cerned with partitioning the image into homogeneous regions (region-based segmentation). In many practical applications, the goal of segmentation is merely to divide the image into two regions: one region that corresponds to an object in the scene, and one region that corresponds to the background. In many industrial applications, this segmentation can be accomplished by a straight-forward thresholding approach. Pixels whose gray level is greater than the threshold are considered to belong to the object, and pixels whose gray level is less than or equal to the threshold are considered to belong to the background. In this section we will describe an algorithm that automatically selects a threshold. This basic idea behind the algorithm is that the pixels should be divided into two groups (background and object), and that the intensities of the pixels in a particular group should all be fairly similar. To quantify this idea, we will use some standard techniques from statistics. Thus, we begin the section with a quick review of the necessary concepts from statistics and then proceed to describe the threshold selection algorithm. 6.3.1 A Brief Statistics Review Many approaches to segmentation exploit statistical information contained in the image. In this section, we brieﬂy review some of the more useful statistical concepts that are used by segmentation algorithms. The basic premise for most of these statistical concepts is that the gray level value associated with a pixel in an image is a random variable that takes on values in the set {0, 1, · · · N − 1}. Let P (z) denote the probability that a pixel has gray level value z. In general, we will not know this probability, but we can estimate it with the use of a histogram. A histogram is an array, H, that encodes the number of occurrences of each gray level value. In particular, the entry H[z] is the number of times gray level value z occurs in the image. Thus, 0 ≤ H[z] ≤ Nrows × Ncols for all z. An algorithm to compute the histogram for an image is shown in ﬁgure 6.2. Given the histogram for the image, we estimate the probability that a pixel will have gray level z by P (z) = H[z] Nrows × Ncols . (6.31) 6.3. SEGMENTATION BY THRESHOLDING 139 For i = 0 to N − 1 H[i] ← 0 For r = 0 to Nrows − 1 For c = 0 to Ncols − 1 Index ← Image(r, c) H[Index] ← H[Index] + 1 Figure 6.2: Pseudo-code to compute an image histogram. Thus, the image histogram is a scaled version of our approximation of P . Given P , we can compute the average, or mean value of the gray level values in the image. We denote the mean by µ, and compute it by µ = N −1∑ z=0 zP (z). (6.32) In many applications, the image will consist of one or more objects against some back- ground. In such applications, it is often useful to compute the mean for each object in the image, and also for the background. This computation can be eﬀected by constructing indi- vidual histogram arrays for each object, and for the background, in the image. If we denote by Hi the histogram for the ith object in the image (where i = 0 denotes the background), the mean for the ith object is given by µi = N −1∑ z=0 z Hi[z] ∑N −1 z=0 Hi[z] , (6.33) which is a straightforward generalization of (6.32). The term Hi[z] ∑N −1 z=0 Hi[z] is in fact an estimate of the probability that a pixel will have gray level value z given that the pixel is a part of object i in the image. For this reason, µi is sometimes called a conditional mean. The mean conveys useful, but very limited information about the distribution of grey level values in an image. For example, if half or the pixels have gray value 127 and the remaining half have gray value 128, the mean will be µ = 127.5. Likewise, if half or the pixels have gray value 255 and the remaining half have gray value 0, the mean will be µ = 127.5. Clearly these two images are very diﬀerent, but this diﬀerence is not reﬂected by the mean. One way to capture this diﬀerence is to compute the the average deviation of gray values from the mean. This average would be small for the ﬁrst example, and large 140 CHAPTER 6. COMPUTER VISION for the second. We could, for example, use the average value of |z − µ|; however, it will be more convenient mathematically to use the square of this value instead. The resulting quantity is known as the variance, which is deﬁned by σ2 = N −1∑ z=0 (z − µ) 2P (z). (6.34) As with the mean, we can also compute the conditional variance, σ2 i for each object in the image σ2 i = N −1∑ z=0 (z − µi) 2 Hi[z] ∑N −1 z=0 Hi[z] . (6.35) 6.3.2 Automatic Threshold Selection We are now prepared to develop an automatic threshold selection algorithm. We will assume that the image consists of an object and a background, and that the background pixels have gray level values less than or equal to some threshold while the object pixels are above the threshold. Thus, for a given threshold value, zt, we divide the image pixels into two groups: those pixels with gray level value z ≤ zt, and those pixels with gray level value z > zt. We can compute the means and variance for each of these groups using the equations of Section 6.3.1. Clearly, the conditional means and variances depend on the choice of zt, since it is the choice of zt that determines which pixels will belong to each of the two groups. The approach that we take in this section is to determine the value for zt that minimizes a function of the variances of these two groups of pixels. In this section, it will be convenient to rewrite the conditional means and variances in terms of the pixels in the two groups. To do this, we deﬁne qi(zt) as the probability that a pixel in the image will belong to group i for a particular choice of threshold, zt. Since all pixels in the background have gray value less than or equal to zt and all pixels in the object have gray value greater than zt, we can deﬁne qi(zt) for i = 0, 1 by q0(zt) = ∑zt z=0 H[z] (Nrows × Ncols) , q1(zt) = ∑N −1 z=zt+1 H[z] (Nrows × Ncols) . (6.36) We now rewrite (6.33) as µi = N −1∑ z=0 z Hi[z] ∑N −1 z=0 Hi[z] = N −1∑ z=0 z Hi[z]/(Nrows × Ncols) ∑N −1 z=0 Hi[z]/(Nrows × Ncols) Using again the fact that the two pixel groups are deﬁned by the threshold zt, we have H0[z] (Nrows × Ncols) = P (z) q0(zt) , z ≤ zt and H1[z] (Nrows × Ncols) = P (z) q1(zt) , z > zt. (6.37) 6.3. SEGMENTATION BY THRESHOLDING 141 Thus, we can write the conditional means for the two groups as µ0(zt) = zt∑ z=0 z P (z) q0(zt) , µ1(zt) = N −1∑ z=zt+1 z P (z) q1(zt) . (6.38) Similarly, we can write the equations for the conditional variances by σ2 0(zt) = zt∑ z=0(z − µ0(zt)) 2 P (z) q0(zt) , σ2 1(zt) = N∑ z=zt+1(z − µ1(zt)) 2 P (z) q1(zt) . (6.39) We now turn to the selection of zt. If nothing is known about the true values of µi or σ2 i , how can we determine the optimal value of zt? To answer this question, recall that the variance is a measure of the average deviation of pixel intensities from the mean. Thus, if we make a good choice for zt, we would expect that the variances σ2 i (zt) would be small. This reﬂects the assumption that pixels belonging to the object will be clustered closely about µ1, pixels belonging to the background will be clustered closely about µ0. We could, therefore, select the value of zt that minimizes the sum of these two variances. However, it is unlikely that the object and background will occupy the same number of pixels in the image; merely adding the variances gives both regions equal importance. A more reasonable approach is to weight the two variances by the probability that a pixel will belong to the corresponding region, σ2 w(zt) = q0(zt)σ2 0(zt) + q1(zt)σ2 1(zt). (6.40) The value σ2 w is known as the within-group variance. The approach that we will take is to minimize this within-group variance. At this point we could implement a threshold selection algorithm. The naive approach would be to simply iterate over all possible values of zt and select the one for which σ2 w(zt) is smallest. Such an algorithm performs an enormous amount of calculation, much of which is identical for diﬀerent candidate values of the threshold. For example, most of the calculations required to compute σ2 w(zt) are also required to compute σ2 w(zt + 1); the required summations change only slightly from one iteration to the next. Therefore, we now turn our attention to an eﬃcient algorithm. To develop an eﬃcient algorithm, we take two steps. First, we will derive the between- group variance, σ2 b , which depends on the within-group variance and the variance over the entire image. The between-group variance is a bit simpler to deal with than the within- group variance, and we will show that maximizing the between-group variance is equivalent to minimizing the within-group variance. Then, we will derive a recursive formulation for the between-group variance that lends itself to an eﬃcient implementation. To derive the between-group variance, we begin by expanding the equation for the total variance of the image, and then simplifying and grouping terms. The variance of the gray 142 CHAPTER 6. COMPUTER VISION level values in the image is given by (6.34), which can be rewritten as σ2 = N −1∑ z=0 (z − µ) 2P (z) = zt∑ z=0(z − µ) 2P (z) + N −1∑ z=zt+1(z − µ) 2P (z) = zt∑ z=0(z − µ0 + µ0 − µ) 2P (z) + N −1∑ z=zt+1(z − µ1 + µ1 − µ) 2P (z) = zt∑ z=0[(z − µ0) 2 + 2(z − µ0)(µ0 − µ) + (µ0 − µ) 2]P (z) + N −1∑ z=zt+1[(z − µ1) 2 + 2(z − µ1)(µ1 − µ) + (µ1 − µ) 2]P (z). (6.41) Note that the we have not explicitly noted the dependence on zt here. In the remainder of this section, to simplify notation, we will refer to the group probabilities and conditional means and variances as qi, µi, and σ2 i , without explicitly noting the dependence on zt. This last expression (6.41) can be further simpliﬁed by examining the cross-terms ∑(z − µi)(µi − µ)P (z) = ∑ zµiP (z) − ∑ zµP (z) − ∑ µ 2 i P (z) + ∑ µiµP (z) = µi ∑ zP (z) − µ ∑ zP (z) − µ 2 i ∑ P (z) + µiµ ∑ P (z) = µi(µiqi) − µ(µiqi) − µ 2 i qi + µiµqi = 0, in which the summations are taken for z from 0 to zt for the background pixels (i.e., i = 0) and z from zt + 1 to N − 1 for the object pixels (i.e., i = 1). Therefore, we can simplify (6.41) to obtain σ2 = zt∑ z=0[(z − µ0) 2 + (µ0 − µ) 2]P (z) + N −1∑ z=zt+1[(z − µ1) 2 + (µ1 − µ) 2]P (z) = q0σ2 0 + q0(µ0 − µ) 2 + q1σ2 1 + q1(µ1 − µ) 2 = {q0σ2 0 + q1σ2 1} + {q0(µ0 − µ) 2 + q1(µ1 − µ) 2} = σ2 w + σ2 b (6.42) in which σ2 b = q0(µ0 − µ) 2 + q1(µ1 − µ) 2. (6.43) Since σ2 does not depend on the threshold value (i.e., it is constant for a speciﬁc image), minimizing σ2 w is equivalent to maximizing σ2 b . This is preferable because σ2 b is a function 6.3. SEGMENTATION BY THRESHOLDING 143 only of the qi and µi, and is thus simpler to compute than σ2 w, which depends also on the σ2 i . In fact, by expanding the squares in (6.43), using the facts that q1 = 1 − q0 and µ = q1µ0 + q1µ1, we obtain σ2 b = q0(1 − q0)(µ0 − µ1) 2. (6.44) The simplest algorithm to maximize σ2 b is to iterate over all possible threshold values, and select the one that maximizes σ2 b . However, as discussed above, such an algorithm performs many redundant calculations, since most of the calculations required to compute σ2 b (zt) are also required to compute σ2 b (zt + 1). Therefore, we now turn our attention to an eﬃcient algorithm that maximizes σ2 b (zt). The basic idea for the eﬃcient algorithm is to re-use the computations needed for σ2 b (zt) when computing σ2 b (zt + 1). In particular, we will derive expressions for the necessary terms at iteration zt + 1 in terms of expressions that were computed at iteration zt. We begin with the group probabilities, and determine the recursive expression for q0 as q0(zt + 1) = zt+1∑ z=0 P (z) = P (zt + 1) + zt∑ z=0 P (z) = P (zt + 1) + q0(zt). (6.45) In this expression, P (zt + 1) can be obtained directly from the histogram array, and q0(zt) is directly available because it was computed on the previous iteration of the algorithm. Thus, given the results from iteration zt, very little computation is required to compute the value for q0 at iteration zt + 1. For the conditional mean µ0(zt) we have µ0(zt + 1) = zt+1∑ z=0 z P (z) q0(zt + 1) (6.46) = (zt + 1)P (zt + 1) q0(zt + 1) + zt∑ z=0 z P (z) q0(zt + 1) (6.47) = (zt + 1)P (zt + 1) q0(zt + 1) + q0(zt) q0(zt + 1) zt∑ z=0 z P (z) q0(zt) (6.48) = (zt + 1)P (zt + 1) q0(zt + 1) + q0(zt) q0(zt + 1) µ0(zt) (6.49) Again, all of the quantities in this expression are available either from the histogram, or as the results of calculations performed at iteration zt of the algorithm. To compute µ1(zt + 1), we use the relationship µ = q0µ0 + q1µ1, which can be easily obtained using (6.32) and (6.38). Thus, we have µ1(zt + 1) = µ − q0(zt + 1)µ0(zt + 1) q1(zt + 1) = µ − q0(zt + 1)µ0(zt + 1) 1 − q0(zt + 1) . (6.50) 144 CHAPTER 6. COMPUTER VISION (a) (b) Figure 6.3: (a) A 300 × 300 pixel image with 256 gray levels. (b) Thresholded version of the image in (a). We are now equipped to construct a highly eﬃcient algorithm that automatically selects a threshold value that minimizes the within-group variance. This algorithm simply iterates from 0 to N − 1 (where N is the total number of gray level values), computing q0, µ0, µ1 and σ2 b at each iteration using the recursive formulations given in (6.45), (6.49), (6.50) and (6.44). The algorithm returns the value of zt for which σ2 b is largest. Figure ?? shows a grey level image and the binary, thresholded image that results from the application of this algorithm. 6.4 Connected Components It is often the case that multiple objects will be present in a single image. When this occurs, after thresholding there will be multiple connected components with gray level values that are above the threshold. In this section, we will ﬁrst make precise the notion of a connected component, and then describe an algorithm that assigns a unique label to each connected component, i.e., all pixels within a single connected component have the same label, but pixels in diﬀerent connected components have diﬀerent labels. In order to deﬁne what is meant by a connected component, it is ﬁrst necessary to deﬁne what is meant by connectivity. For our purposes, it is suﬃcient to say that a pixel, A, with image pixel coordinates (r, c) is adjacent to four pixels, those with image pixel coordinates (r − 1, c), (r + 1, c), (r, c + 1), and (r, c − 1). In other words, each image pixel A (except those at the edges of the image) has four neighbors: the pixel directly above, directly below, directly to the right and directly to the left of pixel A. This relationship is sometimes referred to as 4-connectivity, and we say that two pixels are 4-connected if they are adjacent by this deﬁnition. If we expand the deﬁnition of adjacency to include those pixels that are diagonally adjacent (i.e., the pixels with coordinates (r−1, c−1), (r−1, c+1), 6.4. CONNECTED COMPONENTS 145 (r + 1, c − 1), and (r + 1, c + 1)), then we say that adjacent pixels are 8-connected. In this text, we will consider only the case of 4-connectivity. A connected component is a collection of pixels, S, such that for any two pixels, say P and P ′, in S, there is a 4-connected path between them and this path is contained in S. Intuitively, this deﬁnition means that it is possible to move from P to P ′ by “taking steps” only to adjacent pixels without ever leaving the region S. The purpose of a component labeling algorithm is to assign a unique label to each such S. There are many component labeling algorithms that have been developed over the years. Here, we describe a simple algorithm that requires two passes over the image. This algorithm performs two raster scans of the image (note: a raster scan visits each pixel in the image by traversing from left to right, top to bottom, in the same way that one reads a page of text). On the ﬁrst raster scan, when an object pixel P , (i.e., a pixel whose gray level is above the threshold value), is encountered, its previously visited neighbors (i.e., the pixel immediately above and the pixel immediately to the left of P ) are examined, and if they have gray value that is below the threshold (i.e., they are background pixels), a new label is given to P . This is done by using a global counter that is initialized to zero, and is incremented each time a new label is needed. If either of these two neighbors have already received labels, then P is given the smaller of these, and in the case when both of the neighbors have received labels, an equivalence is noted between those two labels. For example, in Figure 6.4, after the ﬁrst raster scan labels (2,3,4) are noted as equivalent. In the second raster scan, each pixel’s label is replaced by the smallest label to which it is equivalent. Thus, in the example of Figure 6.4, at the end of the second raster scan labels 3 and 4 have been replaced by the label 2. After this algorithm has assigned labels to the components in the image, it is not neces- sarily the case that the labels will be the consecutive integers (1, 2, · · · ). Therefore, a second stage of processing is sometimes used to relabel the components to achieve this. In other cases, it is desirable to give each component a label that is very diﬀerent from the labels of the other components. For example, if the component labelled image is to be displayed, it is useful to increase the contrast, so that distinct components will actually appear distinct in the image (a component with the label 2 will appear almost indistinguishable from a com- ponent with label 3 if the component labels are used as pixel gray values in the displayed component labelled image). The results of applying this process to the image in Figure 6.3 are shown in Figure 6.5. When there are multiple connected object components, it is often useful to process each component individually. For example, we might like to compute the sizes of the various components. For this purpose, it is useful to introduce the indicator function for a component. The indicator function for component i, denoted by Ii, is a function that takes on the value 1 for pixels that are contained in component i, and the value 0 for all other pixels: Ii(r, c) = { 1 : pixel r, c is contained in component i 0 : otherwise . (6.51) We will make use of the indicator function below, when we discuss computing statistics 146 CHAPTER 6. COMPUTER VISION 0 0 0 0 0 0 0 0 0 0 0 X X X 0 0 0 0 0 0 0 X X X 0 0 0 0 0 0 0 X X X 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 X 0 0 X X 0 0 0 0 0 X 0 0 X X 0 0 0 0 0 X X X X X 0 0 X X X X X X X X 0 0 X X X X X X X X 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 3 3 0 0 0 0 0 2 0 0 3 3 0 0 0 0 0 2 2 2 2 2 0 0 4 4 4 2 2 2 2 2 0 0 4 4 4 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 (a) (b) 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 3 3 0 0 0 0 0 2 0 0 3 3 0 0 0 0 0 2 2 2 X 2 0 0 4 4 4 X 2 2 2 2 0 0 4 4 4 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 2 2 0 0 0 0 0 2 0 0 2 2 0 0 0 0 0 2 2 2 2 2 0 0 2 2 2 2 2 2 2 2 0 0 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 (c) (d) Figure 6.4: The image in (a) is a simple binary image. Background pixels are denoted by 0 and object pixels are denoted by X. Image (b) shows the assigned labels after the ﬁrst raster scan. In image (c), an X denotes those pixels at which an equivalence is noted during the ﬁrst raster scan. Image (d) shows the ﬁnal component labelled image. 6.5. POSITION AND ORIENTATION 147 Figure 6.5: The image of Figure 6.3 after connected components have been labelled. associated with the various objects in the image. 6.5 Position and Orientation The ultimate goal of a robotic system is to manipulate objects in the world. In order to achieve this, it is necessary to know the positions and orientations of the objects that are to be manipulated. In this section, we address the problem of determining the position and orientation of objects in the image. If the camera has been calibrated, it is then possible to use these image position and orientations to infer the 3D positions and orientations of the objects. In general, this problem of inferring the 3D position and orientation from image measurements can be a diﬃcult problem; however, for many cases that are faced by industrial robots we an obtain adequate solutions. For example, when grasping parts from a conveyor belt, the depth, z, is ﬁxed, and the perspective projection equations can be inverted if z is known. We begin the section with a general discussion of moments, since moments will be used in the computation of both position and orientation of objects in the image. 6.5.1 Moments Moments are functions deﬁned on the image that can be used to summarize various aspects of the shape and size of objects in the image. The i, j moment for the kth object, denoted by mij(k), is deﬁned by mij(k) = ∑ r,c ric jIk(r, c). (6.52) From this deﬁnition, it is evident that m00 is merely number of pixels in the object. The order of a moment is deﬁned to be the sum i + j. The ﬁrst order moments are of particular 148 CHAPTER 6. COMPUTER VISION interest when computing the centroid of an object, and they are given by m10(k) = ∑ r,c rIk(r, c), m01(k) = ∑ r,c cIk(r, c). (6.53) It is often useful to compute moments with respect to the object center of mass. By doing so, we obtain characteristics that are invariant with respect to translation of the object. These moments are called central moments. The i, j central moment for the kth object is deﬁned by Cij(k) = ∑ r,c (r − ¯r) i(c − ¯c) jIk(r, c), (6.54) in which (¯r, ¯c) are the coordinates for the center of mass, or centroid, of the object. 6.5.2 The Centroid of an Object It is convenient to deﬁne the position of an object to be the object’s center of mass or centroid. By deﬁnition, the center of mass of an object is that point (¯r, ¯c) such that, if all of the object’s mass were concentrated at (¯r, ¯c) the ﬁrst moments would not change. Thus, we have ∑ r,c ¯riIi(r, c) = ∑ r,c rIi(r, c) ⇒ ¯ri = ∑ r,c rIi(r, c) ∑ r,c Ii(r, c) = m10(i) m00(i) (6.55) ∑ r,c ¯ciIi(r, c) = ∑ r,c cIi(r, c) ⇒ ¯ci = ∑ r,c cIi(r, c) ∑ r,c Ii(r, c) = m01(i) m00(i) . (6.56) Figure 6.6(a) shows the centroids for the connected components of the image of Figure 6.3. 6.5.3 The Orientation of an Object We will deﬁne the orientation of an object in the image to be the orientation of an axis that passes through the object such that the second moment of the object about that axis is minimal. This axis is merely the two-dimensional equivalent of the axis of least inertia. For a given line in the image, the second moment of the object about that line is given by L = ∑ r,c d2(r, c)I(r, c) (6.57) in which d(r, c) is the minimum distance from the pixel with coordinates (r, c) to the line. Our task is to minimize L with respect to all possible lines in the image plane. To do this, we will use the ρ, θ parameterization of lines, and compute the partial derivatives of L with respect to ρ and θ. We ﬁnd the minimum by setting these partial derivatives to zero. 6.5. POSITION AND ORIENTATION 149 (a) (b) Figure 6.6: (a) The image of ﬁgure 6.3 showing the centroids of each component. (b) The image of ﬁgure 6.3 showing the orientation of each component. With the ρ, θ parameterization, a line consists of all those points x, y that satisfy x cos θ + y sin θ − ρ = 0. (6.58) Thus, (cos θ, sin θ) gives the unit normal to the line, and ρ gives the perpendicular distance to the line from the origin. Under this parameterization, the distance from the line to the point with coordinates (r, c) is given by d(r, c) = r cos θ + c sin θ − ρ. (6.59) Thus, our task is to ﬁnd L ⋆ = min ρ,θ ∑ r,c (r cos θ + c sin θ − ρ) 2I(r, c) (6.60) We compute the partial derivative with respect to ρ as d dρ L = d dρ ∑ r,c (r cos θ + c sin θ − ρ) 2I(r, c) (6.61) = −2 ∑ r,c (r cos θ + c sin θ − ρ)I(r, c) (6.62) = −2 cos θ ∑ r,c rI(r, c) − 2 sin θ ∑ r,c cI(r, c) + 2ρ ∑ r,c I(r, c) (6.63) = −2(cos θm10 + sin θm01 − ρm00) (6.64) = −2(m00¯r cos θ + m00¯c sin θ − ρm00) (6.65) = −2m00(¯r cos θ + ¯c sin θ − ρ). (6.66) 150 CHAPTER 6. COMPUTER VISION Now, setting this to zero we obtain ¯r cos θ + ¯c sin θ − ρ = 0. (6.67) But this is just the equation of a line that passes through the point (¯r, ¯c), and therefore we conclude that the inertia is minimized by a line that passes through the center of mass. We can use this knowledge to simplify the remaining computations. In particular, deﬁne the new coordinates (r′, c′) as r′ = r − ¯r, c ′ = c − ¯c. (6.68) The line that minimizes L passes through the point r′ = 0, c′ = 0, and therefore its equation can be written as r′ cos θ + c ′ sin θ = 0. (6.69) Before computing the partial derivative of L (expressed in the new coordinate system) with respect to θ, it is useful to perform some simpliﬁcations. L = ∑ r,c (r′ cos θ + c ′ sin θ) 2I(r, c) (6.70) = cos2 θ ∑ r,c (r′) 2I(r, c) + 2 cos θ sin θ ∑ r,c (r′c ′)I(r, c) + sin 2 θ ∑ r,c (c ′) 2I(r, c) (6.71) = C20 cos2 θ + 2C11 cos θ sin θ + C02 sin 2 θ (6.72) in which the Cij are the central moments given in (6.54). Note that the central moments depend on neither ρ nor θ. The ﬁnal set of simpliﬁcations that we will make all rely on the double angle identities: cos 2θ = 1 2 + 1 2 cos 2θ (6.73) sin2θ = 1 2 − 1 2 cos 2θ (6.74) cosθ sin θ = 1 2 sin 2θ. (6.75) Substituting these into our expression for L we obtain L = C20( 1 2 + 1 2 cos 2θ) + 2C11( 1 2 sin 2θ) + C02( 1 2 − 1 2 cos 2θ) (6.76) = 1 2 (C20 + C02) + 1 2 (C20 − C02) cos 2θ + 1 2 C11 sin 2θ (6.77) It is now easy to compute the partial derivative with respect to θ: d dθ L = d dθ 1 2 (C20 + C02) + 1 2 (C20 − C02) cos 2θ + 1 2 C11 sin 2θ (6.78) = −(C20 − C02) sin 2θ + C11 cos 2θ, (6.79) 6.5. POSITION AND ORIENTATION 151 and we setting this to zero we obtain tan 2θ = C11 C20 − C02 . (6.80) Figure 6.6(b) shows the orientations for the connected components of the image of Figure 6.3. 152 CHAPTER 6. COMPUTER VISION Chapter 7 PATH PLANNING AND COLLISION AVOIDANCE In previous chapters, we have studied the geometry of robot arms, developing solutions for both the forward and inverse kinematics problems. The solutions to these problems depend only on the intrinsic geometry of the robot, and they do not reﬂect any constraints imposed by the workspace in which the robot operates. In particular, they do not take into account the possiblity of collision between the robot and objects in the workspace. In this chapter, we address the problem of planning collision free paths for the robot. We will assume that the initial and ﬁnal conﬁgurations of the robot are speciﬁed, and that the problem is to ﬁnd a collision free path for the robot that connects them. The description of this problem is deceptively simple, yet the path planning problem is among the most diﬃcult problems in computer science. The computational complexity of the best known complete1 path planning algorithm grows exponentially with the number of internal degrees of freedom of the robot. For this reason, for robot systems with more than a few degrees of freedom, complete algorithms are not used in practice. In this chapter, we treat the path planning problem as a search problem. The algorithms we describe are not guaranteed to ﬁnd a solution to all problems, but they are quite eﬀective in a wide range of practical applications. Furthermore, these algorithms are fairly easy to implement, and require only moderate computation time for most problems. We begin in Section 7.1 by introducing the notion of conﬁguration space, and describing how obstacles in the workspace can be mapped into the conﬁguration space. We then introduce path planning methods that use artiﬁcial potential ﬁelds in Sections 7.2 and 7.3. The corresponding algorithms use gradient descent search to ﬁnd a collision-free path to the goal, and, as with all gradient descent methods, these algorithms can become trapped in local minima in the potential ﬁeld. Therefore, in Section 7.4 we describe how random motions can be used to escape local minima. In Section 7.5 we describe another randomized method known as the Probabilistic Roadmap (PRM) method. Finally, since each of these 1An algorithm is said to be complete if it ﬁnds a solution whenever one exists. 153 154 CHAPTER 7. PATH PLANNING AND COLLISION AVOIDANCE methods generates a sequence of conﬁgurations, we describe in Chapter 8 how polynomial splines can be used to generate smooth trajectories from a sequence of conﬁgurations. As in previous chapters, we will restrict our attention in this chapter to the geometric aspects of the problem. In future chapters we will consider the problem of generating motor torques to execute such a trajectory. 7.1 The Conﬁguration Space In Chapter 3, we learned that the forward kinematic map can be used to determine the position and orientation of the end eﬀector frame given the vector of joint variables. Fur- thermore, the Ai matrices can be used to infer the position and orientation of the reference frame for any link of the robot. Since each link of the robot is assumed to be a rigid body, the Ai matrices can therefore be used to infer the position of any point on the robot, given the values of the joint variables. In the path planning literature, a complete speciﬁcation of the location of every point on the robot is referred to as a conﬁguration, and the set of all possible conﬁgurations is referred to as the conﬁguration space. For our purposes, the vector of joint variables, q, provides a convenient representation of a conﬁguration. We will denote the conﬁguration space by Q. For a one link revolute arm, the conﬁguration space is merely the set of orientations of the link, and thus Q = S1, where S1 represents the unit circle. We could also say Q = SO(2). In fact, the choice of S1 or SO(2) is not particularly important, since these two are equivalent representations. In either case, we can parameterize Q by a single parameter, the joint angle θ1. For the two-link planar arm, we have Q = S1 × S1 = T 2, in which T 2 represents the torus, and we can represent a conﬁguration by q = (θ1, θ2). For a Cartesian arm, we have Q = ℜ3, and we can represent a conﬁguration by q = (d1, d2, d3) = (x, y, z). Although we have chosen to represent a conﬁguration by a vector of joint variables, the notion of a conﬁguration is more general than this. For example, as we saw in Chapter 2, for any rigid two-dimensional object, we can specify the location of every point on the object by rigidly attaching a coordinate frame to the object, and then specifying the position and orientation of this frame. Thus, for a rigid object moving in the plane we can represent a conﬁguration by the triple q = (x, y, θ), and the conﬁguration space can be represented by Q = ℜ2 × SO(2). Again, this is merely one possible representation of the conﬁguration space, but it is a convenient one given the representations of position and orientation that we have learned in preceeding chapters. A collision occurs when the robot contacts an obstacle in the workspace. To describe collisions, we introduce some additional notation. We will denote the robot by A, and by A(q) the subset of the workspace that is occupied by the robot at conﬁguration q. We denote by Oi the obstacles in the workspace, and by W the workspace (i.e., the Cartesian space in which the robot moves). To plan a collision free path, we must ensure that the robot never reaches a conﬁguration q that causes it to make contact with an obstacle in the workspace. The set of conﬁgurations for which the robot collides with an obstacle is referred to as the conﬁguration space obstacle, and it is deﬁned by 7.1. THE CONFIGURATION SPACE 155 QO = {q ∈ Q | A(q) ∩ O ̸= ∅}. Here, we deﬁne O = ∪Oi. The set of collision-free conﬁgurations, referred to as the free conﬁguration space, is then simply Qfree = Q \\ QO. Example 7.1 A Rigid Body that Translates in the Plane. b2b3 V O 4 V O 3 a3 V A 2 a2 a1 V A 1 V A 3 b1b4 V O 1 V O 2 (a) (b) Figure 7.1: (a) a rigid body, A, in a workspace containing a single rectangular obstacle, O, (b) illustration of the algorithm to construct QO, with the boundary of QO shown as the dashed line. Consider a simple gantry robot with two prismatic joints and forward kinematics given by x = d1, y = d2. For this case, the robot’s conﬁguration space is Q = ℜ2, so it is particularly easy to visualize both the conﬁguration space and the conﬁguration space obstacle region. If there is only one obstacle in the workspace and both the robot end-eﬀector and the obstacle are convex polygons, it is a simple matter to compute the conﬁguration space obstacle region, QO (we assume here that the arm itself is positioned above the workspace, so that the only possible collisions are between the end-eﬀector and obstacles the obstacle). Let V A i denote the vector that is normal to the ith edge of the robot and V O i denote the vector that is normal to the ith edge of the obstacle. Deﬁne ai to be the vector from the origin of the robot’s coordinate frame to the ith vertex of the robot and bj to be the vector from the origin of the world coordinate frame to the jth vertex of the obstacle. An example is shown in Figure 7.1(a). The vertices of QO can be determined as follows. • For each pair V O j and V O j−1, if V A i points between −V O j and −V O j−1 then add to QO the vertices bj − ai and bj − ai+1. 156 CHAPTER 7. PATH PLANNING AND COLLISION AVOIDANCE (a) (b) Figure 7.2: (a) A two-link planar arm and a single polygonal obstacle. (b) The correspond- ing conﬁguration space obstacle region. • For each pair V A i and V A i−1, if V O j points between −V A i and −V A i−1 then add to QO the vertices bj − ai and bj+1 − ai. This is illustrated in Figure 7.1(b). Note that this algorithm essentially places the robot at all positions where vertex-vertex contact between robot and obstacle are possible. The origin of the robot’s local coordinate frame at each such conﬁguration deﬁnes a vertex of QO. The polygon deﬁned by these vertices is QO. If there are multiple convex obstacles Oi, then the conﬁguration space obstacle region is merely the union of the obstacle regions QOi, for the individual obstacles. For a nonconvex obstacle, the conﬁguration space obstacle region can be computed by ﬁrst decomposing the nonconvex obstacle into convex pieces, Oi, computing the C-space obstacle region, QOi for each piece, and ﬁnally, computing the union of the QOi. ⋄ Example 7.2 A Two Link Planar Arm. For robots with revolute joints, computation of QO is more diﬃcult. Consider a two- link planar arm in a workspace containing a single obstacle as shown in Figure 7.2(a). The conﬁguration space obstacle region is illustrated in 7.2(b). The horizontal axis in 7.2(b) corresponds to θ1, and the vertical axis to θ2. For values of θ1 very near π/2, the ﬁrst link of the arm collides with the obstacle. Further, when the ﬁrst link is near the obstacle (θ1 near π/2), for some values of θ2 the second link of the arm collides with the obstacle. The region QO shown in 7.2(b) was computed using a discrete grid on the conﬁguration space. For each cell in the grid, a collision test was performed, and the cell was shaded when a 7.2. PATH PLANNING USING CONFIGURATION SPACE POTENTIAL FIELDS 157 collision occured. Thus, this is only an approximate representation of QO. ⋄ Computing QO for the two-dimensional case of Q = ℜ2 and polygonal obstacles is straightforward, but, as can be seen from the two-link planar arm example, computing QO becomes diﬃcult for even moderately complex conﬁguration spaces. In the general case (e.g., articulated arms or rigid bodies that can both translate and rotate), the problem of computing a representation of the conﬁguration space obstacle region is intractable. One of the reasons for this complexity is that the size of the representation of the conﬁguration space tends to grow exponentially with the number of degrees of freedom. This is easy to understand intuitively by considering the number of n-dimensional unit cubes needed to ﬁll a space of size k. For the one dimensional case, k unit intervals will cover the space. For the two-dimensional case, k2 squares are required. For the three-dimensional case, k3 cubes are required, and so on. Therefore, in this chapter we will develop methods that avoid the construction of an explicit representation of Qfree. The path planning problem is to ﬁnd a path from an initial conﬁguration qinit to a ﬁnal conﬁguration qﬁnal, such that the robot does not collide with any obstacle as it traverses the path. More formally, A collision-free path from qinit to qﬁnal is a continuous map, τ : [0, 1] → Qfree, with τ (0) = qinit and τ (1) = qﬁnal. We will develop path planning methods that compute a sequence of discrete conﬁgurations (set points) in the conﬁguration space. In Chapter 8 we will show how smooth trajectories can be generated from such a sequence. 7.2 Path Planning Using Conﬁguration Space Potential Fields As mentioned above, it is not feasible to build an explicit representation of Qfree. An alternative is to develop a search algorithm that incrementally explores Qfree while searching for a path. Such a search algorithm requires a strategy for exploring Qfree, and one of the most popular is to use an artiﬁcial potential ﬁeld to guide the search. In this section, we will introduce artiﬁcial potential ﬁeld methods. Here we describe how the potential ﬁeld can be constructed directly on the conﬁguration space of the robot. However, as will become clear, computing the gradient of such a ﬁeld is not feasible in general, so in Section 7.3 we will develop an alternative, in which the potential ﬁeld is ﬁrst constructed on the workspace, and then its eﬀects are mapped to the conﬁguration space. The basic idea behind the potential ﬁeld approaches is as follows. The robot is treated as a point particle in the conﬁguration space, under the inﬂuence of an artiﬁcial potential ﬁeld U . The ﬁeld U is constructed so that the robot is attracted to the ﬁnal conﬁguration, qﬁnal, while being repelled from the boundaries of QO. If U is constructed appropriately, there will be a single global minimum of U at qﬁnal, and no local minima. Unfortunately, as we will discuss below, it is often diﬃcult to construct such a ﬁeld. In general, the ﬁeld U is an additive ﬁeld consisting of one component that attracts the 158 CHAPTER 7. PATH PLANNING AND COLLISION AVOIDANCE robot to qﬁnal and a second component that repels the robot from the boundary of QO, U (q) = Uatt(q) + Urep(q). (7.1) Given this formulation, path planning can be treated as an optimization problem, i.e., ﬁnd the global minimum in U , starting from initial conﬁguration qinit. One of the easiest algorithms to solve this problem is gradient descent. In this case, the negative gradient of U can be considered as a force acting on the robot (in conﬁguration space), F (q) = −∇U (q) = −∇Uatt(q) − ∇Urep(q). (7.2) In the remainder of this section, we will describe typical choices for the attractive and repulsive potential ﬁelds, and a gradient descent algorithm that can be used to plan paths in this ﬁeld. 7.2.1 The Attractive Field There are several criteria that the potential ﬁeld Uatt should satisfy. First, Uatt should be monotonically increasing with distance from qﬁnal. The simplest choice for such a ﬁeld is a ﬁeld that grows linearly with the distance from qﬁnal, a so-called conic well potential. However, the gradient of such a ﬁeld has unit magnitude everywhere but the origin, where it is zero. This can lead to stability problems, since there is a discontinuity in the attractive force at the origin. We prefer a ﬁeld that is continuously diﬀerentiable, such that the attractive force decreases as the robot approaches qﬁnal. The simplest such ﬁeld is a ﬁeld that grows quadratically with the distance to qﬁnal. Let ρf (q) be the Euclidean distance between q and qﬁnal, i.e., ρf (q) = ||q − qﬁnal||. Then we can deﬁne the quadratic ﬁeld by Uatt(q) = 1 2 ζρ2 f (q), (7.3) in which ζ is a parameter used to scale the eﬀects of the attractive potential. This ﬁeld is sometimes referred to as a parabolic well. For q = (q1, · · · qn)T , the gradient of Uatt is given by ∇Uatt(q) = ∇ 1 2 ζρ2 f (q) (7.4) = ∇ 1 2 ζ||q − qﬁnal|| 2 (7.5) = 1 2 ζ∇ ∑(qi − qi ﬁnal) 2 (7.6) = ζ(q1 − q1 ﬁnal, · · · , qn − qn ﬁnal) T (7.7) = ζ(q − qﬁnal). (7.8) Here, (7.7) follows since ∂ ∂qj ∑ i (qi − qi ﬁnal) 2 = 2(qj − qj ﬁnal). 7.2. PATH PLANNING USING CONFIGURATION SPACE POTENTIAL FIELDS 159 So, for the parabolic well, the attractve force, Fatt(q) = −∇Uatt(q) is a vector directed toward qﬁnal with magnitude linearly related to the distance from q to qﬁnal. Note that while Fatt(q) converges linearly to zero as q approaches qﬁnal (which is a desirable property), it grows without bound as q moves away from qﬁnal. If qinit is very far from qﬁnal, this may produce an attractive force that is too large. For this reason, we may choose to combine the quadratic and conic potentials so that the conic potential attracts the robot when it is very distant from qﬁnal and the quadratic potential attracts the robot when it is near qﬁnal. Of course it is necessary that the gradient be deﬁned at the boundary between the conic and quadratic portions. Such a ﬁeld can be deﬁned by Uatt(q) =    1 2 ζρ2 f (q) : ρf (q) ≤ d dζρf (q) − 1 2 ζd2 : ρf (q) > d . (7.9) and in this case we have Fatt(q) = −∇Uatt(q) =    −ζ(q − qﬁnal) : ρf (q) ≤ d − dζ(q − qﬁnal) ρf (q) : ρf (q) > d . (7.10) The gradient is well deﬁned at the boundary of the two ﬁelds since at the boundary d = ρf (q), and the gradient of the quadratic potential is equal to the gradient of the conic potential, Fatt(q) = −ζ(q − qﬁnal). 7.2.2 The Repulsive ﬁeld There are several criteria that the repulsive ﬁeld should satisfy. It should repel the robot from obstacles, never allowing the robot to collide with an obstacle, and, when the robot is far away from an obstacle, that obstacle should exert little or no inﬂuence on the motion of the robot. One way to achieve this is to deﬁne a potential that goes to inﬁnity at obstacle boundaries, and drops to zero at a certain distance from the obstacle. If we deﬁne ρ0 to be the distance of inﬂuence of an obstace (i.e., an obstacle will not repel the robot if the distance from the robot to the obstacle is greater that ρ0), one potential that meets these criteria is given by Urep(q) =    1 2 η ( 1 ρ(q) − 1 ρ0 )2 : ρ(q) ≤ ρ0 0 : ρ(q) > ρ0 (7.11) in which ρ(q) is the shortest distance from q to a conﬁguration space obstacle boundary, and η is a scalar gain coeﬃcient that determines the inﬂuence of the repulsive ﬁeld. If QO 160 CHAPTER 7. PATH PLANNING AND COLLISION AVOIDANCE CB1 CB2 F rep F rep Figure 7.3: Situation in which the gradient of the repuslive potential of (7.11) is not con- tinuous. consists of a single convex region, the corresponding repulsive force is given by the negative gradient of the repulsive ﬁeld, Frep(q) =    η ( 1 ρ(q) − 1 ρ0 ) 1 ρ2(q) ∇ρ(q) : ρ(q) ≤ ρ0 0 : ρ(q) > ρ0 . (7.12) When QO is convex, the gradient of the distance to the nearest obstacle is given by ∇ρ(q) = q − b ||q − b|| , (7.13) in which b is the point in the boundary of QO that is nearest to q. The derivation of (7.12) and (7.13) are left as exercises ??. If QO is not convex, then ρ won’t necessarily be diﬀerentiable everywhere, which implies discontinuity in the force vector. Figure 7.3 illustrates such a case. Here QO contains two rectangular obstacles. For all conﬁgurations to the left of the dashed line, the force vector points to the right, while for all conﬁgurations to the right of the dashed line the force vector points to the left. Thus, when the conﬁguration of the robot crosses the dashed line, a discontinuity in force occurs. There are various ways to deal with this problem. The simplest of these is merely to ensure that the regions of inﬂuence of distinct obstacles do not overlap. 7.2.3 Gradient Descent Planning Gradient descent is a well known approach for solving optimization problems. The idea is simple. Starting at the initial conﬁguration, take a small step in the direction of the negative gradient (i.e., in the direction decreases the potential as quickly as possible). This gives a 7.3. PLANNING USING WORKSPACE POTENTIAL FIELDS 161 new conﬁguration, and the process is repeated until the ﬁnal conﬁguration is reached. More formally, we can deﬁne a gradient descent algorithm as follows. 1. q0 ← qinit, i ← 0 2. IF qi ̸= qﬁnal qi+1 ← qi + αi F (qi) ||F (qi)|| i ← i + 1 ELSE return < q0, q1 · · · qi > 3. GO TO 2 In this algorithm, the notation qi is used to denote the value of q at the ith iteration (not the ith componenent of the vector q) and the ﬁnal path consists of the sequence of iterates < q0, q1 · · · qi >. The value of the scalar αi determines the step size at the ith iteration; it is multiplied by the unit vector in the direction of the resultant force. It is important that αi be small enough that the robot is not allowed to “jump into” obstacles, while being large enough that the algorithm doesn’t require excessive computation time. In motion planning problems, the choice for αi is often made on an ad hoc or empirical basis, perhaps based on the distance to the nearest obstacle or to the goal. A number of systematic methods for choosing αi can be found in the optimization literature [?]. The constants ζ and η used to deﬁne Uatt and Urep essentially arbitrate between attractive and repulsive forces. Finally, it is unlikely that we will ever exactly satisfy the condition qi = qﬁnal. For this reason, this condition is often replaced with the more forgiving condition ||qi − qﬁnal|| < ϵ, in which ϵ is chosen to be suﬃciently small, based on the task requirements. The problem that plagues all gradient descent algorithms is the possible existence of local minima in the potential ﬁeld. For appropriate choice of αi, it can be shown that the gradient descent algorithm is guaranteed to converge to a minimum in the ﬁeld, but there is no guarantee that this minimum will be the global minimum. In our case, this implies that there is no guarantee that this method will ﬁnd a path to qﬁnal. An example of this situation is shown in Figure 7.4. We will discuss ways to deal this below in Section 7.4. One of the main diﬃculties with this planning approach lies in the evaluation of ρ and ∇ρ. In the general case, in which both rotational and translational degrees of freedom are allowed, this becomes even more diﬃcult. We address this general case in the next section. 7.3 Planning Using Workspace Potential Fields As described above, in the general case, it is extremely diﬃcult to compute an explicit representation of QO, and thus it can be extremely diﬃcult to compute ρ and ∇ρ. In fact, in general for a curved surface there does not exist a closed form expression for the distance from a point to the surface. Thus, even if we had access to an explicit representation of QO, it would still be diﬃcult to compute ρ and ∇ρ in (7.12). In order to deal with these diﬃculties, in this section we will modify the potential ﬁeld approach of Section 7.2 so that the potential function is deﬁned on the workspace, W, instead of the conﬁguration space, 162 CHAPTER 7. PATH PLANNING AND COLLISION AVOIDANCE qf inal local minimum qinit Figure 7.4: This ﬁgure illustrates the progress of a gradient descent algorithm from qinit to a local minimum in the ﬁeld U . Q. Since W is a subset of a low dimensional space (either ℜ2 or ℜ3), it will be much easier to implement and evaluate potential functions over W than over Q. We begin by describing a method to deﬁne an appropriate potential ﬁeld on the workspace. This ﬁeld should have the properties that the potential is at a minimum when the robot is in its goal conﬁguration, and the potential should grow without bound as the robot ap- proaches an obstacle. As above, we will deﬁne a global potential ﬁeld that is the sum of attractive and repulsive ﬁelds. Once we have constructed the workspace potential, we will develop the tools to map its gradient to changes in the joint variable values (i.e., we will map workspace forces to changes in conﬁguration). Finally, we will present a gradient descent algorithm similar to the one presented above, but which can be applied to robots with more complicated kinematics. 7.3.1 Deﬁning Workspace Potential Fields As before, our goal in deﬁning potential functions is to construct a ﬁeld that repels the robot from obstacles, with a global minimum that corresponds to qﬁnal. In the conﬁguration space, this task was conceptually simple because the robot was represented by a single point, which we treated as a point mass under the inﬂuence of a potential ﬁeld. In the workspace, things are not so simple; the robot is an articulated arm with ﬁnite volume. Evaluating the eﬀect of a potential ﬁeld over the arm would involve computing an integral over the volume of the arm, and this can be quite complex (both mathematically and computationally). An alternative approach is to select a subset of points on the robot, called control points, and to deﬁne a workspace potential for each of these points. The global potential is obtained by summing the eﬀects of the individual potential functions. Evaluating the eﬀect a particular potential ﬁeld on a single point is no diﬀerent than the evaluations required in Section 7.2, but the required distance and gradient calculations are much simpler. Let Aatt = {a1, a2 · · · an} be a set of control points used to deﬁne the attractive potential ﬁelds. For an n-link arm, we could use the centers of mass for the n links, or the origins 7.3. PLANNING USING WORKSPACE POTENTIAL FIELDS 163 for the DH frames (excluding the ﬁxed frame 0). We denote by ai(q) the position of the ith control point when the robot is at conﬁguration q. For each ai ∈ Aatt we can deﬁne an attractive potential by Uatti(q) =    1 2 ζi||ai(q) − ai(qﬁnal)||2 : ||ai(q) − ai(qﬁnal)|| ≤ d dζi||ai(q) − ai(qﬁnal)|| − 1 2 ζid2 : ||ai(q) − ai(qﬁnal)|| > d . (7.14) For the single point ai, this function is analogous the attractive potential deﬁned in Section 7.2; it combines the conic and quadratic potentials, and reaches its global minimum when the control point reaches its goal position in the workspace. If Aatt contains a suﬃcient number of independent control points (the origins of the DH frames, e.g.), then when all control points reach their global minimum potential value, the conﬁguration of the arm will be qﬁnal. With this potential function, the workspace force for attractive control point ai is deﬁned by Fatt,i(q) = −∇Uatti(q) (7.15) =    −ζi(ai(q) − ai(qﬁnal)) : ||ai(q) − ai(qﬁnal)|| ≤ d − dζi(ai(q) − ai(qﬁnal)) ||ai(q)−ai(qﬁnal)|| : ||ai(q) − ai(qﬁnal)|| > d . (7.16) For the workspace repulsive potential ﬁelds, we will select a set of ﬁxed control points on the robot Arep = {a1, · · · , am}, and deﬁne the repulsive potential for aj as Urepj(q) =    1 2 ηj ( 1 ρ(aj(q)) − 1 ρ0 )2 : ρ(aj(q)) ≤ ρ0 0 : ρ(aj(q)) > ρ0 , (7.17) in which ρ(aj(q)) is the shortest distance between the control point aj and any workspace obstacle, and ρ0 is the workspace distance of inﬂuence in the worksoace for obstacles. The negative gradient of each Urepj corresponds to a workspace repulsive force, Frep,j(q) =    ηj ( 1 ρ(aj(q)) − 1 ρ0 ) 1 ρ2(aj(q)) ∇ρ(aj(q)) : ρ(aj(q)) ≤ ρ0 0 : ρ(aj(q)) > ρ0 , (7.18) in which the notation ∇ρ(aj(q)) indicates the gradient ∇ρ(x) evaluated at x = aj(q). If b is the point on the workspace obstacle boundary that is closest to the repulsive control 164 CHAPTER 7. PATH PLANNING AND COLLISION AVOIDANCE A E1a1 a2 O Figure 7.5: The repulsive forces exerted on the robot vertices a1 and a2 may not be suﬃcient to prevent a collision between edge E1 and the obstacle. point aj, then ρ(aj(q)) = ||aj(q) − b||, and its gradient is ∇ρ(x) ∣ ∣ ∣ ∣ x=aj (q) = aj(q) − b ||aj(q) − b|| , (7.19) i.e., the unit vector directed from b toward aj(q). It is important to note that this selection of repulsive control points does not guarantee that the robot cannot collide with an obstacle. Figure 7.5 shows an example where this is the case. In this ﬁgure, the repulsive control points a1 and a2 are very far from the obstacle O, and therefore the repulsive inﬂuence may not be great enough to prevent the robot edge E1 from colliding with the obstacle. To cope with this problem, we can use a set of ﬂoating repulsive control points, af loat,i, typically one per link of the robot arm. The ﬂoating control points are deﬁned as points on the boundary of a link that are closest to any workspace obstacle. Obviously the choice of the af loat,i depends on the conﬁguration q. For the example shown in Figure 7.5, af loat would be located at the center of edge E1, thus repelling the robot from the obstacle. The repulsive force acting on af loat is deﬁned in the same way as for the other control points, using (7.18). 7.3.2 Mapping workspace forces to joint forces and torques Above we have constrructed potential ﬁelds in the robot’s workspace, and these ﬁelds induce artiﬁcial forces on the individual control points on the robot. In this section, we describe how these forces can be used to drive a gradient descent algorithm on the conﬁguration space. Suppose a force, F were applied to a point on the robot arm. Such a force would induce forces and torques on the robot’s joints. If the joints did not resist these forces, a motion would occur. This is the key idea behind mapping artiﬁcial forces in the workspace to motions of the robot arm. Therefore, we now derive the relationship between forces applied to the robot arm, and the resulting forces and torques that are induced on the robot joints. 7.3. PLANNING USING WORKSPACE POTENTIAL FIELDS 165 Let F denote the vector of joint torques (for revolute joints) and forces (for prismatic joints) induced by the workspace force. As we will describe in Chapter 9, the principle of virtual work can be used to derive the relationship between F and F . Let (δx, δy, δz)T be a virtual displacement in the workspace and let δq be a virtual displacement of the robot’s joints. Then, recalling that work is the inner product of force and displacement, by applying the principle of virtual work we obtain F · (δx, δy, δz) T = F · δq (7.20) which can be written as F T (δx, δy, δz) T = F T δq. (7.21) Now, recall from Chapter 8 that   δx δy δz   = Jδq, in which J is the Jacobian of the forward kinematic map for linear velocity (i.e., the top three rows of the manipulator Jacobian). Substituting this into (7.20) we obtain F T Jδq = F T δq (7.22) (7.23) and since this must hold for all virtual displacements δq, we obtain F T J = F T (7.24) which implies that J T F = F. (7.25) Thus we see that one can easily map forces in the workspace to joint forces and torques using (7.25). Example 7.3 A Force Acting on a Vertex of a Polygonal Robot. Consider the polygonal robot shown in Figure 7.6. The vertex a has coordinates (ax, ay)T in the robot’s local coordinate frame. Therefore, if the robot’s conﬁguration is given by q = (x, y, θ), the forward kinematic map for vertex a (i.e., the mapping from q = (x, y, θ) to the global coordinates of the vertex a) is given by a(x, y, θ) = [ x + ax cos θ − ay sin θ y + ax sin θ + ay cos θ ] . (7.26) The corresponding Jacobian matrix is given by Ja(x, y, θ) = [ 1 0 −ax sin θ − ay cos θ 0 1 ax cos θ − ay sin θ ] (7.27) 166 CHAPTER 7. PATH PLANNING AND COLLISION AVOIDANCE ax yA F ay xA θ a Figure 7.6: The robot A, with coordinate frame oriented at angle θ from the world frame, and vertex a with local coordinates (ax, ay). Therefore, the conﬁguration space force is given by   Fx Fy Fθ   =   1 0 0 1 −ax sin θ − ay cos θ ax cos θ − ay sin θ   [ Fx Fy ] =   Fx Fy −Fx(ax sin θ − ay cos θ) + Fy(ax cos θ − ay sin θ)   (7.28) and Fθ corresponds to the torque exerted about the origin of the robot frame. In this simple case, one can use basic physics to arrive at the same result. In particular, recall that a force, F, exerted at point, a, produces a torque, τ , about the point OA, and this torque is given by the relationship τ = r × F, in which r is the vector from OA to a. Of course we must express all vectors relative to a common frame, and in three dimensions (since torque will be deﬁned as a vector perpendicular to the plane in which the force acts). If we choose the world frame as our frame of reference, then we have r =   ax cos θ − ay sin θ ax sin θ + ay cos θ 0   and the cross product gives τ = r × F =   ax cos θ − ay sin θ ax sin θ + ay cos θ 0   ×   Fx Fy 0   =   0 0 −Fx(ax sin θ − ay cos θ) + Fy(ax cos θ − ay sin θ)   (7.29) 7.3. PLANNING USING WORKSPACE POTENTIAL FIELDS 167 Thus we see that the more general expression J T F = F gives the same value for torque as the expression τ = r × F from mechanics. ⋄ Example 7.4 Two-link Planar Arm Consider a two-link planar arm with the usual DH frame assignment. If we assign the control points as the origins of the DH frames (excluding the base frame), the forward kinematic equations for the arm give [ a1(θ1, θ2) a2(θ1, θ2) ] = [ l1 cos θ1 l1 cos θ1 + l2 cos(θ1 + θ2) l1 sin θ1 l1 sin θ1 + l2 sin(θ1 + θ2) ] in which li are the link lengths (we use li rather than ai to avoid confusion of link lengths and control points). For the problem of motion planning, we require only the Jacobian that maps joint velocities to linear velocities, [ ˙x ˙y ] = J [ ˙θ1 ˙θ1 ] . (7.30) For the two-link arm, The Jacobian matrix for a2 is merely the Jacobian that we derived in Chapter 5: Ja2(θ1, θ2) = [ −a1s1 − a2s12 −a2s12 a1c1 + a2c12 a2c12 ] . (7.31) The Jacobian matrix for a1 is similar, but takes into account that motion of joint two does not aﬀect the velocity of a1, Ja1(θ1, θ2) = [ −a1s1 0 a1c1 0 ] . (7.32) ⋄ The total conﬁguration space force acting on the robot is the sum of the conﬁguration space forces that result from all attractive and repulsive control points F (q) = ∑ i Fatti(q) + ∑ i Frepi(q) = ∑ i J T i (q)Fatt,i(q) + ∑ i J T i (q)Frep,i(q) (7.33) in which Ji(q) is the Jacobian matrix for control point ai. It is essential that the addition of forces be done in the conﬁguration space and not in the workspace. For example, Figure 7.7 shows a case where two workspace forces, F1 and F2, act on opposite corners of a rectang. It is easy to see that F1 + F2 = 0, but that the combination of these forces produces a pure torque about the center of the square. 168 CHAPTER 7. PATH PLANNING AND COLLISION AVOIDANCE F2 F1 Figure 7.7: This example illustrates why forces must be mapped to the conﬁguration space before they are added. The two forces illustrated in the ﬁgure are vectors of equal magnitude in opposite directions. Vector addition of these two forces produces zero net force, but there is a net moment induced by these forces. Example 7.5 Two-link planar arm revisited. Consider again the two-link planar arm. Suppose that that the workspace repulsive forces are given by Frep,i(θ1, θ2) = [Fx,i, Fy,i]T . For the two-link planar arm, the repulsive forces in the conﬁguration space are then given by Frep(q) = [ −a1s1 a1c1 0 0 ] [ Fx,1 Fy,1 ] (7.34) + [ −a1s1 − a2s12 a1c1 + a2c12 −a2s12 a2c12 ] [ Fx,2 Fy,2 ] (7.35) ⋄ 7.3.3 Motion Planning Algorithm Having deﬁned a conﬁguration space force, we can use the same gradient descent method for this case as in Section 7.3. As before, there are a number of design choices that must be made. ζi controls the relative inﬂuence of the attractive potential for control point ai. It is not necessary that all of the ζi be set to the same value. Typically, we weight one of the control points more heavily than the others, producing a “follow the leader” type of motion, in which the leader control point is quickly attracted to its ﬁnal position, and the robot then reorients itself so that the other attractive control points reach their ﬁnal positions. ηj controls the relative inﬂuence of the repulsive potential for control point aj. As with the ζi it is not necessary that all of the ηj be set to the same value. In particular, we typically set the value of ηj to be much smaller for obstacles that are near the goal position of the robot (to avoid having these obstacles repel the robot from the goal). 7.4. USING RANDOM MOTIONS TO ESCAPE LOCAL MINIMA 169 ρ0 As with the ηj, we can deﬁne a distinct ρ0 for each obstacle. In particular, we do not want any obstacle’s region of inﬂuence to include the goal position of any repulsive control point. We may also wish to assign distinct ρ0’s to the obstacles to avoid the possibility of overlapping regions of inﬂuence for distinct obstacles. 7.4 Using Random Motions to Escape Local Minima As noted above, one problem that plagues artiﬁcial potential ﬁeld methods for path planning is the existence of local minima in the potential ﬁeld. In the case of articulated manipulators, the resultant ﬁeld U is the sum of many attractive and repulsive ﬁelds deﬁned over ℜ3. This problem has long been known in the optimization community, where probabilistic methods such as simulated annealing have been developed to cope with it. Similarly, the robot path planning community has developed what are known as randomized methods to deal with this and other problems. The ﬁrst of these methods was developed speciﬁcally to cope with the problem of local minima in potential ﬁelds. The ﬁrst planner to use randomization to escape local minima was called RPP (for Ran- domized Potential Planner). The basic approach is straightforward: use gradient descent until the planner ﬁnds itself stuck in a local minimum, then use a random walk to escape the local minimum. The algorithm is a slight modiﬁcation of the gradient descent algorithm of Section 7.3. 1. q0 ← qinit, i ← 0 2. IF qi ̸= qﬁnal qi+1 ← qi + αi F (qi) ||F (qi)|| i ← i + 1 ELSE return < q0, q1 · · · qi > 3. IF stuck in a local minimum execute a random walk, ending at q′ qi+1 ← q′ 4. GO TO 2 The two new problems that must be solved are determining when the planner is stuck in a local minimum and deﬁning the random walk. Typically, a heuristic is used to recognize a local minimum. For example, if several successive qi lie within a small region of the conﬁguration space, it is likely that there is a nearby local minimum (e.g., if for some small positive ϵ we have ∥qi − qi+1∥ < ϵ, ∥qi − qi+2∥ < ϵ, and ∥qi − qi+3∥ < ϵ then assume qi is near a local minimum). Deﬁning the random walk requires a bit more care. The original approach used in RPP is as follows. The random walk consists of t random steps. A random step from q = (q1, · · · qn) is obtained by randomly adding a small ﬁxed constant to each qi, qrandom−step = (q1 ± v1, · · · qn ± vn) 170 CHAPTER 7. PATH PLANNING AND COLLISION AVOIDANCE with vi a ﬁxed small constant and the probability of adding +vi or −vi equal to 1/2 (i.e., a uniform distribution). Without loss of generality, assume that q = 0. We can use probability theory to characterize the behavior of the random walk consisting of t random steps. In particular, the probability density function for q′ = (q1, · · · , qn) is given by pi(qi, t) = 1 vi√2πt exp ( − q2 i 2v2 i t ) (7.36) which is a zero mean Gaussian density function with variance v2 i t. This is a result of the fact that the sum of a set of uniformly distributed random variables is a Gaussian random variable.2 The variance v2 i t essentially determines the range of the random walk. If certain characteristics of local minima (e.g., the size of the basin of attraction) are known in advance, these can be used to select the parameters vi and t. Otherwise, they can be determined empirically, or based on weak assumptions about the potential ﬁeld (the latter approach was used in the original RPP). 7.5 Probabilistic Roadmap Methods The potential ﬁeld approaches described above incrementally explore Qfree, searching for a path from qinit to qﬁnal. At termination, these planners return a single path. Thus, if multiple path planning problems must be solved, such a planner must be applied once for each problem. An alternative approach is to construct a representation of Qfree that can be used to quickly generate paths when new path planning problems arise. This is useful, for example, when a robot operates for a prolonged period in a single workspace. In this section, we will describe probabilistic roadmaps (PRMs), which are one-dimensional roadmaps in Qfree that can be used to quickly generate paths. Once a PRM has been con- structed, the path planning problem is reduced to ﬁnding paths to connect qinit and qﬁnal to the roadmap (a problem that is typically much easier than ﬁnding a path from qinit to qﬁnal). A PRM is a network of simple curve segments, or arcs, that meet at nodes. Each node corresponds to a conﬁguration. Each arc between two nodes corresponds to a collision free path between two conﬁgurations. Constructing a PRM is a conceptually straightforward process. First, a set of random conﬁgurations is generated to serve as the nodes in the network. Then, a simple, local path planner is used to generate paths that connect pairs of conﬁgurations. Finally, if the initial network consists of multiple connected components3, it is augmented by an enhancement phase, in which new nodes and arcs are added in an attempt to connect disjoint components of the network. To solve a path planning problem, 2A Gaussian density function is the classical bell shaped curve. The mean indicates the center of the curve (the peak of the bell) and the variance indicates the width of the bell. The probability density function (pdf) tells how likely it is that the variable qi will lie in a certain interval. The higher the pdf values, the more likely that qi will lie in the corresponding interval. 3 A connected component is a maximal subnetwork of the network such that a path exists in the subnet- work between any two nodes. 7.5. PROBABILISTIC ROADMAP METHODS 171 2-norm in C-space: ∥q′ − q∥ = [∑n i=1(q′ i − qi)2] 1 2 ∞-norm in C-space: maxn |q′ i − qi| 2-norm in workspace: [∑ p∈A∥ ∥p(q′) − p(q) ∥ ∥2] 1 2 ∞-norm in workspace: maxp∈A∥ ∥p(q′) − p(q) ∥ ∥. Table 7.1: Four distance functions from the literature that we have investigated the simple, local planner is used to connect qinit and qﬁnal to the roadmap, and the resulting network is searched for a path from qinit to qﬁnal. These four steps are illustrated in Figure 7.8. We now discuss these steps in more detail. 7.5.1 Sampling the conﬁguration space The simplest way to generate sample conﬁgurations is to sample the conﬁguration space uniformly at random. Sample conﬁgurations that lie in QO are discarded. A simple collision checking algorithm can determine when this is the case. The disadvantage of this approach is that the number of samples it places in any particular region of Qfree is proportional to the volume of the region. Therefore, uniform sampling is unlikely to place samples in narrow passages of Qfree. In the PRM literature, this is refered to as the narrow passage problem. It can be dealt with either by using more intelligent sampling schemes, or by using an enhancement phase during the construction of the PRM. In this section, we discuss the latter option. 7.5.2 Connecting Pairs of Conﬁgurations Given a set of nodes that correspond to conﬁgurations, the next step in building the PRM is to determine which pairs of nodes should be connected by a simple path. The typical approach is to attempt to connect each node to it’s k nearest neighbors, with k a parameter chosen by the user. Of course, to deﬁne the nearest neighbors, a distance function is re- quired. Table 7.1 lists four distance functions that have been popular in the PRM literature. For the equations in this table, the robot has n joints, q and q′ are the two conﬁgurations corresponding to diﬀerent nodes in the roadmap, qi refers to the conﬁguration of the ith joint, and p(q) refers to the workspace reference point p of a set of reference points of the robot, A, at conﬁguration q. Of these, the simplest, and perhaps most commonly used, is the 2-norm in conﬁguraiton space. Once pairs of neighboring nodes have been identiﬁed, a simple local planner is used to connect these nodes. Often, a straight line in conﬁguration space is used as the candidate plan, and thus, planning the path between two nodes is reduced to collision checking along a straight line path in the conﬁguration space. If a collision occurs on this path, it can 172 CHAPTER 7. PATH PLANNING AND COLLISION AVOIDANCE (a) (b) qinit qf inal (c) (d) Figure 7.8: (a) A two-dimensional conﬁguration space populated with several random sam- ples (b) One possible PRM for the given conﬁguration space and random samples (c) PRM after enhancement (d) path from qinit to qﬁnal found by connecting qinit and qﬁnal to the roadmap and then searching the roadmap for a path from qinit to qﬁnal. 7.5. PROBABILISTIC ROADMAP METHODS 173 be discarded, or a more sophisticated planner (e.g., RPP discussed above) can be used to attempt to connect the nodes. The simplest approach to collision detection along the straight line path is to sample the path at a suﬃciently ﬁne discretization, and to check each sample for collision. This method works, provided the discretization is ﬁne enough, but it is terribly ineﬃcient. This is because many of the computations required to check for collision at one sample are repeated for the next sample (assuming that the robot has moved only a small amount between the two conﬁgurations). For this reason, incremental collision detection approaches have been developed. While these approaches are beyond the scope of this text, a number of collision detection software packages are available in the public domain. Most developers of robot motion planners use one of these packages, rather than implementing their own collision detection routines. 7.5.3 Enhancement After the initial PRM has been constructed, it is likely that it will consist of multiple connected components. Often these individual components lie in large regions of Qfree that are connected by narrow passages in Qfree. The goal of the enhancement process is to connect as many of these disjoint components as possible. One approach to enhancement is to merely attempt to directly connect nodes in two disjoint components, perhaps by using a more sophisticated planner such as RPP. A common approach is to identify the largest connected component, and to attempt to connect the smaller components to it. The node in the smaller component that is closest to the larger component is typically chosen as the candidate for connection. A second approach is to choose a node randomly as candidate for connection, and to bias the random choice based on the number of neighbors of the node; a node with fewer neighbors in the network is more likely to be near a narrow passage, and should be a more likely candidate for connection. A second approach to enhancement is to add samples more random nodes to the PRM, in the hope of ﬁnding nodes that lie in or near the narrow passages. One approach is to identify nodes that have few neighbors, and to generate sample conﬁgurations in regions around these nodes. The local planner is then used to attempt to connect these new conﬁgurations to the network. 7.5.4 Path Smoothing After the PRM has been generated, path planning amounts to connecting qinit and qﬁnal to the network using the local planner, and then performing path smoothing, since the resulting path will be composed of straight line segments in the conﬁguration space. The simplest path smoothing algorithm is to select two random points on the path and try to connect them with the local planner. This process is repeated until until no signiﬁcant progress is made. 174 CHAPTER 7. PATH PLANNING AND COLLISION AVOIDANCE 7.6 Historical Perspective The earliest work on robot planning was done in the late sixties and early seventies in a few University-based Artiﬁcial Intelligence (AI) labs [?, ?, ?]. This research dealt with high level planning using symbolic reasoning that was much in vogue at the time in the AI community. Geometry was not often explicitly considered in early robot planners, in part because it was not clear how to represent geometric constraints in a computationally plausible manner. The conﬁguration space and its application to path planning were introduced in [?]. This was the ﬁrst rigorous, formal treatment of the geometric path planning problem, and it initiated a surge in path planning research. The earliest work in geometric path planning developed methods to construct volumetric representations of the free conﬁguration space. These included exact methods (e.g., [?]), and approximate methods (e.g., [?, ?, ?]). In the former case, the best known algorithms have exponential complexity and require exact descriptions of both the robot and its environment, while in the latter case, the size of the representation of C-space grows exponentially in the dimension of the C-space. The best known algorithm for the path planning problem, giving an upper bound on the amount of computation time required to solve the problem, appeared in [?]. That real robots rarely have an exact description of the environment, and a drive for faster planning systems led to the development of potential ﬁelds approaches [?, ?]. By the early nineties, a great deal of research had been done on the geometric path planning problem, and this work is nicely summarized in the textbook [?]. This textbook helped to generate a renewed interest in the path planning problem, and it provided a common framework in which to analyze and express path planning algorithms. Soon after, the research ﬁeld of Algorithmic Robotics was born at a small workshop in San Francisco [?]. In the early nineties, randomization was introduced in the robot planning community [?], originally to circumvent the problems with local minima in potential ﬁelds). Early randomized motion planners proved eﬀective for a large range of problems, but sometimes required extensive computation time for some robots in certain environments [?]. This limitation, together with the idea that a robot will operate in the same environment for a long period of time led to the development of the probabilistic roadmap planners [?, ?, ?]. Finally, much work has been done in the area of collision detection in recent years. [?, ?, ?, ?]. This work is primarily focused on ﬁnding eﬃcient, incremental methods for detecting collisions between objects when one or both are moving. A number of public domain collision detection software packages are currently available on the internet. Chapter 8 TRAJECTORY PLANNING In chapter 7, we learned how to plan paths for robot tasks. In order to execute these plans, a few more details must be speciﬁed. For example, what should be the joint velocities and accelerations while traversing the path? These questions are addressed by a trajectory planner. The trajectory planner computes a function qd(t) that completely speciﬁes the motion of the robot as it traverses the path. We begin by discussing the trajectory planning problem and how it relates to path plan- ning. We then consider the simple case of planning a trajectory between two conﬁgurations. This leads naturally to planning trajectories for paths that are speciﬁed as a sequence of conﬁgurations. We then turn our attention to the problem of planning trajectories that sat- isfy constraints that are speciﬁed in the Cartesian workspace of the robot (e.g., a straight line trajectory for the end eﬀector). We end the chapter with a discussion of time scaling of trajectories. 8.1 The Trajectory Planning Problem We begin by distinguising between a path and a trajectory. Recall from Chapter 7 that a path from qinit to qf inal is deﬁned as a continuous map, τ : [0, 1] → Q, with τ (0) = qinit and τ (1) = qf inal. A trajectory is a function of time q(t) such that q(t0) = qinit and q(tf ) = qf inal . In this case, tf − t0 represents the amount of time taken to execute the trajectory. Since the trajectory is parameterized by time, we can compute velocities and accelerations along the trajectories by diﬀerentiation. If we think of the argument to τ as a time variable, then a path is a special case of a trajectory, one that will be executed in one unit of time. In other words, in this case τ gives a complete speciﬁcation of the robot’s trajectory, including the time derivatives (since one need only diﬀerentiate τ to obtain these). In general, a path planning algorithm may not actually give the map τ ; it might give only a sequence of points along the path (as was the case for several of the path planning algorithms of Chapter 7). Or, it may be the case that we prefer that the duration of the robot motion not be one unit of time. Furthermore, there are other ways that the path 175 176 CHAPTER 8. TRAJECTORY PLANNING could be speciﬁed. In some cases, paths are speciﬁed by giving a sequence of end-eﬀector poses, T 0 6 (k∆t). In this case, the inverse kinematic solution must be used to convert this to a sequence of joint conﬁgurations. A common way to specify paths for industrial robots is to physically lead the robot through the desired motion with a teach pendant. In this case, there is no need for calculation of the inverse kinematics. The desired motion is simply recorded as a set of joint angles (actually as a set of encoder values) and the robot can be controlled entirely in joint space. In each of these cases, the path will not serve as a trajectory for the robot. We ﬁrst consider point to point motion. In this case the task is to plan a trajectory from q(t0) to q(tf ), i.e., the path is speciﬁed by its initial and ﬁnal conﬁgurations. This type of motion is suitable for materials transfer tasks when the workspace is clear of obstacles and is common in so-called teach and playback mode where the robot is taught a sequence of moves with a teach pendant. In some cases, there may be constraints on the trajectory (e.g., if the robot must start and end with zero velocity). Nevertheless, it is easy to realize that there are inﬁnitely many trajectories that will satisfy a ﬁnite number of constraints on the endpoints. It is common practice therefore to choose trajectories from a ﬁnitely parameterizable family, for example, polynomials of degree n, with n dependant on the number of constraints to be satisﬁed. This is the approach that we will take in this text.. In Section 8.2, we will discuss the trajectory planning problem for point to point motion. Once we have developed techniques for planning trajectories for point to point motion, we will turn our attention in Section 8.3 to the problem of planning trajectories for paths that are speciﬁed by a sequence of via points, such as those plans returned by the PRM planner discussed in Chapter 7. In this case, we will deal not only with constraints on initial and ﬁnal conﬁgurations, but also with constraints at each via point (e.g., velocity discontinuities will not be allowed at via points). We will investigate several methods for planning these trajectories, each of which is an extension of a method in Section 8.2 to the multiple via point case. For some purposes, such as obstacle avoidance, the path of the end-eﬀector can be further constrained by the addition of via points intermediate to the initial and ﬁnal conﬁgurations as illustrated in Figure 8.1. Additional constraints on the velocity or acceleration between via points, as for example in so-called guarded motion, shown in Figure 8.2, can be handled in the joint interpolation schemes treated in this chapter . 8.2 Trajectories for Point to Point Motion As described above, the problem here is to ﬁnd a trajectory that connects an initial to a ﬁnal conﬁguration while satisfying other speciﬁed constraints at the endpoints (e.g., velocity and/or acceleration constraints). Without loss of generality, we will, from here on, consider planning the trajectory for a single joint, since the trajectories for the remaining joints will be created independently and in exactly the same way. Thus, we will concern ourselves with the problem of determining q(t), where q(t) is a scalar joint variable. 8.2. TRAJECTORIES FOR POINT TO POINT MOTION 177 Figure 8.1: Via points to plan motion around obstacles. Figure 8.2: Guarded and free motions. We suppose that at time t0 the joint variable satisﬁes q(t0) = q0 (8.1) ˙q(t0) = v0 (8.2) and we wish to attain the values at tf q(tf ) = qf (8.3) ˙q(tf ) = vf . (8.4) Figure 8.3 shows a suitable trajectory for this motion. In addition, we may wish to specify the constraints on initial and ﬁnal accelerations. In this case we have two the additional equations ¨q(t0) = α0 (8.5) ¨q(tf ) = αf . (8.6) 178 CHAPTER 8. TRAJECTORY PLANNING 2 2.2 2.4 2.6 2.8 3 3.2 3.4 3.6 3.8 4 5 10 15 20 25 30 35 40 45 Time (sec)Angle (deg) Typical Joint Space Trajectory t 0 q 0 t f q f Figure 8.3: Typical Joint Space Trajectory. 8.2.1 Cubic Polynomial Trajectories Suppose that we wish to generate a trajectory between two conﬁgurations, and that we wish to specify the start and end velocities for the trajectory. One way to generate a smooth curve such as that shown in Figure 8.3 is by a polynomial function of t. Since we have four constraints to satisfy, namely (8.1)-(8.3) we require a polynomial with four independent coeﬃcients that can be chosen to satisfy these constraints. Thus we consider a cubic trajectory of the form q(t) = a0 + a1t + a2t2 + a3t3. (8.7) Then the desired velocity is automatically given as ˙q(t) = a1 + 2a2t + 3a3t2. (8.8) Combining equations (8.7) and (8.8) with the four constraints yields four equations in four unknowns q0 = a0 + a1t0 + a2t2 0 + a3t3 0 (8.9) v0 = a1 + 2a2t0 + 3a3t2 0 (8.10) qf = a0 + a1tf + a2t2 f + a3t3 f (8.11) vf = a1 + 2a2tf + 3a3t2 f . (8.12) These four equations can be combined into a single matrix equation     1 t0 t2 0 t3 0 0 1 2t0 3t2 0 1 tf t2 f t3 f 0 1 2tf 3t2 f         a0 a1 a2 a3     =     q0 v0 qf vf     . (8.13) 8.2. TRAJECTORIES FOR POINT TO POINT MOTION 179 It can be shown (Problem X) that the determinant of the coeﬃcient matrix in Equation 8.13 is equal to (tf − t0)4 and, hence, 8.13 always has a unique solution provided a nonzero time interval is allowed for the execution of the trajectory. Example 8.1 Writing Equation 8.13 as M a = b (8.14) where M is the coeﬃcient matrix, a = [a0, a1, a2, a3]T is the vector of coeﬃcients of the cubic polynomial, and b = [q0, v0, q1, v1]T is the vector of initial data (initial and ﬁnal positions and velocities), the Matlab script below computes the general solution as a = M −1b (8.15) ⋄ %% %% cubic.m %% %% M-file to compute a cubic polynomial reference trajectory %% %% q0 = initial position %% v0 = initial velocity %% q1 = final position %% v1 = final velocity %% t0 = initial time %% tf = final time %% d = input(’ initial data = [q0,v0,q1,v1,t0,tf] = ’) q0 = d(1); v0= d(2); q1 = d(3); v1 = d(4); t0=d(5); tf=d(6); %% t = linspace(t0,tf,100*(tf-t0)); c = ones(size(t)); %% M = [ 1 t0 t0^2 t0^3; 0 1 2*t0 3*t0^2; 1 tf tf^2 tf^3; 0 1 2*tf 3*tf^2]; %% b = [q0; v0; q1; v1]; a = inv(M)*b; %% % qd = reference position trajectory 180 CHAPTER 8. TRAJECTORY PLANNING % vd = reference velocity trajectory % ad = reference acceleration trajectory % qd = a(1).*c + a(2).*t +a(3).*t.^2 + a(4).*t.^3; vd = a(2).*c +2*a(3).*t +3*a(4).*t.^2; ad = 2*a(3).*c + 6*a(4).*t; Example 8.2 As an illustrative example, we may consider the special case that the initial and ﬁnal velocities are zero. Suppose we take t0 = 0 and tf = 1 sec, with v0 = 0 vf = 0. (8.16) Thus we want to move from the initial position q0 to the ﬁnal position qf in 1 second, starting and ending with zero velocity. From the above formula (8.13) we obtain     1 0 0 0 0 1 0 0 1 1 1 1 0 1 2 3         a0 a1 a2 a3     =     q0 0 qf 0     . (8.17) This is then equivalent to the four equations a0 = q0 (8.18) a1 = 0 (8.19) a2 + a3 = qf − q0 (8.20) 2a2 + 3a3 = 0. (8.21) These latter two can be solved to yield a2 = 3(qf − q0) (8.22) a3 = −2(qf − q0). (8.23) The required cubic polynomial function is therefore qi(t) = q0 + 3(qf − q0)t2 − 2(qf − q0)t3. (8.24) Figure 8.4 shows this trajectory with q0 = 10◦, qf = −20◦. The corresponding velocity and acceleration curves are given in Figures 8.5 and 8.6. ⋄ 8.2. TRAJECTORIES FOR POINT TO POINT MOTION 181 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 −20 −15 −10 −5 0 5 10 Time (sec)Angle (deg) Cubic Polynomial Trajectory Figure 8.4: Cubic polynomial trajectory. 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 −45 −40 −35 −30 −25 −20 −15 −10 −5 0 Time (sec)Velocity (deg/sec) Velocity Profile for Cubic Polynomial Trajectory Figure 8.5: Velocity proﬁle for cubic polynomial trajectory 8.2.2 Multiple Cubics A sequence of moves can be planned using the above formula by using the end conditions qf , vf of the i-th move as initial conditions for the i + 1-st move. Example 8.3 Figure 8.9 shows a 6-second move, computed in three parts using (??), where the trajectory begins at 10◦ and is required to reach 40◦ at 2-seconds, 30◦ at 4seconds, and 90◦ at 6-seconds, with zero velocity at 0,2,4, and 6 seconds. ⋄ 8.2.3 Quintic Polynomial Trajectories As the above example shows, planning trajectories using multiple cubic trajectories leads to continuous positions and velocities at the blend times but discontinuities in the acceleration. The derivative of acceleration is called the Jerk. A discontinuity in acceleration leads to an impulsive Jerk, which may excite vibrational modes in the manipulator and reduce tracking 182 CHAPTER 8. TRAJECTORY PLANNING 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 −200 −150 −100 −50 0 50 100 150 200 Time (sec)Acceleration (deg/sec2) Acceleration Profile for Cubic Polynomial Trajectory Figure 8.6: Acceleration proﬁle for cubic polynomial trajectory. 0 1 2 3 4 5 6 10 20 30 40 50 60 70 80 90 Time (sec)Angle (deg) Trajectory Built of Multiple Cubic Segments Figure 8.7: Cubic spline trajectory made from three cubic polynomials. accuracy. For this reason, one may wish to specify constraints on the acceleration as well as on the position and velocity. In this case, we have six constraints (one each for initial and ﬁnal conﬁgurations, initial and ﬁnal velocities, and initial and ﬁnal accelerations). Therefore we require a ﬁfth order polynomial q(t) = a0 + a1t + a2t2 + a3t3 + a4t4 + a5t5. (8.25) Using (8.1) - (8.6) and taking the appropriate number of derivatives we obtain the following equations, 8.2. TRAJECTORIES FOR POINT TO POINT MOTION 183 0 1 2 3 4 5 6 −10 0 10 20 30 40 50 Time (sec)Velocity (deg/sec) Velocity Profile for Multiple Cubic Segments Figure 8.8: Velocity Proﬁle for Multiple Cubic Polynomial Trajectory 0 1 2 3 4 5 6 −100 −80 −60 −40 −20 0 20 40 60 80 100 Time (sec)Acceleration (deg/sec2) Acceleration for Multiple Cubic Segments Figure 8.9: Acceleration Proﬁle for Multiple Cubic Polynomial Trajectory q0 = a0 + a1t0 + a2t2 0 + a3t3 0 + a4t4 0 + a5t5 0 v0 = a1 + 2a2t0 + 3a3t2 0 + 4a4t3 0 + 5a5t4 0 α0 = 2a2 + 6a3t0 + 12a4t2 0 + 20a5t3 0 qf = a0 + a1tf + a2t2 f + a3t3 f + a4t4 f + a5t5 f vf = a1 + 2a2tf + 3a3t2 f + 4a4t3 f + 5a5t4 f αf = 2a2 + 6a3tf + 12a4t2 f + 20a5t3 f 184 CHAPTER 8. TRAJECTORY PLANNING which can be written as          1 t0 t2 0 t3 0 t4 0 t5 0 0 1 2t0 3t2 0 4t3 0 5t4 0 0 0 2 6t0 12t2 0 20t3 0 1 tf t2 f t3 f t4 f t5 f 0 1 2tf 3t2 f 4t3 f 5t4 f 0 0 2 6tf 12t2 f 20t3 f                  a0 a1 a2 a3 a4 a5         =         q0 v0 α0 qf vf αf         . (8.26) The Matlab script below gives the general solution to this equation. %% %% M-file to compute a quintic polynomial reference trajectory %% %% q0 = initial position %% v0 = initial velocity %% ac0 = initial acceleration %% q1 = final position %% v1 = final velocity %% ac1 = final acceleration %% t0 = initial time %% tf = final time %% clear d = input(’ initial data = [q0,v0,ac0,q1,v1,ac1,t0,tf] = ’) q0 = d(1); v0= d(2); ac0 = d(3); q1 = d(4);v1 = d(5);ac1=d(6);t0=d(7); tf=d(8); %% t = linspace(t0,tf,100*(tf-t0)); c = ones(size(t)); %% M = [ 1 t0 t0^2 t0^3 t0^4 t0^5; 0 1 2*t0 3*t0^2 4*t0^3 5*t0^4; 0 0 2 6*t0 12*t0^2 20*t0^3; 1 tf tf^2 tf^3 tf^4 tf^5; 0 1 2*tf 3*tf^2 4*tf^3 5*tf^4; 0 0 2 6*tf 12*tf^2 20*tf^3]; %% b=[q0; v0; ac0; q1; v1; ac1]; a = inv(M)*b; %% %% qd = position trajectory %% vd = velocity trajectory %% ad = acceleration trajectory 8.2. TRAJECTORIES FOR POINT TO POINT MOTION 185 %% qd = a(1).*c + a(2).*t +a(3).*t.^2 + a(4).*t.^3 +a(5).*t.^4 + a(6).*t.^5; vd = a(2).*c +2*a(3).*t +3*a(4).*t.^2 +4*a(5).*t.^3 +5*a(6).*t.^4; ad = 2*a(3).*c + 6*a(4).*t +12*a(5).*t.^2 +20*a(6).*t.^3; plot(t,qd) Example 8.4 The ﬁgures below show a quintic polynomial trajectory with q(0) = 0, q(2) = 40 with zero initial and ﬁnal velocities and accelerations. 0 0.2 0.4 0.6 0.8 1 1.2 1.4 1.6 1.8 2 0 5 10 15 20 25 30 35 40 Time (sec)Angle (deg) Cubic Polynomial Trajectory Figure 8.10: Quintic Polynomial Trajectory 0 0.2 0.4 0.6 0.8 1 1.2 1.4 1.6 1.8 2 0 5 10 15 20 25 30 35 40 Time (sec)Velocity (deg/sec) Velocity Profile for Cubic Polynomial Trajectory Figure 8.11: Velocity Proﬁle for Quintic Polynomial Trajectory ⋄ Example 8.5 The next ﬁgures show the same six second trajectory as in Example 8.3 with the added constraints that the accelerations should be zero at the blend times. ⋄ 186 CHAPTER 8. TRAJECTORY PLANNING 0 0.2 0.4 0.6 0.8 1 1.2 1.4 1.6 1.8 2 −60 −40 −20 0 20 40 60 Time (sec)Acceleration (deg/sec2) Acceration Profile for Quintic Polynomial Trajectory Figure 8.12: Acceleration Proﬁle for Quintic Polynomial Trajectory 0 1 2 3 4 5 6 10 20 30 40 50 60 70 80 90 100 Time (sec)Angle (deg) Multiple Quintic Polynomial Segments Figure 8.13: Trajectory with Multiple Quintic Segments 8.2.4 Linear Segments with Parabolic Blends (LSPB) Another way to generate suitable joint space trajectories is by so-called Linear Segments with Parabolic Blends or (LSPB) for short. This type of trajectory is appropriate when a constant velocity is desired along a portion of the path. The LSPB trajectory is such that the velocity is initially “ramped up” to its desired value and then “ramped down” when it approaches the goal position. To achieve this we specify the desired trajectory in three parts. The ﬁrst part from time t0 to time tb is a quadratic polynomial. This results in a linear “ramp” velocity. At time tb, called the blend time, the trajectory switches to a linear function. This corresponds to a constant velocity. Finally, at time tf − tb the trajectory switches once again, this time to a quadratic polynomial so that the velocity is linear. We choose the blend time tb so that the position curve is symmetric as shown in Fig- ure 8.16. For convenience suppose that t0 = 0 and ˙q(tf ) = 0 = ˙q(0). Then between times 0 8.2. TRAJECTORIES FOR POINT TO POINT MOTION 187 0 1 2 3 4 5 6 −10 0 10 20 30 40 50 60 Time (sec)Velocity (deg/sec) Velocity Profile for Multiple Quintic Segments Figure 8.14: Velocity Proﬁle for Multiple Quintic Segments 0 1 2 3 4 5 6 −100 −80 −60 −40 −20 0 20 40 60 80 100 Time (sec)Acceleration (deg/sec2) Acceleration Profile for Multiple Quintic Segments Figure 8.15: Acceleration Proﬁle for Multiple Quintic Segments and tb we have q(t) = a0 + a1t + a2t2 (8.27) so that the velocity is ˙q(t) = a1 + 2a2t. (8.28) The constraints q0 = 0 and ˙q(0) = 0 imply that a0 = q0 (8.29) a1 = 0. (8.30) At time tb we want the velocity to equal a given constant, say V . Thus, we have ˙q(tb) = 2a2tb = V (8.31) 188 CHAPTER 8. TRAJECTORY PLANNING 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 5 10 15 20 25 30 35 40 Time (sec)Angle (deg) Blend Times for LSPB Trajectory t b t f−t b Figure 8.16: Blend times for LSPB trajectory. which implies that a2 = V 2tb . (8.32) Therefore the required trajectory between 0 and tb is given as q(t) = q0 + V 2tb t2 (8.33) = q0 + α 2 t2 ˙q(t) = V tb t = αt (8.34) ¨q = V tb = α (8.35) where α denotes the acceleration. Now, between time tf and tf − tb, the trajectory is a linear segment (corresponding to a constant velocity V ) q(t) = a0 + a1t = a0 + V t. (8.36) Since, by symmetry, q ( tf 2 ) = q0 + qf 2 (8.37) we have q0 + qf 2 = a0 + V tf 2 (8.38) 8.2. TRAJECTORIES FOR POINT TO POINT MOTION 189 which implies that a0 = q0 + qf − V tf 2 . (8.39) Since the two segments must “blend” at time tb we require q0 + V 2 tb = q0 + qf − V tf 2 + V tb (8.40) which gives upon solving for the blend time tb tb = q0 − qf + V tf V . (8.41) Note that we have the constraint 0 < tb ≤ tf 2 . This leads to the inequality qf − q0 V < tf ≤ 2(qf − q0) V . (8.42) To put it another way we have the inequality qf − q0 tf < V ≤ 2(qf − q0) tf . (8.43) Thus the speciﬁed velocity must be between these limits or the motion is not possible. The portion of the trajectory between tf − tb and tf is now found by symmetry consid- erations (Problem XX). The complete LSPB trajectory is given by q(t) =    q0 + a 2 t2 0 ≤ t ≤ tb qf + q0 − V tf 2 + V t tb < t ≤ tf − tb qf − at 2 f 2 + atf t − a 2 t2 tf − tb < t ≤ tf . (8.44) Figure 8.17 shows such an LSPB trajectory, where the maximum velocity V = 60. In this case tb = 1 3 . The velocity and acceleration curves are given in Figures 8.18 and 8.19, respectively. 8.2.5 Minimum Time Trajectories An important variation of this trajectory is obtained by leaving the ﬁnal time tf unspeciﬁed and seeking the “fastest” trajectory between q0 and qf with a given constant acceleration α, that is, the trajectory with the ﬁnal time tf a minimum. This is sometimes called a 190 CHAPTER 8. TRAJECTORY PLANNING 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 5 10 15 20 25 30 35 40 Time (sec)Angle (deg) LSPB Trajectory Figure 8.17: LSPB trajectory. 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 10 20 30 40 50 60 70 Time (sec)Velocity (deg/sec) LSPB Velocity Profile Figure 8.18: Velocity proﬁle for LSPB trajectory. Bang-Bang trajectory since the optimal solution is achieved with the acceleration at its maximum value +α until an appropriate switching time ts at which time it abruptly switches to its minimum value −α (maximum deceleration) from ts to tf . Returning to our simple example in which we assume that the trajectory begins and ends at rest, that is, with zero initial and ﬁnal velocities, symmetry considerations would suggest that the switching time ts is just tf 2 . This is indeed the case. For nonzero initial and/or ﬁnal velocities, the situation is more complicated and we will not discuss it here. If we let Vs denote the velocity at time ts then we have Vs = αts (8.45) and also ts = q0 − qf + Vstf Vs . (8.46) 8.3. TRAJECTORIES FOR PATHS SPECIFIED BY VIA POINTS 191 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 −200 −150 −100 −50 0 50 100 150 200 TIme (sec)Acceleration (deg/sec2) LSPB Acceleration Profile Figure 8.19: Acceleration for LSPB trajectory. The symmetry condition ts = tf 2 implies that Vs = qf − q0 ts . (8.47) Combining these two we have the conditions qf − q0 ts = αts (8.48) which implies that ts = √qf − q0/2. (8.49) 8.3 Trajectories for Paths Speciﬁed by Via Points NOTE: via points are also called knot points or interpolation points path planner in chapter XXX gives a set of via points (e.g., PRM method). how do we convert this set of via points into a path??? Consider the simple of example of a path speciﬁed by three points, q0, q1, q2, such that the via points are reached at times t0, t1 and t2. If in addition to these three constraints we impose constraints on the initial and ﬁnal velocities and accelerations, we obtain the following set of constraints, 192 CHAPTER 8. TRAJECTORY PLANNING q(t0) = q0 ˙q(t0) = v0 ¨q(t0) = α0 q(t1) = q1 q(t2) = q2 ˙q(t2) = v2 ¨q(t2) = α2. which could be satisﬁed by generating a trajectory using the sixth order polynomial q(t) = a6t6 + a5t5 + a4t4 + a3t3 + a2t2 + a1t1 + a0. (8.50) One advantage to this approach is that, since q(t) is continuously diﬀerentiable, we need not worry about discontinuities in either velocity or acceleration at the via point, q1. How- ever, to determine the coeﬃcients for this polynomial, we must solve a linear system of dimension seven. The clear disadvantage to this approach is that as the number of via points increases, the dimension of the corresponding linear system also increases, making the method intractable when many via points are used.. An alternative to using a single high order polynomial for the entire trajectory is to use low order polynomials for trajectory segments between adjacent via points. We will denote by Qi(t) the polynomial that represents the trajectory from qi−1 to qi. These polynomi- als sometimes refered to as interpolating polynomials or blending polynomials. With this approach, we must take care that continuity constraints (e.g., in velocity and acceleration) are satisﬁed at the via points, where we switch from one polynomial to another. In this section, we will consider three types of interpolating polynomial trajectories: trajectories for which each Qi is a cubic polynomial; trajectories for which each Q1 and Q3 are fourth order polynomials and Q2 is a cubic polynomial; NOTE: should generalize this to an n segment trajectory with fourth order polynomials for ﬁrst and last segments and cubics in between. and .... what is that last one....; 8.3.1 4-3-4 trajectories q(t) =    Q1(t) = a14t4 + a13t3 + a12t2 + a11t + a10 : t0 ≤ t < t1 Q2(t) = a23t3 + a22t2 + a21t + a20 : t1 ≤ t < t2 Q3(t) = a34t4 + a33t3 + a32t2 + a31t + a30 : t2 ≤ t < t3 (8.51) Chapter 9 DYNAMICS This chapter deals with the dynamics of robot manipulators. Whereas the kinematic equa- tions describe the motion of the robot without consideration of the forces and moments producing the motion, the dynamic equations explicitly describe the relationship between force and motion. The equations of motion are important to consider in the design of robots, as well as in simulation and animation, and in the design of control algorithms. We introduce the so-called Euler-Lagrange equations, which describe the evolution of a mechanical system subject to holonomic constraints (this term is deﬁned later on). To motivate the Euler-Lagrange approach we begin with a simple derivation of these equa- tions from Newton’s Second Law for a one-degree-of-freedom system. We then derive the Euler-Lagrange equations from the Principle of Virtual Work in the general case. In order to determine the Euler-Lagrange equations in a speciﬁc situation, one has to form the Lagrangian of the system, which is the diﬀerence between the kinetic energy and the potential energy; we show how to do this in several commonly encountered situations. We then derive the dynamic equations of several example robotic manipulators, including a two-link cartesian robot, a two-link planar robot, and a two-link robot with remotely driven joints. The Euler-Lagrange equations have several very important properties that can be ex- ploited to design and analyze feedback control algorithms. Among these are explicit bounds on the inertia matrix, linearity in the inertia parameters, and the so-called skew symmetry and passivity properties. We discuss these properties in Section 9.5. This chapter is concluded with a derivation of an alternate the formulation of the dynam- ical equations of a robot, known as the Newton-Euler formulation which is a recursive formulation of the dynamic equations that is often used for numerical calculation. 9.1 The Euler-Lagrange Equations In this section we derive a general set of diﬀerential equations that describe the time evolu- tion of mechanical systems subjected to holonomic constraints, when the constraint forces satisfy the principle of virtual work. These are called the Euler-Lagrange equations of 193 194 CHAPTER 9. DYNAMICS motion. Note that there are at least two distinct ways of deriving these equations. The method presented here is based on the method of virtual displacements; but it is also possible to derive the same equations based on Hamilton’s principle of least action [?]. 9.1.1 One Dimensional System To motivate the subsequent derivation, we show ﬁrst how the Euler-Lagrange equations can be derived from Newton’s Second Law for a single degree of freedom system consisting of a particle of constant mass m, constrained to move in the y-direction, and subject to a force f and the gravitational force mg, as shown in Figure 9.1. By Newton’s Second law, Figure 9.1: One Degree of Freedom System F = ma, the equation of motion of the particle is m¨y = f − mg (9.1) Notice that the left hand side of Equation (9.1) can be written as m¨y = d dt (m ˙y) = d dt ∂ ∂ ˙y ( 1 2 m ˙y2) = d dt ∂K ∂ ˙y (9.2) where K = 1 2 m ˙y2 is the kinetic energy. We use the partial derivative notation in the above expression to be consistent with systems considered later when the kinetic energy will be a function of several variables. Likewise we can express the gravitational force in Equation (9.1) as mg = ∂ ∂y (mgy) = ∂P ∂y (9.3) where P = mgy is the potential energy due to gravity. If we deﬁne L = K − P = 1 2 m ˙y2 − mgy (9.4) and note that ∂L ∂ ˙y = ∂K ∂ ˙y and ∂L ∂y = − ∂P ∂y 9.1. THE EULER-LAGRANGE EQUATIONS 195 then we can write Equation (9.1) as d dt ∂L ∂ ˙y − ∂L ∂y = f. (9.5) The function L, which is the diﬀerence of the kinetic and potential energy, is called the Lagrangian of the system, and Equation (9.5) is called the Euler-Lagrange Equation. The Euler-Lagrange equations provide a formulation of the dynamic equations of motion equivalent to those derived using Newton’s Second Law. However, as we shall see, the Lagrangian approach is advantageous for more complex systems such as multi-link robots. Example: 9.1 Single-Link Manipulator Consider the single-link robot arm shown in Figure 9.2, consisting of a rigid link coupled Link \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001 \u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001 \u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0001\u0001\u0001 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0002\u0002\u0002 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001\u0001\u0001 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002\u0002\u0002 Gears Motor \u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001 \u0001\u0001\u0001\u0001 \u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002 \u0002\u0002\u0002\u0002 Figure 9.2: Single-Link Robot. through a gear train to a DC-motor. Let θℓ and θm denote the angles of the link and motor shaft, respectively. Then θm = rθℓ where r : 1 is the gear ratio. The algebraic relation between the link and motor shaft angles means that the system has only one degree-of- freedom and we can therefore write the equations of motion using either θm or θℓ. In terms of θℓ, the kinetic energy of the system is given by K = 1 2 Jm ˙θ2 m + 1 2 Jℓ ˙θ2 ℓ = 1 2 (r2Jm + Jℓ) ˙θ2 ℓ (9.6) where Jm, Jℓ are the rotational inertias of the motor and link, respectively. The potential energy is given as P = M gℓ(1 − cos θℓ) (9.7) where M is the total mass of the link and ℓ is the distance from the joint axis to the link center of mass. Deﬁning J = r2Jm + Jℓ, the Lagrangian L is given by L = 1 2 J ˙θ2 ℓ − M gℓ(1 − cos θℓ). (9.8) Substituting this expression into the Euler-Lagrange equations yields the equation of motion J ¨θℓ + M gℓ sin θℓ = τℓ. (9.9) 196 CHAPTER 9. DYNAMICS The generalized force τℓ consists of the motor torque u = rτm, reﬂected to the link and (nonconservative) damping torques Bm ˙θm, and Bℓ, ˙θℓ. Reﬂecting motor damping to the link yields τ = u − B ˙θℓ. where B = rBm + Bℓ. Therefore the complete expression for the dynamics of this system is J ¨θℓ + B ˙θℓ + M gℓ sin θℓ = u. (9.10) In general, for any system of the type considered, an application of the Euler-Lagrange equa- tions leads to a system of n coupled, second order nonlinear ordinary diﬀerential equations of the form d dt ∂L ∂ ˙qi − ∂L ∂qi = τi i = 1, . . . , n (9.11) The order, n, of the system is determined by the number of so-called generalized co- ordinates are required to describe the evolution of the system. We shall see that the n Denavit-Hartenberg joint variables serves as a set of generalized coordinates for an n-link rigid robot. 9.1.2 The General Case Now, consider a system consisting of k particles, with corresponding position vectors r1, . . . , rk. If these particles are free to move about without any restrictions, then it is quite an easyrkr1:::r2 Figure 9.3: System of k particles matter to describe their motion, by noting merely that the rate of change of the momentum of each mass equals the external force applied to it. However, if the motion of the particles is constrained in some fashion, then one must take into account not only the externally applied forces, but also the so-called constraint forces, that is, the forces needed to make the constraints hold. As a simple illustration of this, suppose the system consists of two particles, which are joined by a massless rigid wire of length ℓ. Then the two coordinates r1 and r2 must satisfy the constraint ∥r1 − r2∥ = ℓ, or (r1 − r2) T (r1 − r2) = ℓ 2. (9.12) 9.1. THE EULER-LAGRANGE EQUATIONS 197 If one applies some external forces to each particle, then the particles experience not only these external forces but also the force exerted by the wire, which is along the direction r2 − r1 and of appropriate magnitude. Therefore, in order to analyze the motion of the two particles, we can follow one of two options. First, we can compute, under each set of external forces, what the corresponding constraint force must be in order that the equation above continues to hold. Second, we can search for a method of analysis that does not require us to know the constraint force. Clearly, the second alternative is preferable, since it is in general quite an involved task to compute the constraint forces. The contents of this section are aimed at achieving this second objective. First it is necessary to introduce some terminology. A constraint on the k coordinates r1, . . . , rk is called holonomic if it is an equality constraint of the form gi(r1, . . . , rk) = 0, i = 1, . . . , ℓ (9.13) and nonholonomic otherwise. The constraint (9.12) imposed by connecting two particles by a massless rigid wire is a holonomic constraint. As as example of a nonholonomic constraint, consider a particle moving inside a sphere of radius p centered at the origin of the coordinate system. In this case the coordinate vector r of the particle must satisfy the constraint ∥r∥ ≤ ρ. (9.14) Note that the motion of the particle is unconstrained so long as the particle remains away from the wall of the sphere; but when the particle comes into contact with the wall, it experiences a constraining force. If a system is subjected to ℓ holonomic constraints, then one can think in terms of the constrained system having ℓ fewer degrees-of-freedom than the unconstrained system. In this case it may be possible to express the coordinates of the k particles in terms of n generalized coordinates q1, . . . , qn. In other words, we assume that the coordinates of the various particles, subjected to the set of constraints (9.13), can be expressed in the form ri = ri(q1, . . . , qn), i = 1, . . . , k (9.15) where q1, . . . , qn are all independent. In fact, the idea of generalized coordinates can be used even when there are inﬁnitely many particles. For example, a physical rigid object such as a bar contains an inﬁnity of particles; but since the distance between each pair of particles is ﬁxed throughout the motion of the bar, only six coordinates are suﬃcient to specify completely the coordinates of any particle in the bar. In particular, one could use three position coordinates to specify the location of the center of mass of the bar, and three Euler angles to specify the orientation of the body. To keep the discussion simple, however, we assume in what follows that the number of particles is ﬁnite. Typically, generalized coordinates are positions, angles, etc. In fact, in Chapter ?? we chose to denote the joint variables by the symbols q1, . . . , qn precisely because these joint variables form a set of generalized coordinates for an n-link robot manipulator. 198 CHAPTER 9. DYNAMICS One can now speak of virtual displacements, which are any set, δr1, . . . , δrk, of in- ﬁnitesimal displacements that are consistent with the constraints. For example, consider once again the constraint (9.12) and suppose r1, r2 are perturbed to r1 + δr1, r2 + δr2, re- spectively. Then, in order that the perturbed coordinates continue to satisfy the constraint, we must have (r1 + δr1 − r2 − δr2) T (r1 + δr1 − r2 − δr2) = ℓ 2. (9.16) Now let us expand the above product and take advantage of the fact that the original co- ordinates r1, r2 satisfy the constraint (9.12); let us also neglect quadratic terms in δr1, δr2. This shows that (r1 − r2) T (δr1 − δr2) = 0. (9.17) Thus any perturbations in the positions of the two particles must satisfy the above equa- tion in order that the perturbed positions continue to satisfy the constraint (9.12). Any pair of inﬁnitesimal vectors δr1, δr2 that satisfy (9.17) would constitute a set of virtual displacements for this problem. Now the reason for using generalized coordinates is to avoid dealing with complicated relationships such as (9.17) above. If (9.15) holds, then one can see that the set of all virtual displacements is precisely δri = n∑ j=1 ∂ri ∂qj δqj, i = 1, . . . , k (9.18) where the virtual displacements δq1, . . . , δqn of the generalized coordinates are uncon- strained (that is what makes them generalized coordinates). Next we begin a discussion of constrained systems in equilibrium. Suppose each particle is in equilibrium. Then the net force on each particle is zero, which in turn implies that the work done by each set of virtual displacements is zero. Hence the sum of the work done by any set of virtual displacements is also zero; that is, k∑ i=1 F T i δri = 0 (9.19) where F i is the total force on particle i. As mentioned earlier, the force F i is the sum of two quantities, namely (i) the externally applied force f i, and (ii) the constraint force f (a) i . Now suppose that the total work done by the constraint forces corresponding to any set of virtual displacements is zero, that is, k∑ i=1(f (a) i ) T δri = 0. (9.20) 9.1. THE EULER-LAGRANGE EQUATIONS 199 This will be true whenever the constraint force between a pair of particles is directed along the radial vector connecting the two particles (see the discussion in the next paragraph). Substituting (9.20) into (9.19) results in k∑ i=1 f T i δri = 0. (9.21) The beauty of this equation is that it does not involve the unknown constraint forces, but only the known external forces. This equation expresses the principle of virtual work, which can be stated in words as follows: The work done by external forces corresponding to any set of virtual displacements is zero. Note that the principle is not universally applicable, but requires that (9.20) hold, that is, that the constraint forces do no work. Thus, if the principle of virtual work applies, then one can analyze the dynamics of a system without having to evaluate the constraint forces. It is easy to verify that the principle of virtual work applies whenever the constraint force between a pair of particles acts along the vector connecting the position coordinates of the two particles. In particular, when the constraints are of the form (9.12), the principle applies. To see this, consider once again a single constraint of the form (9.12). In this case the constraint force, if any, must be exerted by the rigid massless wire, and therefore must be directed along the radial vector connecting the two particles. In other words, the force exerted on particle 1 by the wire must be of the form f (a) 1 = c(r1 − r2) (9.22) for some constant c (which could change as the particles move about). By the law of action and reaction, the force exerted on particle 2 by the wire must be just the negative of the above, that is, f (a) 2 = −c(r1 − r2). (9.23) Now the work done by the constraint forces corresponding to a set of virtual displacements is (f (a) 1 ) T δr1 + (f (a) 2 ) T δr2 = c(r1 − r2) T (δr1 − δr2). (9.24) But (9.17) shows that for any set of virtual displacements, the above inner product must be zero. Thus the principle of virtual work applies in a system constrained by (9.12). The same reasoning can be applied if the system consists of several particles, which are pairwise connected by rigid massless wires of ﬁxed lengths, in which case the system is subjected to several constraints of the form (9.12). Now, the requirement that the motion of a body be rigid can be equivalently expressed as the requirement that the distance between any pair of points on the body remain constant as the body moves, that is, as an inﬁnity of constraints of the form (9.12). Thus the principle of virtual work applies whenever rigidity is the only constraint on the motion. There are indeed situations when this principle does not apply, 200 CHAPTER 9. DYNAMICS typically in the presence of magnetic ﬁelds. However, in all situations encountered in this book, we can safely assume that the principle of virtual work is valid. In (9.21), the virtual displacements δri are not independent, so we cannot conclude from this equation that each coeﬃcient F i individually equals zero. In order to apply such reasoning, we must transform to generalized coordinates. Before doing this, we consider systems that are not necessarily in equilibrium. For such systems, D’Alembert’s principle states that, if one introduces a ﬁctitious additional force − ˙pi on particle i for each i, where pi is the momentum of particle i, then each particle will be in equilibrium. Thus, if one modiﬁes (9.19) by replacing F i by F i − ˙pi, then the resulting equation is valid for arbitrary systems. One can then remove the constraint forces as before using the principle of virtual work. This results in the equations k∑ i=1 f T i δri − k∑ i=1 ˙p T i δri = 0. (9.25) The above equation does not mean that each coeﬃcient of δri is zero. For this pur- pose, express each δri in terms of the corresponding virtual displacements of generalized coordinates, as is done in (9.18). Then the virtual work done by the forces f i is given by k∑ i=1 f T i δri = k∑ i=1 n∑ j=1 f T i ∂ri ∂qj δqj = n∑ j=1 ψjδqj (9.26) where ψj = k∑ i=1 f T i ∂ri ∂qj (9.27) is called the j-th generalized force. Note that ψj need not have dimensions of force, just as qj need not have dimensions of length; however, ψjδqj must always have dimensions of work. Now let us study the second summation in (9.25) Since pi = mi ˙ri, it follows that k∑ i=1 ˙p T i δri = k∑ i=1 mi¨rT i δri = k∑ i=1 n∑ j=1 mi¨rT i ∂ri ∂qj δqj. (9.28) Next, using the product rule of diﬀerentiation, we see that k∑ i=1 mi¨rT i ∂ri ∂qj = k∑ i=1 { d dt [ mi ˙rT i ∂ri ∂qj ] − mi ˙rT i d dt [ ∂ri ∂qj ]} . (9.29) Now diﬀerentiate (9.15) using the chain rule; this gives vi = ˙ri = n∑ j=1 ∂ri ∂qj ˙qj. (9.30) 9.1. THE EULER-LAGRANGE EQUATIONS 201 Observe from the above equation that ∂vi ∂ ˙qi = ∂ri ∂qj . (9.31) Next, d dt [ ∂ri ∂qj ] = n∑ ℓ=1 ∂2ri ∂qj∂qℓ ˙qℓ = ∂vi ∂qj (9.32) where the last equality follows from (9.30). Substituting from (9.31) and (9.32) into (9.29) and noting that ˙ri = vi gives k∑ i=1 mi¨rT i ∂ri ∂qj = k∑ i=1 { d dt [ mivT i ∂vi ∂ ˙qj ] − mivT i ∂vi ∂qj } . (9.33) If we deﬁne the kinetic energy K to be the quantity K = k∑ i=1 1 2 mivT i vi (9.34) then the sum above can be compactly expressed as k∑ i=1 mi¨rT i ∂ri ∂qj = d dt ∂K ∂ ˙qj − ∂K ∂qj . (9.35) Now, substituting from (9.35) into (9.28) shows that the second summation in (9.25) is k∑ i=1 ˙p T i δri = n∑ j=1 { d dt ∂K ∂ ˙qj − ∂K ∂qj } δqj. (9.36) Finally, combining (9.36) and (9.26) gives n∑ j=1 { d dt ∂K ∂ ˙qj − ∂K ∂qj − ψj } δqj = 0. (9.37) Now, since the virtual displacements δqj are independent, we can conclude that each coef- ﬁcient in (9.37) is zero, that is, that d dt ∂K ∂ ˙qj − ∂K ∂qj = ψj, j = 1, . . . , n. (9.38) If the generalized force ψj is the sum of an externally applied generalized force and another one due to a potential ﬁeld, then a further modiﬁcation is possible. Suppose there exist functions τj and a potential energy function P (q) such that ψj = − ∂P ∂qj + τj. (9.39) 202 CHAPTER 9. DYNAMICS Then (9.38) can be written in the form d dt ∂L ∂ ˙qj − ∂L ∂qj = τj (9.40) where L = K −P is the Lagrangian and we have recovered the Euler-Lagrange equations of motion as in Equation (9.11). 9.2 General Expressions for Kinetic and Potential Energy In the previous section, we showed that the Euler-Lagrange equations can be used to derive the dynamical equations in a straightforward manner, provided one is able to express the kinetic and potential energy of the system in terms of a set of generalized coordinates. In order for this result to be useful in a practical context, it is therefore important that one be able to compute these terms readily for an n-link robotic manipulator. In this section we derive formulas for the kinetic energy and potential energy of a rigid robot using the Denavit-Hartenberg joint variables as generalized coordinates. To begin we note that the kinetic energy of a rigid object is the sum of two terms: the translational energy obtained by concentrating the entire mass of the object at the center of mass, and the rotational kinetic energy of the body about the center of mass. Referring to Figure 9.4 we attach a coordinate frame at the center of mass (called the body attached frame) as shown. The kinetic energy of the rigid body is then given asrycxczcz0y0x0 Figure 9.4: A General Rigid Body K = 1 2 mvT v + 1 2 ωT Iω. (9.41) where m is the total mass of the object, v and ω are the linear and angular velocity vectors, respectively, and I is a symmetric 3 × 3 matrix called the Inertia Tensor. 9.2. GENERAL EXPRESSIONS FOR KINETIC AND POTENTIAL ENERGY 203 9.2.1 The Inertia Tensor It is understood that the linear and angular velocity vectors, v and ω, respectively, in the above expression for the kinetic energy are expressed in the inertial frame. In this case we know that ω is found from the skew symmetric matrix S(ω) = ˙RRT (9.42) where R is the orientation transformation between the body attached frame and the inertial frame. It is therefore necessary to express the inertia tensor, I, also in the inertial frame in order to compute the triple product ωT Iω. The inertia tensor relative to the inertial reference frame will depend on the conﬁguration of the object. If we denote as I the inertia tensor expressed instead in the body attached frame, then the two matrices are related via a similarity transformation according to I = RIRT (9.43) This is an important observation because the inertia matrix expressed in the body attached frame is a constant matrix independent of the motion of the object and easily computed. We next show how to compute this matrix explicitly. Let the mass density of the object be represented as a function of position, ρ(x, y, z). Then the inertia tensor in the body attached frame is computed as I =   Ixx Ixy Ixz Iyx Iyy Iyz Izx Izy Izz   . (9.44) where Ixx = ∫ ∫ ∫ (y2 + z2)ρ(x, y, z)dx dy dz Iyy = ∫ ∫ ∫ (x 2 + z2)ρ(x, y, z)dx dy dz Izz = ∫ ∫ ∫ (x 2 + y2)ρ(x, y, z)dx dy dz Ixy = Iyx = − ∫ ∫ ∫ xyρ(x, y, z)dx dy dz Ixz = Izx = − ∫ ∫ ∫ xzρ(x, y, z)dx dy dz Iyz = Izy = − ∫ ∫ ∫ yzρ(x, y, z)dx dy dz The integrals in the above expression are computed over the region of space occupied by the rigid body. The diagonal elements of the inertia tensor, Ixx, Iyy, Izz, are called the Principal Moments of Inertia about the x,y,z axes, respectively. The oﬀ diagonal 204 CHAPTER 9. DYNAMICS terms Ixy, Ixz, etc., are called the Cross Products of Inertia. If the mass distribution of the body is symmetric with respect to the body attached frame then the cross products of inertia are identically zero. Example: 9.2 Uniform Rectangular Solid Consider the rectangular solid of length, a, width, b, and height, c, shown in Figure 9.5 and suppose that the density is constant, ρ(x, y, z) = ρ. z c x b y a Figure 9.5: Uniform Rectangular Solid If the body frame is attached at the geometric center of the object, then by symmetry, the cross products of inertia are all zero and it is a simple exercise to compute Ixx = ∫ c/2 −c/2 ∫ b/2 −b/2 ∫ a/2 −a/2(y2 + z2)ρ(x, y, z)dx dy dz = ρ abc 12 (b2 + c 2) Likewise Iyy = ρ abc 12 (a 2 + c 2) ; Izz = ρ abc 12 (a 2 + b2) and the cross products of inertia are zero. 9.2.2 Kinetic Energy for an n-Link Robot Now consider a manipulator consisting of n links. We have seen in Chapter 5 that the linear and angular velocities of any point on any link can be expressed in terms of the Jacobian matrix and the derivative of the joint variables. Since in our case the joint variables are indeed the generalized coordinates, it follows that, for appropriate Jacobian matrices Jvi and Jωi, we have that vi = Jvi(q) ˙q, ωi = Jωi(q) ˙q (9.45) 9.3. EQUATIONS OF MOTION 205 Now suppose the mass of link i is mi and that the inertia matrix of link i, evaluated around a coordinate frame parallel to frame i but whose origin is at the center of mass, equals Ii. Then from (9.41) it follows that the overall kinetic energy of the manipulator equals K = 1 2 ˙qT n∑ i=1 [ miJvi(q) T Jvi(q) + Jωi(q) T Ri(q)IiRi(q) T Jωi(q) ] ˙q (9.46) In other words, the kinetic energy of the manipulator is of the form K = 1 2 ˙qT D(q) ˙q (9.47) where D(q) is a symmetric positive deﬁnite matrix that is in general conﬁguration depen- dent. The matrix D is called the inertia matrix, and in Section 9.4 we will compute this matrix for several commonly occurring manipulator conﬁgurations. 9.2.3 Potential Energy for an n-Link Robot Now consider the potential energy term. In the case of rigid dynamics, the only source of potential energy is gravity. The potential energy of the i-th link can be computed by assuming that the mass of the entire object is concentrated at its center of mass and is given by Pi = gT rcimi. (9.48) where g is vector giving the direction of gravity in the inertial frame and the vector rci gives the coordinates of the center of mass of link i. The total potential energy of the n-link robot is therefore P = n∑ i=1 Pi = n∑ i=1 gT rcimi. (9.49) In the case that the robot contains elasticity, for example, ﬂexible joints, then the potential energy will include terms containing the energy stored in the elastic elements. Note that the potential energy is a function only of the generalized coordinates and not their derivatives, i.e. the potential energy depends on the conﬁguration of the robot but not on its velocity. 9.3 Equations of Motion In this section, we specialize the Euler-Lagrange equations derived in Section 9.1 to the special case when two conditions hold: ﬁrst, the kinetic energy is a quadratic function of the vector ˙q of the form K = 1 2 n∑ i,j dij(q) ˙qi ˙qj := 1 2 ˙qT D(q) ˙q (9.50) 206 CHAPTER 9. DYNAMICS where the n × n “inertia matrix” D(q) is symmetric and positive deﬁnite for each q ∈ Rn, and second, the potential energy P = P (q) is independent of ˙q. We have already remarked that robotic manipulators satisfy this condition. The Euler-Lagrange equations for such a system can be derived as follows. Since L = K − P = 1 2 ∑ i,j dij(q) ˙qi ˙qj − P (q) (9.51) we have that ∂L ∂ ˙qk = ∑ j dkj ˙qj (9.52) and d dt ∂L ∂ ˙qk = ∑ i dkj ¨qj + ∑ j d dt dkj ˙qj = ∑ j dkj ¨qj + ∑ i,j ∂dkj ∂qi ˙qi ˙qj (9.53) Also ∂L ∂qk = 1 2 ∑ i,j ∂dij ∂qk ˙qi ˙qj − ∂P ∂qk . (9.54) Thus the Euler-Lagrange equations can be written ∑ j dkj ¨qj + ∑ i,j { ∂dkj ∂qi − 1 2 ∂dij ∂qk } ˙qi ˙qj − ∂P ∂qk = τk. (9.55) By interchanging the order of summation and taking advantage of symmetry, we can show that ∑ i,j { ∂dkj ∂qi } ˙qi ˙qj = 1 2 ∑ i,j { ∂dkj ∂qi + ∂dki ∂qj } ˙qi ˙qj. (9.56) Hence sumi,j { ∂dkj ∂qi − 1 2 ∂dij ∂qk } ˙qi ˙qj = ∑ i,j 1 2 { ∂dkj ∂qi + ∂dki ∂qj − ∂dij ∂qk } ˙qi ˙qj. (9.57) The terms cijk := 1 2 { ∂dkj ∂qi + ∂dki ∂qj − ∂dij ∂qk } (9.58) 9.4. SOME COMMON CONFIGURATIONS 207 are known as Christoﬀel symbols (of the ﬁrst kind). Note that, for a ﬁxed k, we have cijk = cjik, which reduces the eﬀort involved in computing these symbols by a factor of about one half. Finally, if we deﬁne φk = ∂P ∂qk (9.59) then we can write the Euler-Lagrange equations as ∑ i dkj(q)¨qj + ∑ i,j cijk(q) ˙qi ˙qj + φk(q) = τk, k = 1, . . . , n. (9.60) In the above equation, there are three types of terms. The ﬁrst involve the second deriva- tive of the generalized coordinates. The second are quadratic terms in the ﬁrst derivatives of q, where the coeﬃcients may depend on q. These are further classiﬁed into two types. Terms involving a product of the type ˙q2 i are called centrifugal, while those involving a product of the type ˙qiqj where i ̸= j are called Coriolis terms. The third type of terms are those involving only q but not its derivatives. Clearly the latter arise from diﬀerentiating the potential energy. It is common to write (9.60) in matrix form as D(q)¨q + C(q, ˙q) ˙q + g(q) = τ (9.61) where the k, j-th element of the matrix C(q, ˙q) is deﬁned as ckj = n∑ i=1 cijk(q) ˙qi (9.62) = n∑ i=1 1 2 { ∂dkj ∂qj + ∂dki ∂qj − ∂dij ∂qk } ˙qi. (9.63) Let us examine an important special case, where the inertia matrix is diagonal and independent of q. In this case it follows from (9.58) that all of the Christoﬀel symbols are zero, since each dij is a constant. Moreover, the quantity dkj is nonzero if and only if k = j, so that the Equations 9.60) decouple nicely into the form dkk ¨q − φk(q) = τk, k = 1, . . . , n. (9.64) In summary, the development in this section is very general and applies to any me- chanical system whose kinetic energy is of the form (9.50) and whose potential energy is independent of ˙q. In the next section we apply this discussion to study speciﬁc robot conﬁgurations. 9.4 Some Common Conﬁgurations In this section we apply the above method of analysis to several manipulator conﬁgurations and derive the corresponding equations of motion. The conﬁgurations are progressively more complex, beginning with a two-link cartesian manipulator and ending with a ﬁve-bar linkage mechanism that has a particularly simple inertia matrix. 208 CHAPTER 9. DYNAMICS Two-Link Cartesian Manipulator Consider the manipulator shown in Figure 9.6, consisting of two links and two prismatic q2 q1 Figure 9.6: Two-link cartesian robot. joints. Denote the masses of the two links by m1 and m2, respectively, and denote the displacement of the two prismatic joints by q1 and q2, respectively. Then it is easy to see, as mentioned in Section 9.1, that these two quantities serve as generalized coordinates for the manipulator. Since the generalized coordinates have dimensions of distance, the corresponding generalized forces have units of force. In fact, they are just the forces applied at each joint. Let us denote these by fi, i = 1, 2. Since we are using the joint variables as the generalized coordinates, we know that the kinetic energy is of the form (9.50) and that the potential energy is only a function of q1 and q2. Hence we can use the formulae in Section 9.3 to obtain the dynamical equations. Also, since both joints are prismatic, the angular velocity Jacobian is zero and the kinetic energy of each link consists solely of the translational term. By (5.87) it follows that the velocity of the center of mass of link 1 is given by vc1 = Jvc1 ˙q (9.65) where Jvc1 =   0 0 0 0 1 0   , ˙q = [ ˙q1 ˙q2 ] . (9.66) Similarly, vc2 = Jvc2 ˙q (9.67) where Jvc2 =   0 0 0 1 1 0   . (9.68) 9.4. SOME COMMON CONFIGURATIONS 209 Hence the kinetic energy is given by K = 1 2 ˙qT {m1J T vcJvc1 + m2J T vc2Jvc2} ˙q. (9.69) Comparing with (9.50), we see that the inertia matrix D is given simply by D = [ m1 + m2 0 0 m2 ] . (9.70) Next, the potential energy of link 1 is m1gq1, while that of link 2 is m2gq1, where g is the acceleration due to gravity. Hence the overall potential energy is P = g(m1 + m2)q1. (9.71) Now we are ready to write down the equations of motion. Since the inertia matrix is constant, all Christoﬀel symbols are zero. Further, the vectors φk are given by φ1 = ∂P ∂q1 = g(m1 + m2), φ2 = ∂P ∂q2 = 0. (9.72) Substituting into (9.60) gives the dynamical equations as (m1 + m2)¨q1 + g(m1 + m2) = f1 m2 ¨q2 = f2. (9.73) Planar Elbow Manipulator Now consider the planar manipulator with two revolute joints shown in Figure 9.7. Let y0 x0 x2y2 x1 q1 m1g m2g y1 q2 ℓc2 ℓc1 ℓ2 ℓ1 Figure 9.7: Two-link revolute joint arm. us ﬁx notation as follows: For i = 1, 2, qi denotes the joint angle, which also serves as a 210 CHAPTER 9. DYNAMICS generalized coordinate; mi denotes the mass of link i, ℓi denotes the length of link i; ℓci denotes the distance from the previous joint to the center of mass of link i; and Ii denotes the moment of inertia of link i about an axis coming out of the page, passing through the center of mass of link i. We will make eﬀective use of the Jacobian expressions in Chapter 5 in computing the kinetic energy. Since we are using joint variables as the generalized coordinates, it follows that we can use the contents of Section 9.7. First, vc1 = Jvc1 ˙q (9.74) where, from (5.80), Jvc1 =   −ℓc sin q1 0 ℓc1 cos q1 0 0 0   . (9.75) Similarly, vc2 = Jvc2 ˙q (9.76) where Jvc2 =   −ℓ1 sin q1 − ℓc2 sin(q1 + q2) −ℓc2 sin(q1 + q2) ℓ1 cos q1 + ℓc2 cos(q1 + q2) ℓc2 cos(q1 + q2) 0 0   . (9.77) Hence the translational part of the kinetic energy is 1 2 m1vT c1vc1 + 1 2 m2vT c2vc2 = 1 2 ˙q {m1J T vc1Jvc1 + m2J T vc2Jvc2} ˙q. (9.78) Next we deal with the angular velocity terms. Because of the particularly simple nature of this manipulator, many of the potential diﬃculties do not arise. First, it is clear that ω1 = ˙q1k, ω2 = ( ˙q1 + ˙q2)k (9.79) when expressed in the base inertial frame. Moreover, since ωi is aligned with k, the triple product ωT i Iiωi reduces simply to (I33)i times the square of the magnitude of the angular velocity. This quantity (I33)i is indeed what we have labeled as Ii above. Hence the rotational kinetic energy of the overall system is 1 2 ˙qT {I1 [ 1 0 0 0 ] + I2 [ 1 1 1 1 ]} ˙q (9.80) Now we are ready to form the inertia matrix D(q). For this purpose, we merely have to add the two matrices in (9.78) and (9.80), respectively. Thus D(q) = m1J T vc1Jvc1 + m2J T vc2Jvc2 + [ I1 + I2 I2 I2 I2 ] . (9.81) 9.4. SOME COMMON CONFIGURATIONS 211 Carrying out the above multiplications and using the standard trigonometric identities cos2 θ + sin 2 θ = 1, cos α cos β + sin α sin β = cos(α − β) leads to d11 = m1ℓ 2 c1 + m2(ℓ 2 1 + ℓ 2 c2 + 2ℓ1ℓ 2 c2 + 2ℓ1ℓc2 cos q2) + I1 + I2 d12 = d21 = m2(ℓ 2 c2 + ℓ1ℓc2 cos q2) + I2 d22 = m2ℓ 2 c2 + I2. (9.82) Now we can compute the Christoﬀel symbols using the deﬁnition (9.58). This gives c111 = 1 2 ∂d11 ∂q1 = 0 c121 = c211 = 1 2 ∂d11 ∂q2 = −m2ℓ1ℓc2 sin q2 =: h c221 = ∂d12 ∂q2 − 1 2 ∂d22 ∂q1 = h c112 = ∂d21 ∂q1 − 1 2 ∂d11 ∂q2 = −h (9.83) c122 = c212 = 1 2 ∂d22 ∂q1 = 0 c222 = 1 2 ∂d22 ∂q2 = 0. Next, the potential energy of the manipulator is just the sum of those of the two links. For each link, the potential energy is just its mass multiplied by the gravitational acceleration and the height of its center of mass. Thus P1 = m1gℓc1 sin q1 P2 = m2g(ℓ1 sin q1 + ℓc2 sin(q1 + q2)) P = P1 + P2 = (m1ℓc1 + m2ℓ1)g sin q1 + m2ℓc2g sin(q1 + q2). (9.84) Hence, the functions φk deﬁned in (9.59) become φ1 = ∂P ∂q1 = (m1ℓc1 + m2ℓ1)g cos q1 + m2ℓc2g cos(q1 + q2) (9.85) φ2 = ∂P ∂q2 = m2ℓc2 cos(q1 + q2). (9.86) Finally we can write down the dynamical equations of the system as in (9.60). Substituting for the various quantities in this equation and omitting zero terms leads to d11 ¨q1 + d12 ¨q2 + c121 ˙q1 ˙q2 + c211 ˙q2 ˙q1 + c221 ˙q2 2 + φ1 = τ1 d21 ¨q1 + d22 ¨q2 + c112 ˙q2 1 + φ2 = τ2. (9.87) In this case the matrix C(q, ˙q) is given as C = [ h ˙q2 h ˙q2 + h ˙q1 −h ˙q1 0 ] . (9.88) 212 CHAPTER 9. DYNAMICS Planar Elbow Manipulator with Remotely Driven Link Now we illustrate the use of Lagrangian equations in a situation where the generalized coordinates are not the joint variables deﬁned in earlier chapters. Consider again the planar elbow manipulator, but suppose now that both joints are driven by motors mounted at the base. The ﬁrst joint is turned directly by one of the motors, while the other is turned via a gearing mechanism or a timing belt (see Figure 9.8). In this case one should choose Figure 9.8: Two-link revolute joint arm with remotely driven link. the generalized coordinates as shown in Figure 9.9, because the angle p2 is determined by y0 x0 x2y2 p2 p1 Figure 9.9: Generalized coordinates for robot of Figure 6.4. driving motor number 2, and is not aﬀected by the angle p1. We will derive the dynamical equations for this conﬁguration, and show that some simpliﬁcations will result. Since p1 and p2 are not the joint angles used earlier, we cannot use the velocity Jacobians derived in Chapter 5 in order to ﬁnd the kinetic energy of each link. Instead, we have to 9.4. SOME COMMON CONFIGURATIONS 213 carry out the analysis directly. It is easy to see that vc1 =   −ℓc1 sin p1 ℓc1 cos p1 0   ˙p1, vc2 =   ℓ1 sin p1 −ℓc2 sin p2 ℓ1 cos p1 ℓc2 cos p2 0 0   [ ˙p1 ˙p2 ] (9.89) ω1 = ˙p1k, ω2 = ˙p2k. (9.90) Hence the kinetic energy of the manipulator equals K = 1 2 ˙p T D(p) ˙p (9.91) where D(p) = [ m1ℓ2 c1 + m2ℓ2 1 + I1 m2ℓ1ℓc2 cos(p2 − p1) m2ℓ1ℓc2 cos(p2 − p1) m2ℓ2 c2 + I2. ] (9.92) Computing the Christoﬀel symbols as in (9.58) gives c111 = 1 2 ∂d11 ∂p1 = 0 c121 = c211 = 1 2 ∂d11 ∂p2 = 0 c221 = ∂d12 ∂p2 − 1 2 ∂d22 ∂p1 = −m2ℓ1ℓc2 sin(p2 − p1) (9.93) c112 = ∂d21 ∂p1 − 1 2 ∂d11 ∂p2 = m2ℓ1ℓc2 sin(p2 − p1) c212 = = c122 = 1 2 ∂d22 ∂p1 = 0 c222 = 1 2 ∂d22 ∂p2 = 0. Next, the potential energy of the manipulator, in terms of p1 and p2, equals P = m1gℓc1 sin p1 + m2g(ℓ1 sin p1 + ℓc2 sin p2). (9.94) Hence the gravitational generalized forces are φ1 = (m1ℓc1 + m2ℓ1)g cos p1 φ2 = m2ℓc2g cos p2. Finally, the equations of motion are d11 ¨p1 + d12 ¨p2 + c221 ˙p2 2 + φ1 = τ1 d21 ¨p1 + d22 ¨p2 + c112 ˙p2 1 + φ2 = τ2. (9.95) Comparing (9.95) and (9.87), we see that by driving the second joint remotely from the base we have eliminated the Coriolis forces, but we still have the centrifugal forces coupling the two joints. 214 CHAPTER 9. DYNAMICS Five-Bar Linkage Now consider the manipulator shown in Figure 9.10. We will show that, if the parameters q1 ℓc4 ℓ2 ℓ4 ≡ ℓ2 ℓc1 q2 ℓc3 ℓc2 ℓ3 ≡ ℓ1 Figure 9.10: Five-bar linkage. of the manipulator satisfy a simple relationship, then the equations of the manipulator are decoupled, so that each quantity q1 and q2 can be controlled independently of the other. The mechanism in Figure 9.10 is called a ﬁve-bar linkage. Clearly there are only four bars in the ﬁgure, but in the theory of mechanisms it is a convention to count the ground as an additional linkage, which explains the terminology. In Figure 9.10, it is assumed that the lengths of links and 3 are the same, and that the two lengths marked ℓ2 are the same; in this way the closed path in the ﬁgure is in fact a parallelogram, which greatly simpliﬁes the computations. Notice, however, that the quantities ℓc1, and ℓc3 need not be equal. For example, even though links 1 and 3 have the same length, they need not have the same mass distribution. It is clear from the ﬁgure that, even though there are four links being moved, there are in fact only two degrees-of-freedom, identiﬁed as q1 and q2. Thus, in contrast to the earlier mechanisms studied in this book, this one is a closed kinematic chain (though of a particularly simple kind). As a result, we cannot use the earlier results on Jacobian matrices, and instead have to start from scratch. As a ﬁrst step we write down the coordinates of the 9.4. SOME COMMON CONFIGURATIONS 215 centers of mass of the various links as a function of the generalized coordinates. This gives [ xc1 yc1 ] = [ ℓc1 cos q1 ℓc1 sin q1 ] (9.96) [ xc2 yc2 ] = [ ℓc2 cos q2 ℓc2 sin q2 ] (9.97) [ xc3 yc3 ] = [ ℓc2 cos q1 ℓc2 sin q2 ] + [ ℓc3 cos q1 ℓc3 sin q1 ] (9.98) [ xc4 yc4 ] = [ ℓ1 cos q1 ℓ1 sin q1 ] + [ ℓc4 cos(q2 − π) ℓc4 sin(q2 − π) ] = [ ℓ1 cos q1 ℓ1 sin q1 ] − [ ℓc4 cos q2 ℓc4 sin q2 ] . (9.99) Next, with the aid of these expressions, we can write down the velocities of the various centers of mass as a function of ˙q1 and ˙q2. For convenience we drop the third row of each of the following Jacobian matrices as it is always zero. The result is vc1 = [ −ℓc1 sin q1 0 ℓc1 cos q1 0 ] ˙q vc2 = [ 0 −ℓc2 sin q2 0 ℓc2 cos q2 ] ˙q vc3 = [ −ℓc3 sin q1 −ℓ2 sin q2 ℓc3 cos q1 ℓ2 cos q2 ] ˙q (9.100) vc4 = [ −ℓ1 sin q1 ℓc4 sin q2 ℓ1 cos q1 ℓc4 cos q2 ] ˙q. (9.101) Let us deﬁne the velocity Jacobians Jvci, i = 1, . . . , 4 in the obvious fashion, that is, as the four matrices appearing in the above equations. Next, it is clear that the angular velocities of the four links are simply given by ω1 = ω3 = q1k, ω2 = ω4 = ˙q2k. (9.102) Thus the inertia matrix is given by D(q) = 4∑ i=1 miJ T vcJvc + [ I1 + I3 0 0 I2 + I4 ] . (9.103) If we now substitute from (9.100) into the above equation and use the standard trigonometric identities, when the dust settles we are left with d11(q) = m1ℓ 2 c1 + m3ℓ 2 c3 + m4ℓ 2 1 + I1 + I3 d12(q) = d21(q) = (m3ℓ2ℓc3 − m4ℓ1ℓc4) cos(q2 − q1) (9.104) d22(q) = m2ℓ 2 c2 + m3ℓ 2 2 + m4ℓ 2 c4 + I2 + I4. 216 CHAPTER 9. DYNAMICS Now the thing to note is that if m3ℓ2ℓc3 = m4ℓ1ℓc4 (9.105) then the inertia matrix is diagonal and constant, and as a consequence the dynamical equations will contain neither Coriolis nor centrifugal terms. Turning now to the potential energy, we have that P = g 4∑ i=1 yci = g sin q1(m1ℓc1 + m3ℓc3 + m4ℓ1) (9.106) = g sin q2(m2ℓc2 + m3ℓ2 − m4ℓc4). Hence φ1 = g cos q1(m1ℓc1 + m3ℓc3 + m4ℓ1) φ2 = g cos q2(m2ℓc2 + m3ℓ2 − m4ℓc4). (9.107) Notice that φ1 depends only on q1 but not on q2 and similarly that φ2 depends only on q2 but not on q1. Hence, if the relationship (9.105) is satisﬁed, then the rather complex-looking manipulator in Figure 9.10 is described by the decoupled set of equations d11 ¨q1 + φ1(q1) = τ1, d22 ¨q2 + φ2(q2) = τ2. (9.108) This discussion helps to explain the increasing popularity of the parallelogram conﬁg- uration in industrial robots (e.g., P-50). If the relationship (9.105) is satisﬁed, then one can adjust the two angles q1 and q2 independently, without worrying about interactions between the two angles. Compare this with the situation in the case of the planar elbow manipulators discussed earlier in this section. 9.5 Properties of Robot Dynamic Equations The equations of motion for an n-link robot can be quite formidable especially if the robot contains one or more revolute joints. Fortunately, these equations contain some important structural properties which can be exploited to good advantage in particular for developing control algorithms. We will see this in subsequent chapters. Here we will discuss some of these properties, the most important of which are the so-called skew symmetry property and the related passivity property, and the linearity in the parameters property. For revolute joint robots, the inertia matrix also satisﬁes global bounds that are useful for control design. 9.5. PROPERTIES OF ROBOT DYNAMIC EQUATIONS 217 9.5.1 The Skew Symmetry and Passivity Properties The Skew Symmetry property refers to an important relationship between the inertia ma- trix D(q) and the matrix C(q, ˙q) appearing in (9.61) that will be of fundamental importance for the problem of manipulator control considered in later chapters. Proposition: 9.1 Deﬁne the matrix N (q, ˙q) = ˙D(q) − 2C(q, ˙q). Then N (q, ˙q) is skew symmetric, that is, the components njk of N satisfy njk = −nkj. Proof: Given the inertia matrix D(q), the kj-th component of ˙D(q) is given by the chain rule as ˙dkj = n∑ i=1 ∂dkj ∂qi ˙qi. (9.109) Therefore, the kj-th component of N = ˙D − 2C is given by nkj = ˙dkj − 2ckj (9.110) = n∑ i=1 [ ∂dkj ∂qi − { ∂dkj ∂qi + ∂dki ∂j − ∂dij ∂qk }] ˙qi = n∑ i=1 [ ∂dij ∂qk − ∂dki ∂qj ] ˙qi. Since the inertia matrix D(q) is symmetric, that is, dij = dji, it follows from (9.110) by interchanging the indices k and j that njk = −nkj (9.111) which completes the proof. Related to the skew symmetry property is the so-called Passivity Property which, in the present context, means that there exists a constant, β ≥ 0, such that ∫ T 0 ˙qT (ζ)τ (ζ)dζ ≥ −β, ∀ T > 0. (9.112) The term ˙qT τ has units of power hence, the expression ∫ T 0 ˙qT (ζ)τ (ζ)dζ is the energy pro- duced by the system over the time interval [0, T ]. Passivity therefore means that the amount of energy produced by the system has a lower bound given by −β. The word passivity comes from circuit theory where a passive system according to the above deﬁnition is one that can be built from passive components (resistors, capacitors, inductors). Likewise a passive mechanical system can be built from masses, springs, and dampers. To prove the passivity property, let H be the total energy of the system, i.e., the sum of the kinetic and potential energies, H = 1 2 ˙qT D(q) ˙q + P (q) (9.113) 218 CHAPTER 9. DYNAMICS Then, the derivative ˙H satisﬁes ˙H = ˙qT D(q)¨q + 1 2 ˙qT ˙D(q) ˙q + ˙qT ∂P ∂q (9.114) = ˙qT {τ − C(q, ˙q) − g(q)} + 1 2 ˙qT ˙D(q) ˙q + ˙qT ∂P ∂q (9.115) where we have substituted for D(q)¨q using the equations of motion. Collecting terms and using the fact that g(q) = ∂P ∂q yields ˙H = ˙qT τ + 1 2 ˙qT { ˙D(q) − 2C(q, ˙q)} ˙q (9.116) = ˙qT τ (9.117) the latter equality following from the skew-symmetry property. Integrating both sides of (9.117) with respect to time gives, ∫ T 0 ˙qT (ζ)τ (ζ)dζ = H(T ) − H(0) ≥ −H(0) (9.118) since the total energy H(T ) is non–negative, and the passivity property therefore follows with β = H(0). 9.5.2 Bounds on the Inertia Matrix We have remarked previously that the inertia matrix for an n-link rigid robot is symmetric and positive deﬁnite. For a ﬁxed value of the generalized coordinate q, let 0 < λ1(q) ≤ . . . , ≤ λn(q) denote the n eigenvalues of D(q). These eigenvalues are positive as a consequence of the positive deﬁniteness of D(q). As a result, it can easily be shown that λ1(q)In×n ≤ D(q) ≤ λn(q)In×n (9.119) where In×n denotes the n × n identity matrix. The above inequalities are interpreted in the standard sense of matrix inequalities, namely, if A and B are n × n matrices, then B < A means that the matrix A − B is positive deﬁnite and B ≤ A means that A − B is positive semi-deﬁnite. If all of the joints are revolute then the inertia matrix contains only bounded functions of the joint variables, i.e., terms containing sine and cosine functions. As a result one can ﬁnd constants λm and λM that provide uniform (independent of q) bounds in the inertia matrix λmIn×n ≤ D(q) ≤ λM In×n < ∞ (9.120) 9.5. PROPERTIES OF ROBOT DYNAMIC EQUATIONS 219 9.5.3 Linearity in the Parameters The robot equations of motion are deﬁned in terms of certain parameters, such as link masses, moments of inertia, etc., that must be determined for each particular robot in order, for example, to simulate the equations or to tune controllers. The complexity of the dynamic equations makes the determination of these parameters a diﬃcult task. Fortunately, the equations of motion are linear in these inertia parameters in the following sense. There exists an n × ℓ function, Y (q, ˙q, ¨q), which we assume is completely known, and an ℓ-dimensional vector Θ such that the Euler-Lagrange equations can be written D(q) + C(q, ˙q) ˙q + g(q) =: Y (q, ˙q, ¨q)Θ = τ (9.121) The function, Y (q, ˙q, ¨q), is called the Regressor and Θ is the Parameter vector. The dimension of the parameter space, IR ℓ, i.e., the number of parameters needed to write the dynamics in this way, is not unique. In general, a given rigid body is described by ten parameters, namely, the total mass, the six independent entries of the inertia tensor, and the three coordinates of the center of mass. An n-link robot then has a maximum of 10n independent dynamics parameters. However, since the link motions are constrained and coupled by the joint interconnections, there are actually fewer than 10n independent pa- rameters. Finding a minimal set of parameters that can parametrize the dynamic equations is, however, diﬃcult in general. Example: 9.3 Two Link Planar Robot Consider the two link, revolute joint, planar robot from section 9.4 above. If we group the inertia terms appearing in Equation 9.82 as Θ1 = m1ℓ 2 c1 + m2(ℓ 2 1 + ℓ 2 c2) + I1 + I2 (9.122) Θ2 = m2ℓ1ℓc2 (9.123) Θ3 = m2ℓ1ℓc2 (9.124) then we can write the inertia matrix elements as d11 = Θ1 + 2Θ2 cos(q2) (9.125) d12 = d21 = Θ3 + Θ2 cos(q2) (9.126) d22 = Θ3 (9.127) No additional parameters are required in the Christoﬀel symbols as these are functions of the elements of the inertia matrix. The gravitational torques require additional parameters, in general. Setting Θ4 = m1ℓc1 + m2ℓ1 (9.128) Θ5 = m2ℓ2 (9.129) 220 CHAPTER 9. DYNAMICS we can write the gravitational terms, φ1 and φ2 as φ1 = Θ4g cos(q1) + Θ5g cos(q1 + q2) (9.130) φ2 = Θ5 cos(q1 + q2) (9.131) Substituting these into the equations of motion it is straightforward to write the dynamics in the form (9.121) where Y (q, ˙q, ¨q) = (9.132) [ ¨q1 cos(q2)(2¨q1 + ¨q2) + sin(q2)( ˙q2 1 − 2 ˙q1 ˙q2) ¨q2 g cos(q1) g cos(q1 + q2) 0 cos(q2)¨q1 + sin(q2) ˙q2 1 ¨q2 0 g cos(q1 + q2) ] and the parameter vector Θ is given by Θ =       Θ1 Θ2 Θ3 Θ4 Θ5       =       m1ℓ2 c1 + m2(ℓ2 1 + ℓ2 c2) + I1 + I2 m2ℓ1ℓc2 m2ℓ1ℓc2 m1ℓc1 + m2ℓ1 m2ℓ2       (9.133) Thus, we have parameterized the dynamics using a ﬁve dimensional parameter space. Note that in the absence of gravity, as in a SCARA conﬁguration, only three parameters are needed. 9.6 Newton-Euler Formulation In this section, we present a method for analyzing the dynamics of robot manipulators known as the Newton-Euler formulation. This method leads to exactly the same ﬁnal answers as the Lagrangian formulation presented in earlier sections, but the route taken is quite diﬀerent. In particular, in the Lagrangian formulation we treat the manipulator as a whole and perform the analysis using a Lagrangian function (the diﬀerence between the kinetic energy and the potential energy). In contrast, in the Newton-Euler formulation we treat each link of the robot in turn, and write down the equations describing its linear motion and its angular motion. Of course, since each link is coupled to other links, these equations that describe each link contain coupling forces and torques that appear also in the equations that describe neighboring links. By doing a so-called forward-backward recursion, we are able to determine all of these coupling terms and eventually to arrive at a description of the manipulator as a whole. Thus we see that the philosophy of the Newton-Euler formulation is quite diﬀerent from that of the Lagrangian formulation. At this stage the reader can justly ask whether there is a need for another formulation, and the answer is not clear. Historically, both formulations were evolved in parallel, and each was perceived as having certain advantages. For instance, it was believed at one time that the Newton-Euler formulation is better suited to recursive computation than the 9.6. NEWTON-EULER FORMULATION 221 Lagrangian formulation. However, the current situation is that both of the formulations are equivalent in almost all respects. Thus at present the main reason for having another method of analysis at our disposal is that it might provide diﬀerent insights. In any mechanical system one can identify a set of generalized coordinates (which we introduced in Section 9.1 and labeled q) and corresponding generalized forces (also intro- duced in Section 9.1 and labeled τ ). Analyzing the dynamics of a system means ﬁnding the relationship between q and τ . At this stage we must distinguish between two aspects: First, we might be interested in obtaining closed-form equations that describe the time evolution of the generalized coordinates, such as (9.88) for example. Second, we might be interested in knowing what generalized forces need to be applied in order to realize a par- ticular time evolution of the generalized coordinates. The distinction is that in the latter case we only want to know what time dependent function τ (·) produces a particular tra- jectory q(·) and may not care to know the general functional relationship between the two. It is perhaps fair to say that in the former type of analysis, the Lagrangian formulation is superior while in the latter case the Newton-Euler formulation is superior. Looking ahead to topics beyond the scope of the book, if one wishes to study more advanced mechanical phenomena such as elastic deformations of the links (i.e., if one no longer assumes rigidity of the links), then the Lagrangian formulation is clearly superior. In this section we present the general equations that describe the Newton-Euler formu- lation. In the next section we illustrate the method by applying it to the planar elbow manipulator studied in Section 9.4 and show that the resulting equations are the same as (9.87). The facts of Newtonian mechanics that are pertinent to the present discussion can be stated as follows: 1. Every action has an equal and opposite reaction. Thus, if body 1 applies a force f and torque τ to body 2, then body 2 applies a force of −f and torque of −τ to body 1. 2. The rate of change of the linear momentum equals the total force applied to the body. 3. The rate of change of the angular momentum equals the total torque applied to the body. Applying the second fact to the linear motion of a body yields the relationship d(mv) dt = f (9.134) where m is the mass of the body, v is the velocity of the center of mass with respect to an inertial frame, and f is the sum of external forces applied to the body. Since in robotic applications the mass is constant as a function of time, (9.134) can be simpliﬁed to the familiar relationship ma = f (9.135) where a = ˙v is the acceleration of the center of mass. 222 CHAPTER 9. DYNAMICS Applying the third fact to the angular motion of a body gives d(I0ω0) dt = τ 0 (9.136) where I0 is the moment of inertia of the body about an inertial frame whose origin is at the center of mass, ω0 is the angular velocity of the body, and τ0 is the sum of torques applied to the body. Now there is an essential diﬀerence between linear motion and angular motion. Whereas the mass of a body is constant in most applications, its moment of inertia with respect an inertial frame may or may not be constant. To see this, suppose we attach a frame rigidly to the body, and let I denote the inertia matrix of the body with respect to this frame. Then I remains the same irrespective of whatever motion the body executes. However, the matrix I0 is given by I0 = RIRT (9.137) where R is the rotation matrix that transforms coordinates from the body attached frame to the inertial frame. Thus there is no reason to expect that I0 is constant as a function of time. One possible way of overcoming this diﬃculty is to write the angular motion equation in terms of a frame rigidly attached to the body. This leads to I ˙ω + ω × (Iω) = τ (9.138) where I is the (constant) inertia matrix of the body with respect to the body attached frame, ω is the angular velocity, but expressed in the body attached frame, and τ is the total torque on the body, again expressed in the body attached frame. Let us now give a derivation of (9.138) to demonstrate clearly where the term ω × (Iω) comes from; note that this term is called the gyroscopic term. Let R denote the orientation of the frame rigidly attached to the body w.r.t. the inertial frame; note that it could be a function of time. Then (9.137) gives the relation between I and I0. Now by the deﬁnition of the angular velocity given in Section 2.6, we know that ˙RRT = S(ω0). (9.139) In other words, the angular velocity of the body, expressed in an inertial frame, is given by (9.139). Of course, the same vector, expressed in the body attached frame, is given by ω0 = Rω, ω = RT ω0. (9.140) Hence the angular momentum, expressed in the inertial frame, is h = RIRT Rω = RIω. (9.141) Diﬀerentiating and noting that I is constant gives an expression for the rate of change of the angular momentum, expressed as a vector in the inertial frame: ˙h = ˙RIω + RI ˙ω. (9.142) 9.6. NEWTON-EULER FORMULATION 223 Now S(ω0) = ˙RRT , ˙R = S(ω)R. (9.143) Hence, with respect to the inertial frame, ˙h = S(ω0)RIω + RI ˙ω. (9.144) With respect to the frame rigidly attached to the body, the rate of change of the angular momentum is RT ˙h = RT S(ω0)RIω + I ˙ω = S(RT ω0)Iω + I ˙ω = S(ω)Iω + I ˙ω = ω × (Iω) + I ˙ω. (9.145) This establishes (9.138). Of course we can, if we wish, write the same equation in terms of vectors expressed in an inertial frame. But we will see shortly that there is an advantage to writing the force and moment equations with respect to a frame attached to link i, namely that a great many vectors in fact reduce to constant vectors, thus leading to signiﬁcant simpliﬁcations in the equations. Now we derive the Newton-Euler formulation of the equations of motion of an n-link manipulator. For this purpose, we ﬁrst choose frames 0, . . . , n, where frame 0 is an inertial frame, and frame i is rigidly attached to link i for i ≥ 1. We also introduce several vectors, which are all expressed in frame i. The ﬁrst set of vectors pertain to the velocities and accelerations of various parts of the manipulator. ac,i = the acceleration of the center of mass of link i. ae,i = the acceleration of the end of link i (i.e., joint i + 1). ωi = the angular velocity of frame i w.r.t. frame 0. αi = the angular acceleration of frame i w.r.t. frame 0. The next several vectors pertain to forces and torques. gi = the acceleration due to gravity (expressed in frame i ). f i = the force exerted by link i − 1 on link i. τ i = the torque exerted by link i − 1 on link i. Ri+1 i = the rotation matrix from frame i + 1 to frame i. The ﬁnal set of vectors pertain to physical features of the manipulator. Note that each of the following vectors is constant as a function of q. In other words, each of the vectors 224 CHAPTER 9. DYNAMICS listed here is independent of the conﬁguration of the manipulator. mi = the mass of link i. Ii = the inertia matrix of link i about a frame parallel to frame i whose origin is at the center of mass of link i. ri,ci = the vector from joint i to the center of mass of link i. ri+1,ci = the vector from joint i + 1 to the center of mass of link i. ri,i+1 = the vector from joint i to joint i + 1. Now consider the free body diagram shown in Figure 9.11; this shows link i together with Figure 9.11: Forces and moments on link i. all forces and torques acting on it. Let us analyze each of the forces and torques shown in the ﬁgure. First, f i is the force applied by link i − 1 to link i. Next, by the law of action and reaction, link i + 1 applies a force of −f i+1 to link i, but this vector is expressed in frame i + 1 according to our convention. In order to express the same vector in frame i, it is necessary to multiply it by the rotation matrix Ri+1 i . Similar explanations apply to the torques τ i and −Ri+1 i τ i+1. The force migi is the gravitational force. Since all vectors in Figure 9.11 are expressed in frame i, the gravity vector gi is in general a function of i. Writing down the force balance equation for link i gives f i − Ri+1 i f i+1 + migi = miac,i. (9.146) Next we write down the moment balance equation for link i. For this purpose, it is important to note two things: First, the moment exerted by a force f about a point is given by f × r, where r is the radial vector from the point where the force is applied to the point about which we are computing the moment. Second, in the moment equation below, the vector migi does not appear, since it is applied directly at the center of mass. Thus we have τ i − Ri+1 i τ i+1 + f i × ri,ci − (Ri+1 i f i+1) × ri+1,ci (9.147) = αi + ωi × (Iiωi). 9.6. NEWTON-EULER FORMULATION 225 Now we present the heart of the Newton-Euler formulation, which consists of ﬁnding the vectors f 1, . . . , f n and τ 1, . . . , τ n corresponding to a given set of vectors q, ˙q, ¨q. In other words, we ﬁnd the forces and torques in the manipulator that correspond to a given set of generalized coordinates and ﬁrst two derivatives. This information can be used to perform either type of analysis, as described above. That is, we can either use the equations below to ﬁnd the f and τ corresponding to a particular trajectory q(·), or else to obtain closed-form dynamical equations. The general idea is as follows: Given q, ˙q, ¨q, suppose we are somehow able to determine all of the velocities and accelerations of various parts of the manipulator, that is, all of the quantities ac,i, ωi and αi. Then we can solve (9.146) and (9.147) recursively to ﬁnd all the forces and torques, as follows: First, set f n+l = 0 and τ n+1 = 0. This expresses the fact that there is no link n + 1. Then we can solve (9.146) to obtain f i = Ri+1 i f i+1 + miac,i − migi. (9.148) By successively substituting i = n, n − 1, . . . , 1 we ﬁnd all forces. Similarly, we can solve (9.147) to obtain τ i = (9.149) Ri+1 i τ i+1 − f i × ri,ci + (Ri+1 i f i+1) × ri+1,ci + αi + ωi × (Iiωi). By successively substituting i = nm n − 1, . . . , 1 we ﬁnd all torques. Note that the above iteration is running in the direction of decreasing i. Thus the solution is complete once we ﬁnd an easily computed relation between q, ˙q, ¨q and ac,i, ωi and αi. This can be obtained by a recursive procedure in the direction of increasing i. This procedure is given below, for the case of revolute j oint s; the corresponding relation ships for prismatic joints are actually easier to derive. In order to distinguish between quantities expressed with respect to frame i and the base frame, we use a superscript (0) to denote the latter. Thus, for example, ωi denotes the angular velocity of frame i expressed in frame i, while ω(0) i denotes the same quantity expressed in an inertial frame. Now from Section 2.6 we have that ω(0) i = ω(0) i−1 + zi−1 ˙qi. (9.150) This merely expresses the fact that the angular velocity of frame i equals that of frame i − 1 plus the added rotation from joint i. To get a relation between ωi and ωi−1, we need only express the above equation in frame i rather than the base frame, taking care to account for the fact that ωi and ωi−1 are expressed in diﬀerent frames. This leads to ωi = (Ri i−1) T ωi−1 + bi ˙qi (9.151) where bi = (Ri 0) T zi−1 (9.152) 226 CHAPTER 9. DYNAMICS is the axis of rotation of joint i expressed in frame i. Next let us work on the angular acceleration αi. It is vitally important to note here that αi = (Ri 0) T ˙ω(0) i . (9.153) In other words, αi is the derivative of the angular velocity of frame i, but expressed in frame i. It is not true that αi = ˙ωi! We will encounter a similar situation with the velocity and acceleration of the center of mass. Now we see directly from (9.150) that ˙ω(0) i = ˙ω(0) i−1 + zi−1 ¨qi + ω(0) i × zi−1 ˙qi. (9.154) Expressing the same equation in frame i gives αi = (Ri i−1) T αi−1 + bi ¨qi + ωi × bi ˙qi. (9.155) Now we come to the linear velocity and acceleration terms. Note that, in contrast to the angular velocity, the linear velocity does not appear anywhere in the dynamic equations; however, an expression for the linear velocity is needed before we can derive an expression for the linear acceleration. From Section 5.2, we get that the velocity of the center of mass of link i is given by v(0) c,i = v(0) e,i−1 + ω(0) i × r(0) i,ci. (9.156) To obtain an expression for the acceleration, we use (??), and note that the vector r(0) i,ci is constant in frame i. Thus a (0) c,i = a (0) e,i−1 × r(0) i,ci + ω(0) i × (ω(0) i × r(0) i,ci). (9.157) Now ac,i = (Ri 0) T a (0) c,i . (9.158) Let us carry out the multiplication and use the familiar property R(a × b) = (Ra) × (Rb). (9.159) We also have to account for the fact that ae,i−1 is expressed in frame i − 1 and transform it to frame i. This gives ac,i = (Ri i−1) T ae,i−1 + ˙ωi × ri,ci + ωi × (ωi × ri,ci). (9.160) Now to ﬁnd the acceleration of the end of link i, we can use (9.160) with ri,i+1 replacing ri,ci. Thus ae,i = (Ri i−1) T ae,i−1 + ˙ωi × ri,i+1 + ωi × (ωi × ri,i+1). (9.161) Now the recursive formulation is complete. We can now state the Newton-Euler formulation as follows. 9.7. PLANAR ELBOW MANIPULATOR REVISITED 227 1. Start with the initial conditions ω0 = 0, α0 = 0, ac,0 = 0, ae,0 = 0 (9.162) and solve (9.151), (9.155), (9.161) and (9.160) (in that order!) to compute ωi, αi and ac,i for i increasing from 1 to n. 2. Start with the terminal conditions f n+1 = 0, τ n+1 = 0 (9.163) and use (9.148) and (9.149) to compute f i and τ i for i decreasing from n to 1. 9.7 Planar Elbow Manipulator Revisited In this section we apply the recursive Newton-Euler formulation derived in Section 9.6 to analyze the dynamics of the planar elbow manipulator of ﬁgure 9.8, and show that the Newton-Euler method leads to the same equations as the Lagrangian method, namely (9.87). We begin with the forward recursion to express the various velocities and accelerations in terms of q1, q2 and their derivatives. Note that, in this simple case, it is quite easy to see that ω1 = ˙q1k, α1 = ¨q1k, ω2 = (q1 + q2)k, α2 = (¨q1 + ¨q2)k (9.164) so that there is no need to use (9.151) and (9.155). Also, the vectors that are independent of the conﬁguration are as follows: r1,c1 = ℓc1i, r2,c1 = (ℓ1 − ℓc1)i, r1,2 = ℓ1i (9.165) r2,c2 = ℓc2i, r3,c2 = (ℓ2 − ℓc2)i, r2,3 = ℓ2i. (9.166) Forward Recursion link 1 Using (9.160) with i = 1 and noting that ae,0 = 0 gives ac,1 = ¨q1k × ℓc1i + ˙q1k × ( ˙q1k × ℓc1i) = ℓc1 ¨q1j − ℓc1 ˙q2 1i =   −ℓc1 ˙q2 1 ℓc ¨q1 0   . (9.167) Notice how simple this computation is when we do it with respect to frame 1. Compare with the same computation in frame 0! Finally, we have g1 = −(R1 0) T gj = g   sin q1 − cos q1 0   (9.168) 228 CHAPTER 9. DYNAMICS where g is the acceleration due to gravity. At this stage we can economize a bit by not displaying the third components of these accelerations, since they are obviously always zero. Similarly, the third component of all forces will be zero while the ﬁrst two components of all torques will be zero. To complete the computations for link 1, we compute the acceleration of end of link 1. Clearly, this is obtained from (9.167) by replacing ℓc1 by ℓ1. Thus ae,1 = [ −ℓ1 ˙q2 1 ℓ1 ¨q1 ] . (9.169) Forward Recursion: Link 2 Once again we use (9.160) and substitute for (o2 from (9.164); this yields αc,2 = (R2 1) T ae,1 + [(¨q1 + ¨q2)k] × ℓc2i + ( ˙q1 + ˙q2)k × [( ˙q1 + ˙q2)k × ℓc2i] (9.170) The only quantity in the above equation which is conﬁguration dependent is the ﬁrst one. This can be computed as (R2 1) T ae,1 = [ cos q2 sin q2 − sin q2 cos q2 ] [ −ℓ1 ˙q2 1 ℓ1 ¨q1 ] = [ −ℓ1 ˙q2 1 cos q2 + ℓ1 ¨q1 sin ˙q2 ℓ1 ˙q2 1 sin q2 + ℓ1 ¨q1 cos q2 ] . (9.171) Substituting into (9.170) gives ac,2 = [ −ℓ1 ˙q2 1 cos q2 + ℓ1 ¨q1 sin q2 − ℓc2( ˙q1 + ˙q2)2 ℓ1 ˙q2 1 sin q2 + ℓ1 ¨q1 cos q2 − ℓc2(¨q1 + ¨q2) ] . (9.172) The gravitational vector is g2 = g [ sin(q1 + q2) − cos(q1 + q2) ] . (9.173) Since there are only two links, there is no need to compute ae,2. Hence the forward recursions are complete at this point. Backward Recursion: Link 2 Now we carry out the backward recursion to compute the forces and joint torques. Note that, in this instance, the joint torques are the externally applied quantities, and our ultimate objective is to derive dynamical equations involving the joint torques. First we apply (9.148) with i = 2 and note that f 3 = 0. This results in f 2 = m2ac,2 − m2g2 (9.174) τ 2 = I2α2 + ω2 × (I2ω2) − f 2 × ℓc2i. (9.175) 9.7. PLANAR ELBOW MANIPULATOR REVISITED 229 Now we can substitute for ω2, α2 from (9.164), and for ac,2 from (9.172). We also note that the gyroscopic term equals zero, since both ω2 and I2ω2 are aligned with k. Now the cross product f 2 × ℓc2i is clearly aligned with k and its magnitude is just the second component of f 2. The ﬁnal result is τ 2 = I2(¨q1 + ¨q2)k + [m2ℓ1ℓc2 sin q2 ˙q2 1 + m2ℓ1ℓc2 cos q2 ¨q1 +m2ℓ 2 c2(¨q1 + ¨q2) + m)2ℓc2g cos(q1 + q2)]k (9.176) Since τ 2 = τ2k, we see that the above equation is the same as the second equation in (9.88). Backward Recursion: Link 1 To complete the derivation, we apply (9.148) and (9.149) with i = 1. First, the force equation is f 1 = m1ac,1 + R2 1f 2 − m1g1 (9.177) and the torque equation is τ 1 = R2 1τ 2 − f 1 × ℓc,1i − (R2 1f 2) × (ℓ1 − ℓc1)i (9.178) +I1α1 + ω1 × (I1ω1). Now we can simplify things a bit. First, R2 1τ2 = τ2, since the rotation matrix does not aﬀect the third components of vectors. Second, the gyroscopic term is the again equal to zero. Finally, when we substitute for f 1 from (9.177) into (9.178), a little algebra gives τ 1 = τ 2 − m1ac,1 × ℓc1i + m1g1 × ℓc1i − (R2 1f 2) (9.179) ×ℓ1i + I1i + I1α1. Once again, all these products are quite straightforward, and the only diﬃcult calculation is that of R2 1f 2. The ﬁnal result is: τ 1 = τ 2 + m1ℓ 2 c1 + m1ℓc1g cos q1 + m2ℓ1g cos q1 + I1 ¨q1 (9.180) +m2ℓ 2 1 ¨q1 − m1ℓ1ℓc2( ˙q1 + ˙q2) 2 sin q2 + m2ℓ1ℓc2(¨q1 + ¨q2) cos q2. If we now substitute for τ 1 from (9.176) and collect terms, we will get the ﬁrst equation in (9.88); the details are routine and are left to the reader. 230 CHAPTER 9. DYNAMICS Chapter 10 INDEPENDENT JOINT CONTROL 10.1 Introduction The control problem for robot manipulators is the problem of determining the time history of joint inputs required to cause the end-eﬀector to execute a commanded motion. The joint inputs may be joint forces and torques, or they may be inputs to the actuators, for example, voltage inputs to the motors, depending on the model used for controller design. The commanded motion is typically speciﬁed either as a sequence of end-eﬀector positions and orientations, or as a continuous path. There are many control techniques and methodologies that can be applied to the control of manipulators. The particular control method chosen as well as the manner in which it is implemented can have a signiﬁcant impact on the performance of the manipulator and consequently on the range of its possible applications. For example, continuous path tracking requires a diﬀerent control architecture than does point-to-point control. In addition, the mechanical design of the manipulator itself will inﬂuence the type of control scheme needed. For example, the control problems encountered with a cartesian manipulator are fundamentally diﬀerent from those encountered with an elbow type ma- nipulator. This creates a so-called hardware/software trade-oﬀ between the mechanical structure of the system and the architecture/programming of the controller. Technological improvements are continually being made in the mechanical design of robots, which in turn improves their performance potential and broadens their range of applications. Realizing this increased performance, however, requires more sophisticated approaches to control. One can draw an analogy to the aerospace industry. Early aircraft were relatively easy to ﬂy but possessed limited performance capabilities. As performance increased with technological advances so did the problems of control to the extent that the latest vehicles, such as the space shuttle or forward swept wing ﬁghter aircraft, cannot be ﬂown without sophisticated computer control. As an illustration of the eﬀect of the mechanical design on the control problem, compare 231 232 CHAPTER 10. INDEPENDENT JOINT CONTROL a robot actuated by permanent magnet DC motors with gear reduction to a direct-drive robot using high-torque motors with no gear reduction. In the ﬁrst case, the motor dynamics are linear and well understood and the eﬀect of the gear reduction is largely to decouple the system by reducing the inertia coupling among the joints. However, the presence of the gears introduces friction, drive train compliance and backlash. In the case of a direct-drive robot, the problems of backlash, friction, and compliance due to the gears are eliminated. However, the coupling among the links is now signiﬁcant, and the dynamics of the motors themselves may be much more complex. The result is that in order to achieve high performance from this type of manipulator, a diﬀerent set of control problems must be addressed. In this chapter we consider the simplest type of control strategy, namely, independent joint control. In this type of control each axis of the manipulator is controlled as a single- input/single-output (SISO) system. Any coupling eﬀects due to the motion of the other links is treated as a disturbance. We assume, in this chapter, that the reader has had an introduction to the theory of feedback control systems up to the level of say, Kuo [?]. The basic structure of a single-input/single-output feedback control system is shown in Figure 10.1. The design objective is to choose the compensator in such a way that the plant Disturbance +\u000f\u000f Reference trajectory +//⊕ // Compensator // Power ampliﬁer +// ⊕ // Plant Output // ooSensor −OO Figure 10.1: Basic structure of a feedback control system. output “tracks” or follows a desired output, given by the reference signal. The control signal, however, is not the only input acting on the system. Disturbances, which are really inputs that we do not control, also inﬂuence the behavior of the output. Therefore, the controller must be designed, in addition, so that the eﬀects of the disturbances on the plant output are reduced. If this is accomplished, the plant is said to ”reject” the disturbances. The twin objectives of tracking and disturbance rejection are central to any control methodology. 10.2 Actuator Dynamics In Chapter 9 we obtained the following set of diﬀerential equations describing the motion of an n degree of freedom robot (cf. Equation (9.61)) D(q)¨q + C(q, ˙q) ˙q + g(q) = τ (10.1) It is important to understand exactly what this equation represents. Equation (10.1) rep- resents the dynamics of an interconnected chain of ideal rigid bodies, supposing that there 10.2. ACTUATOR DYNAMICS 233 is a generalized force τ acting at the joints. We can assume that the k-th component τk of the generalized force vector τ is a torque about the joint axis zk−1 if joint k is revolute and is a force along the joint axis zk−1 if joint k is prismatic. This generalized force is produced by an actuator, which may be electric, hydraulic or pneumatic. Although (10.1) is extremely complicated for all but the simplest manipulators, it nevertheless is an ide- alization, and there are a number of dynamic eﬀects that are not included in (10.1). For example, friction at the joints is not accounted for in these equations and may be signiﬁcant for some manipulators. Also, no physical body is completely rigid. A more detailed analysis of robot dynamics would include various sources of ﬂexibility, such as elastic deformation of bearings and gears, deﬂection of the links under load, and vibrations. In this section we are interested mainly in the dynamics of the actuators producing the generalized force τ . We treat only the dynamics of permanent magnet DC-motors, as these are common for use in present-day robots. A DC-motor basically works on the principle that a current carrying conductor in a magnetic ﬁeld experiences a force F = i × φ, where φ is the magnetic ﬂux and i is the current in the conductor. The motor itself consists of a ﬁxed stator and a movable rotor that rotates inside the stator, as shown in Figure 10.2. If the stator produces a radial magnetic Figure 10.2: Cross-sectional view of a surface-wound permanent magnet DC motor. ﬂux φ and the current in the rotor (also called the armature) is i then there will be a torque on the rotor causing it to rotate. The magnitude of this torque is τm = K1φia (10.2) where τm is the motor torque (N − m), φ is the magnetic ﬂux (webers), ia is the armature current (amperes), and K1 is a physical constant. In addition, whenever a conductor moves in a magnetic ﬁeld, a voltage Vb is generated across its terminals that is proportional to the velocity of the conductor in the ﬁeld. This voltage, called the back emf, will tend to oppose the current ﬂow in the conductor. Thus, in addition to the torque τm in (10.2), we have the back emf relation Vb = K2φωm (10.3) 234 CHAPTER 10. INDEPENDENT JOINT CONTROL where Vb denotes the back emf (Volts), ωm is the angular velocity of the rotor (rad/sec), and K2 is a proportionality constant. DC-motors can be classiﬁed according to the way in which the magnetic ﬁeld is produced and the armature is designed. Here we discuss only the so-called permanent magnet motors whose stator consists of a permanent magnet. In this case we can take the ﬂux, φ, to be a constant. The torque on the rotor is then controlled by controlling the armature current, ia. Consider the schematic diagram of Figure 10.3 where + L Vb + R V (t) φia τm, θm, τℓ Figure 10.3: Circuit diagram for armature controlled DC motor. V = armature voltage L = armature inductance R = armature resistance Vb = back emf ia = armature current θm = rotor position (radians) τm = generated torque τℓ = load torque φ = magnetic ﬂux due to stator The diﬀerential equation for the armature current is then L dia dt + Ria = V − Vb. (10.4) Since the ﬂux φ is constant the torque developed by the motor is τm = K1φia = Kmia (10.5) where Km is the torque constant in N − m/amp. From (10.3) we have Vb = K2φωm = Kbωm = Kb dθm dt (10.6) where Kb is the back emf constant. 10.2. ACTUATOR DYNAMICS 235 Figure 10.4: Typical torque-speed curves of a DC motor. We can determine the torque constant of the DC motor using a set of torque-speed curves as shown in Figure 10.4 for various values of the applied voltage V . When the motor is stalled, the blocked-rotor torque at the rated voltage is denoted τ0. Using Equation (10.4) with Vb = 0 and dia/dt = 0 we have Vr = Ria (10.7) = Rτ0 Km . Therefore the torque constant is Km = Rτ0 Vr . (10.8) The remainder of the discussion refers to Figure 10.5 consisting of the DC-motor in series Figure 10.5: Lumped model of a single link with actuator/gear train. with a gear train with gear ratio r : 1 and connected to a link of the manipulator. The gear 236 CHAPTER 10. INDEPENDENT JOINT CONTROL ratio r typically has values in the range 20 to 200 or more. Referring to Figure 10.5, we set Jm = Ja + Jg, the sum of the actuator and gear inertias. The equation of motion of this system is then Jm d2θm dt2 + Bm dθm dt = τm − τℓ/r (10.9) = Kmia − τℓ/r (10.10) the latter equality coming from (10.5). In the Laplace domain the three equations (10.4), (10.6) and (10.9) may be combined and written as (Ls + R)Ia(s) = V (s) − KbsΘm(s) (10.11) (Jms 2 + Bms)Θm(s) = KiIa(s) − τℓ/r(s). (10.12) The block diagram of the above system is shown in Figure 10.6. The transfer function from τl/r −\u000f\u000fV (s) +// ⊕ // 1 Ls+R Ia(s) // Ki +// ⊕ // 1 Jms+Bm // oo 1 s θm(s) // Kb −OO Figure 10.6: Block diagram for a DC motor system. V (s) to Θm(s) is then given by (with τℓ = 0) Θm(s) V (s) = Km s [(Ls + R)(Jms + Bm) + KbKm] . (10.13) The transfer function from the load torque τℓ/r to Θm is given by (with V = 0) Θm(s) τℓ(s) = −(Ls + R) s [(Ls + R)(Jms + Bm) + KbKm] . (10.14) Frequently it is assumed that the “electrical time constant” L R is much smaller than the “mechanical time constant” Jm Bm . This is a reasonable assumption for many electro- mechanical systems and leads to a reduced order model of the actuator dynamics. If we now divide numerator and denominator of (10.11) by R and neglect the electrical time constant by setting L R equal to zero, the transfer function between Θm and V becomes (again, with τℓ = 0) Θm(s) V (s) = Km/R s(Jms + Bm + KbKm/R) . (10.15) 10.2. ACTUATOR DYNAMICS 237 Similarly the transfer function between Θm and τℓ/r is Θm(s) τℓ(s) = − 1 s(Jm(s) + Bm + KbKm/R) . (10.16) In the time domain Equations (10.15) and (10.16) represent, by superposition, the second order diﬀerential equation Jm ¨θm(t) + (Bm + KbKm/R) ˙θm(t) = (Km/R)V (t) − τℓ(t)/r (10.17) The block diagram corresponding to the reduced order system (10.17) is shown in Fig- ure 10.7. τl/r −\u000f\u000fV (s) +// ⊕ Im // Ki/R +// ⊕ // 1 Jms+Bm // oo 1 s θm(s) // Kb −OO Figure 10.7: Block diagram for reduced order system. If the output side of the gear train is directly coupled to the link, then the joint variables and the motor variables are related by θmk = rkqk ; k = 1, . . . , n (10.18) where rk is the k-th gear ratio. Similarly, the joint torques τk given by (10.1) and the actuator load torques τℓk are related by τℓk = τk ; k = 1, . . . , n. (10.19) However, in manipulators incorporating other types of drive mechanisms such as belts, pulleys, chains, etc., θmk need not equal rkqk. In general one must incorporate into the dynamics a transformation between joint space variables and actuator variables of the form qk = fk(θs1, . . . , θsn) ; τℓk = fk(τ1, . . . , τn) (10.20) where θsk = θmk /rk. Example 7.2.1 Consider the two link planar manipulator shown in Figure 10.8, whose actuators are both located on link 1. In this case we have, q1 = θs1 ; q2 = θs1 + θs2. (10.21) 238 CHAPTER 10. INDEPENDENT JOINT CONTROL Figure 10.8: Two-link manipulator with remotely driven link. Similarly, the joint torques τi and the actuator load torques τℓ, are related by τℓ1 = τ1 ; τℓ2 = τ1 + τ2. (10.22) The inverse transformation is then θs1 = q1 ; θs2 = q2 − q1 (10.23) and τ1 = τℓ1 ; τ2 = τℓ2 − τℓ1. (10.24) 10.3 Set-Point Tracking In this section we discuss set-point tracking using a PD or PID compensator. This type of control is adequate for applications not involving very fast motion, especially in robots with large gear reduction between the actuators and the links. The analysis in this section follows typical engineering practice rather than complete mathematical rigor. For the following discussion, assume for simplicity that qk = θsk = θmk /rk and (10.25) τℓk = τk. Then, for k = 1, . . . , n, the equations of motion of the manipulator can be written as n∑ j=1 djk(q)¨qj + n∑ i,j=1 cijk(q) ˙qiqj + gk(q) = τk (10.26) Jmk ¨θmk + (Bmk + Kbk Kmk /Rk) ˙θmk = Kmk /RkVk − τk/rk (10.27) 10.3. SET-POINT TRACKING 239 Combining these equations yields (Jmk + 1 r2 k dkk(q))¨θmk + (Bmk + Kbk Kmk /Rk) ˙θmk = Kmk /RkVk − dk (10.28) where dk is deﬁned by dk := 1 rk ∑ j̸=k ¨qj + ∑ i,j cijk ˙qi ˙qj + gk. (10.29) Note that the coeﬃcient of ¨θmk in the above expression is a nonlinear function of the manipulator conﬁguration, q. However, large gear reduction, i.e. large values of rk, mitigates the inﬂuence of this term and one often deﬁnes a constant average, or eﬀective inertia Jef fk as an approximation of the exact expression Jmk + 1 r2 k dkk(q). If we further deﬁne Bef fk = Bmk + Kbk Kmk /Rk and uk = Kmk /RkVk (10.30) we may write (10.27) as Jef fk ¨θmk + Bef fk ˙θmk = uk − dk (10.31) The advantage of this model is its simplicity since the motor dynamics represented by (10.27) are linear. The eﬀect of the nonlinear coupling terms is treated as a disturbance dk, which may be small for large gear reduction provided the velocities and accelerations of the joints are also small. Henceforth we suppress the subscript k representing the particular joint and represent (10.31) in the Laplace domain by the block diagram of Figure 10.9. The set-point tracking d −\u000f\u000fu +//⊕ // 1 Jef f s+Bef f // 1 s θm// Figure 10.9: Block diagram of simpliﬁed open loop system with eﬀective inertia and damp- ing. problem is now the problem of tracking a constant or step reference command θd. 10.3.1 PD Compensator As a ﬁrst illustration we choose a so-called PD-compensator. The resulting closed loop system is shown in Figure 10.10. The input U (s) is given by U (s) = Kp(Θ d(s) − Θ(s)) − KDsΘ(s) (10.32) where Kp, KD are the proportional (P) and derivative (D) gains, respectively. 240 CHAPTER 10. INDEPENDENT JOINT CONTROL d −\u000f\u000fθd m +//⊕ // KP +//⊕ // K +//⊕ // 1 Jef f s+Bef f // oo 1 s θm// −OO KD −OO Figure 10.10: Closed loop system with PD-control. Taking Laplace transforms of both sides of (10.31) and using the expression (10.32) for the feedback control V (s), leads to the closed loop system Θm(s) = KKp Ω(s) Θ d(s) − 1 Ω(s) D(s) (10.33) where Ω(s) is the closed loop characteristic polynomial Ω(s) = Jef f s 2 + (Bef f + KKD)s + KKp. (10.34) The closed loop system will be stable for all positive values of Kp and KD and bounded disturbances, and the tracking error is given by E(s) = Ωd(s) − Θm(s) (10.35) = Jef f s2 + (Bef f + KKD)s Ω(s) Θ d(s) + 1 Ω(s) D(s). (10.36) For a step reference input Θ d(s) = Ωd s (10.37) and a constant disturbance D(s) = D s (10.38) it now follows directly from the ﬁnal value theorem [4] that the steady state error ess satisﬁes ess = lim s→0 sE(s) (10.39) = −D KKp . (10.40) Since the magnitude D of the disturbance is proportional to the gear reduction 1 r we see that the steady state error is smaller for larger gear reduction and can be made arbitrarily 10.3. SET-POINT TRACKING 241 small by making the position gain Kp large, which is to be expected since the system is Type 1. We know, of course, from (10.29) that the disturbance term D(s) in (10.35) is not con- stant. However, in the steady state this disturbance term is just the gravitational force acting on the robot, which is constant. The above analysis therefore, while only approx- imate, nevertheless gives a good description of the actual steady state error using a PD compensator assuming stability of the closed loop system. 10.3.2 Performance of PD Compensators For the PD-compensator given by (10.32) the closed loop system is second order and hence the step response is determined by the closed loop natural frequency ω and damping ratio ζ. Given a desired value for these quantities, the gains KD and Kp can be found from the expression s 2 + (Bef f + KKD) Jef f s + KKp Jef f = s 2 + 2ζωs + ω2 (10.41) as Kp = ω2Jef f K , KD = 2ζωJef f − Bef f K . (10.42) It is customary in robotics applications to take ζ = 1 so that the response is critically damped. This produces the fastest non-oscillatory response. In this context ω determines the speed of response. Example 10.1 Consider the second order system of Figure 10.11. The closed loop char- d +\u000f\u000fθd +//⊕ // KP + KDs +// ⊕ // 1 s(s+1) θ// − OO Figure 10.11: System of Example 7.3.1. acteristic polynomial is p(s) = s 2 + (1 + KD)s + Kp. (10.43) Suppose θd = 10 and there is no disturbance (d = 0). With ζ = 1, the required PD gains for various values of ω are shown in Table 10.1. The corresponding step responses are shown in Figure 10.12. Now suppose that there is a constant disturbance d = 40 acting on the system. The response of the system with the PD gains of Table 10.1 are shown in Figure 10.13. We see that the steady state error due to the disturbance is smaller for large gains as expected. ⋄ 242 CHAPTER 10. INDEPENDENT JOINT CONTROL Table 10.1: . Ω KP KD 4 16 7 8 64 15 12 144 23 0 0.2 0.4 0.6 0.8 1 1.2 1.4 1.6 1.8 2 0 2 4 6 8 10 12 Time (sec)Step Response ω = 4 ω = 8 ω = 12 Figure 10.12: Critically damped second order step responses. 10.3.3 PID Compensator In order to reject a constant disturbance using PD control we have seen that large gains are required. By using integral control we may achieve zero steady state error while keeping the gains small. Thus, let us add an integral term KI s to the above PD compensator. This leads to the so-called PID control law, as shown in Figure 10.14. The system is now Type 2 and the PID control achieves exact steady tracking of step (and ramp) inputs while rejecting step disturbances, provided of course that the closed loop system is stable. With the PID compensator C(s) = Kp + KDs + KI s (10.44) the closed loop system is now the third order system Θm(s) = (KDs2 + Kps + KI ) Ω2(s) Θ d(s) − rs Ω2(s) D(s) (10.45) where Ω2 = Jef f s 3 + (Bef f + KKD)s 2 + KKps + KKI . (10.46) Applying the Routh-Hurwitz criterion to this polynomial, it follows that the closed loop 10.3. SET-POINT TRACKING 243 0 0.2 0.4 0.6 0.8 1 1.2 1.4 1.6 1.8 2 0 2 4 6 8 10 12 Time (sec)Step Response ω = 4 ω = 8 ω = 12 reference Figure 10.13: Second order system response with disturbance added. KI s +\u000f\u000f d −\u000f\u000fθd +//⊕ // // KP +//⊕ +//⊕ // 1 Jef f s+Bef f // oo 1 s θm// −OO KD −OO Figure 10.14: Closed loop system with PID control. system is stable if the gains are positive, and in addition, KI < (Bef f + KKD)Kp Jef f . (10.47) Example 10.2 To the system of Example 7.3.1 we have added a disturbance and an integral control term in the compensator. The step responses are shown in Figure 10.17. We see that the steady state error due to the disturbance is removed. ⋄ 10.3.4 Saturation In theory, one could achieve arbitrarily fast response and arbitrarily small steady state error to a constant disturbance by simply increasing the gains in the PD or PID compensator. In practice, however, there is a maximum speed of response achievable from the system. Two major factors, heretofore neglected, limit the achievable performance of the system. The ﬁrst factor, saturation, is due to limits on the maximum torque (or current) input. Many manipulators, in fact, incorporate current limiters in the servo-system to prevent damage that might result from overdrawing current. The second eﬀect is ﬂexibility in the 244 CHAPTER 10. INDEPENDENT JOINT CONTROL 0 0.5 1 1.5 2 2.5 3 0 2 4 6 8 10 12 Time (sec)Step Response Response With Integral Control ω = 4 ω = 8 Figure 10.15: Response with integral control action. motor shaft and/or drive train. We illustrate the eﬀects of saturation below and drive train ﬂexibility in section 10.5. Example 10.3 Consider the block diagram of Figure 10.16, where the saturation function Saturation Plant θd +//⊕ // KP + KDs // −50 +50 // 1 s(s+1) θ// −OO Figure 10.16: Second order system with input saturation. represents the maximum allowable input. With PID control and saturation the response is below. ⋄ The second eﬀect to consider is the joint ﬂexibility. Let kr be the eﬀective stiﬀness at the joint. The joint resonant frequency is then ω4 = √kr/Jef f . It is common engineering practice to limit ω in (10.42) to no more than half of ωr to avoid excitation of the joint resonance. We will discuss the eﬀects of the joint ﬂexibility in more detail in section 10.5. These examples clearly show the limitations of PID-control when additional eﬀects such as input saturation, disturbances, and unmodeled dynamics must be considered. 10.4 Feedforward Control and Computed Torque In this section we introduce the notion of feedforward control as a method to track time varying trajectories and reject time varying disturbances. Suppose that r(t) is an arbitrary reference trajectory and consider the block diagram 10.4. FEEDFORWARD CONTROL AND COMPUTED TORQUE 245 0 0.5 1 1.5 2 2.5 3 0 2 4 6 8 10 12 Time (sec)Step Response PD Control with Saturation Figure 10.17: Response with Saturation and Integral Control Action of Figure 10.18, where G(s) represents the forward transfer function of a given system and F (s) +\u000f\u000fr +// // ⊕ // H(s) +//⊕ // G(s) y // −OO Figure 10.18: Feedforward control scheme. H(s) is the compensator transfer function. A feedforward control scheme consists of adding a feedforward path with transfer function F (s) as shown. Let each of the three transfer functions be represented as ratios of polynomials G(s) = q(s) p(s) H(s) = c(s) d(s) F (s) = a(s) b(s) (10.48) We assume that G(s) is strictly proper and H(s) is proper. Simple block diagram manipu- lation shows that the closed loop transfer function T (s) = Y (s) R(s) is given by (Problem 7-9) T (s) = q(s)(c(s)b(s) + a(s)d(s)) b(s)(p(s)d(s) + q(s)c(s)) . (10.49) The closed loop characteristic polynomial of the system is then b(s)(p(s)d(s) + q(s)c(s)). For stability of the closed loop system therefore we require that the compensator H(s) and the feedforward transfer function F (s) be chosen so that the polynomials p(s)d(s)+ q(s)c(s) and b(s) are Hurwitz. This says that, in addition to stability of the closed loop system the feedforward transfer function F (s) must itself be stable. If we choose the feedforward transfer function F (s) equal to 1 G(s)′ the inverse of the forward plant, that is, a(s) = p(s) and b(s) = q(s), then the closed loop system becomes q(s)(p(s)d(s) + q(s)c(s))Y (s) = q(s)(p(s)d(s) + q(s)c(s))R(s) (10.50) 246 CHAPTER 10. INDEPENDENT JOINT CONTROL or, in terms of the tracking error E(s) = R(s) − Y (s), q(s)(p(s)d(s) + q(s)c(s))E(s) = 0. (10.51) Thus, assuming stability, the output y(t) will track any reference trajectory r(t). Note that we can only choose F (s) in this manner provided that the numerator polynomial q(s) of the forward plant is Hurwitz, that is, as long as all zeros of the forward plant are in the left half plane. Such systems are called minimum phase. If there is a disturbance D(s) entering the system as shown in Figure 10.19, then it is F (s) ˙˙6666666 D(s) +\u000f\u000fr +// // ⊕ // H(s) + + //⊕ // G(s) y // −OO Figure 10.19: Feedforward control with disturbance. easily shown that the tracking error E(s) is given by E(s) = q(s)d(s) p(s)d(s) + q(s)c(s) D(s). (10.52) We have thus shown that, in the absence of disturbances the closed loop system will track any desired trajectory r(t) provided that the closed loop system is stable. The steady state error is thus due only to the disturbance. Let us apply this idea to the robot model of Section ??. Suppose that θd(t) is an arbitrary trajectory that we wish the system to track. In this case we have from (10.31) G(s) = K Jef f s2+Bef f s together with a PD compensator H(s) = Kp + KDs. The resulting system is shown in Figure 10.20. Note that G(s) has no zeros at all and hence is minimum phase. Jef f s2 + Bef f s ˆˆ44444444 rD(s) −\u000f\u000fθd +// // ⊕ // KP + KDs + + // ⊕ // 1 Jef f s2+Bef f s θm// − OO Figure 10.20: Feedforward compensator for second order system. Note also that G(s)−1 is not a proper rational function. However, since the derivatives of the reference trajectory θd are known and precomputed, the implementation of the above scheme does not require diﬀerentiation of an actual signal. It is easy to see from (10.52) that the steady state error to a step disturbance is now given by the same expression (10.39) independent of the reference trajectory. As before, a PID compensator would result in zero 10.4. FEEDFORWARD CONTROL AND COMPUTED TORQUE 247 steady state error to a step disturbance. In the time domain the control law of Figure 10.20 can be written as V (t) = Jef f K ¨θd + Bef f K ˙θd + KD( ˙θd − ˙θm) + Kp(θd − θm) (10.53) = f (t) + KD ˙e(t) + Kpe(t) (10.54) where f (t) is the feedforward signal f (t) = Jef f K ¨θd + Bef f K ˙θd (10.55) and e(t) is the tracking error θd(t) − θ(t). Since the forward plant equation is Jef f ¨θm + Bef f ˙θm = KV (t) − rd(t) the closed loop error e(t) = θm − θd satisﬁes the second order diﬀerential equation Jef f ¨e + (Bef f + KKD) ˙e + KKpe(t) = −rd(t). (10.56) Remark 7.6.1 We note from (10.56) that the characteristic polynomial of the closed loop system is iden- tical to (10.34). The system now however is written in terms of the tracking errore(t). Therefore, assuming that the closed loop system is stable, the tracking error will approach zero asymptotically for any desired joint space trajectory in the absence of disturbances, that is, if d = 0. Computed Torque Disturbance Cancellation We see that the feedforward signal (10.55) results in asymptotic tracking of any trajectory in the absence of disturbances but does not otherwise improve the disturbance rejection properties of the system. However, although the term d(t) in (10.56) represents a distur- bance, it is not completely unknown since d satisﬁes (10.29). Thus we may consider adding to the above feedforward signal, a term to anticipate the eﬀects of the disturbance d(t). Consider the diagram of Figure 10.21. Given a desired trajectory, then we superimpose, as shown, the term dd := ∑ djk(qd)¨qd j + ∑ cijk(qd) ˙qd i ˙qd j + gk(qd) (10.57) since dd has units of torque, the above feedforward disturbance cancellation control is called the method of computed torque. The expression (10.57) thus compensates in a feedforward manner the nonlinear coupling inertial, coriolis, centripetal, and gravitational forces arising due to the motion of the manipulator. Although the diﬀerence ∆d := dd − d is zero only in the ideal case of perfect tracking (θ = θd) and perfect computation of (10.57), in practice, ∆d can be expected to be smaller than d and hence the computed torque has 248 CHAPTER 10. INDEPENDENT JOINT CONTROL qd 1..n ˙qd 1..n ¨qd 1..n    // Computed torque (7.?.?) + \u000f\u000f Jef f s2 + Bef f s ˆˆ44444444 rD(s) −\u0004\u0004 θd +// // ⊕ // KP + KDs + + //⊕ // 1 Jef f s2+Bef f s θm// −OO Figure 10.21: Feedforward computed torque compensation. the advantage of reducing the eﬀects of d. Note that the expression (10.57) is in general extremely complicated so that the computational burden involved in computing (10.57) is of major concern. In fact the problem of real-time implementation of this computed torque control has stimulated a great deal of research. The development of eﬃcient recursive formulations of manipulator dynamics, such as the recursive Newton-Euler equations of Chapter ??, was partly motivated by the need to compute the expression (10.57) in real- time. Since only the values of the desired trajectory need to be known, many of these terms can be precomputed and stored oﬀ-line. Thus there is a trade-oﬀ between memory requirements and on-line computational requirements. This has led to the development of table look up schemes to implement (10.57) and also to the development of computer programs for the automatic generation and simpliﬁcation of manipulator dynamic equations. 10.5 Drive Train Dynamics In this section we discuss in more detail the problem of joint ﬂexibility. For many manipula- tors, particularly those using harmonic drives1 for torque transmission, the joint ﬂexibility is signiﬁcant. In addition to torsional ﬂexibility in the gears, joint ﬂexibility is caused by eﬀects such as shaft windup, bearing deformation, and compressibility of the hydraulic ﬂuid in hydraulic robots. Consider the idealized situation of Figure 10.22 consisting of an actuator connected to a load through a torsional spring which represents the joint ﬂexibility. For simplicity we take the motor torque u as input. The equations of motion are easily derived using the techniques of Chapter ??, with generalized coordinates θℓ and θm, the link angle, and the 1Harmonic drives are a type of gear mechanism that are very popular for use in robots due to their low backlash, high torque transmission and compact size. However, they also introduce unwanted friction and ﬂexibility at the joints. 10.5. DRIVE TRAIN DYNAMICS 249 Figure 10.22: Idealized model to represent joint ﬂexibility. motor angle, respectively, as Jℓ ¨θℓ + Bℓ ˙θℓ + k(θℓ − θm) = 0 (10.58) Jm ¨θm + Bm ˙θm − k(θℓ − θm) = u (10.59) where Jℓ, Jm are the load and motor inertias, Bℓ and Bm are the load and motor damping constants, and u is the input torque applied to the motor shaft. In the Laplace domain we can write this as pℓ(s)Θℓ(s) = kΘm(s) (10.60) pm(s)Θm(s) = kΘℓ(s) + U (s) (10.61) where pℓ(s) = Jℓs 2 + Bℓs + k (10.62) pm(s) = Jms 2 + Bms + k. (10.63) This system is represented by the block diagram of Figure 10.23. The output to be controlled is, of course, the load angle θℓ. The open loop transfer function between U and Θℓ is given by Θℓ(s) U (s) = k pℓ(s)pm(s) − k2 . (10.64) The open loop characteristic polynomial is JℓJms 4 + (JℓBm + JmBℓ)s 3 + (k(Jℓ + Jm) + BℓBm)s 2 + k(Bℓ + Bm)s. (10.65) If the damping constants Bℓ and Bm are neglected, the open loop characteristic polynomial is JℓJms 4 + k(Jℓ + Jm)s 2 (10.66) 250 CHAPTER 10. INDEPENDENT JOINT CONTROL Figure 10.23: Block diagram for the system (10.60)-(10.61). which has a double pole at the origin and a pair of complex conjugate poles at s = ±jω where ω2 = k ( 1 Jℓ + 1 Jm ). Assuming that the open loop damping constants Bℓ and Bm are small, then the open loop poles of the system (10.60)-(10.61) will be in the left half plane near the poles of the undamped system. Suppose we implement a PD compensator C(s) = Kp + KDs. At this point the analysis depends on whether the position/velocity sensors are placed on the motor shaft or on the load shaft, that is, whether the PD-compensator is a function of the motor variables or the load variables. If the motor variables are measured then the closed loop system is given by the block diagram of Figure 10.24. Set Kp + KDs = KD(s + a); a = Kp/KD. The root Figure 10.24: PD-control with motor angle feedback. locus for the closed loop system in terms of KD is shown in Figure 10.25. −5 −4.5 −4 −3.5 −3 −2.5 −2 −1.5 −1 −0.5 0 −3 −2 −1 0 1 2 3 Root Locus Real AxisImaginary Axis Figure 10.25: Root locus for the system of Figure 10.24. We see that the system is stable for all values of the gain KD but that the presence of 10.5. DRIVE TRAIN DYNAMICS 251 the open loop zeros near the jω axis may result in poor overall performance, for example, undesirable oscillations with poor settling time. Also the poor relative stability means that disturbances and other unmodeled dynamics could render the system unstable. If we measure instead the load angle θℓ, the system with PD control is represented by the block diagram of Figure 10.26. The corresponding root locus is shown in Figure 10.27. Figure 10.26: PD-control with load angle feedback. In this case the system is unstable for large KD. The critical value of KD, that is, the value −6 −5 −4 −3 −2 −1 0 1 2 3 −5 −4 −3 −2 −1 0 1 2 3 4 Root Locus Real AxisImaginary Axis Figure 10.27: Root locus for the system of Figure 7.22. of KD for which the system becomes unstable, can be found from the Routh criterion. The best that one can do in this case is to limit the gain KD so that the closed loop poles remain within the left half plane with a reasonable stability margin. Example 10.4 Suppose that the system (10.58)-(10.59) has the following parameters (see 252 CHAPTER 10. INDEPENDENT JOINT CONTROL [1]) k = 0.8N m/rad Bm = 0.015N ms/rad (10.67) Jm = 0.0004N ms 2/rad Bℓ = 0.0N ms/rad Jℓ = 0.0004N m 2/rad. If we implement a PD controller KD(s + a) then the response of the system with motor (respectively, load) feedback is shown in Figure 10.28 (respectively, Figure 10.29). ⋄ 0 2 4 6 8 10 12 0 2 4 6 8 10 12 Figure 10.28: Step response – PD-control with motor angle feedback. 0 5 10 15 20 25 30 35 40 45 50 −2 0 2 4 6 8 10 12 14 Figure 10.29: Step response – PD control with load angle feedback. Chapter 11 MULTIVARIABLE CONTROL 11.1 Introduction In the previous chapter we discussed techniques to derive a control law for each joint of a manipulator based on a single-input/single-output model. Coupling eﬀects among the joints were regarded as disturbances to the individual systems. In reality, the dynamic equations of a robot manipulator form a complex, nonlinear, and multivariable system. In this chapter, therefore, we treat the robot control problem in the context of nonlinear, multivariable control. This approach allows us to provide more rigorous analysis of the performance of control systems, and also allows us to design robust and adaptive nonlinear control laws that guarantee stability and tracking of arbitrary trajectories. Let us ﬁrst reformulate the manipulator dynamic equations in a form more suitable for the discussion to follow. Recall the robot equations of motion (10.26) and (10.27) n∑ j=1 djk(q)¨qj + n∑ i,j=1 cijk(q) ˙qi ˙qj + φk = τk (11.1) Jmk ¨θmk + Bk ˙θmk = Kmk /RkVk − τk/rk. (11.2) where Bk = Bmk + Kbk Kmk /Rk. Multiplying (11.2) by rk and using the fact that θmk = rkqk (11.3) we write Equation (11.2) as r2 kJm ¨qk + r2 kBk ˙qk = rkKmk /RVk − τk (11.4) Substituting (11.4) into (11.1) yields r2 kJmk ¨qk + n∑ j−1 djk ¨qj + n∑ i,j=1 cijk ˙qi ˙qj + r2 kBk ˙qk + φk = rk Km R Vk. (11.5) 253 254 CHAPTER 11. MULTIVARIABLE CONTROL In matrix form these equations of motion can be written as M (q)¨q + C(q, ˙q) ˙q + B ˙q + g(q) = u (11.6) where M (q) = D(q) + J where J is a diagonal matrix with diagonal elements r2 kJmk . The vector g(q) and the matrix C(q, ˙q) are deﬁned by (9.61) and (9.62), respectively, and the input vector u has components uk = rk Kmk Rk Vk. Note that uk has units of torque. Henceforth, we will take B = 0 for simplicity in Equation (11.6) and use this equation for all of our subsequent development. We leave it as an exercise for the reader (cf:Problem X) to show that the properties of passivity, skew-symmetry, bounds on the inertia matrix and linearity in the parameters continue to hold for the system (11.6). 11.2 PD Control Revisited It is rather remarkable that the simple PD-control scheme for set-point control of rigid robots that we discussed in Chapter 10 can be rigorously shown to work in the general case.1. An independent joint PD-control scheme can be written in vector form as u = KP ˜q − KD ˙q (11.7) where ˜q = qd − q is the error between the desired joint displacements qd and the actual joint displacements q, and KP , KD are diagonal matrices of (positive) proportional and derivative gains, respectively. We ﬁrst show that, in the absence of gravity, that is, if g is zero in (11.6), the PD control law (11.7) achieves asymptotic tracking of the desired joint positions. This, in eﬀect, reproduces the result derived previously, but is more rigorous, in the sense that the nonlinear equations of motion (11.1) are not approximated by a constant disturbance. To show that the above control law achieves zero steady state error consider the Lya- punov function candidate V = 1/2 ˙qT M (q) ˙q + 1/2˜qT KP ˜q. (11.8) The ﬁrst term in (11.8) is the kinetic energy of the robot and the second term accounts for the proportional feedback KP ˜q. Note that V represents the total kinetic energy that would result if the joint actuators were to be replaced by springs with stiﬀnesses represented by KP and with equilibrium positions at qd. Thus V is a positive function except at the “goal” q = qd, ˙q = 0, at which point V is zero. The idea is to show that along any motion 1The reader should review the discussion on Lyapunov Stability in Appendix C. 11.2. PD CONTROL REVISITED 255 of the robot, the function V is decreasing to zero. This will imply that the robot is moving toward the desired goal conﬁguration. To show this we note that, since J and qd are constant, the time derivative of V is given by ˙V = ˙qT M (q)¨q + 1/2 ˙qT ˙D(q) ˙q − ˙qT KP ˜q. (11.9) Solving for M (q)¨q in (11.6) with g(q) = 0 and substituting the resulting expression into (11.9) yields ˙V = ˙qT (u − C(q, ˙q) ˙q) + 1/2 ˙qT ˙D(q) ˙q − ˙qT KP ˜q (11.10) = ˙qT (u − KP ˜q) + 1/2 ˙qT ( ˙D(q) − 2C(q, ˙q)) ˙q = ˙qT (u − KP ˜q) where in the last equality we have used the fact (Theorem 6.3.1) that ˙D − 2C is skew symmetric. Substituting the PD control law (11.7) for u into the above yields ˙V = − ˙qT KD ˙q ≤ 0. (11.11) The above analysis shows that V is decreasing as long as ˙q is not zero. This, by itself is not enough to prove the desired result since it is conceivable that the manipulator can reach a position where ˙q = 0 but q ̸= qd. To show that this cannot happen we can use LaSalle’s Theorem (Appendix C). Suppose ˙V ≡ 0. Then (11.11) implies that ˙q ≡ 0 and hence ¨q ≡ 0. From the equations of motion with PD-control M (q)¨q + C(q, ˙q) ˙q = −KP ˜q − KD ˙q must then have 0 = −KP ˜q which implies that ˜q = 0, ˙q = 0. LaSalle’s Theorem then implies that the equilibrium is asymptotically stable. In case there are gravitational terms present in (11.6) Equation (11.10) must be modiﬁed to read ˙V = ˙qT (u − g(q) − KP ˜q). (11.12) The presence of the gravitational term in (11.12) means that PD control alone cannot guarantee asymptotic tracking. In practice there will be a steady state error or oﬀset. Assuming that the closed loop system is stable the robot conﬁguration q that is achieved will satisfy KP (qd − q) = g(q). (11.13) 256 CHAPTER 11. MULTIVARIABLE CONTROL The physical interpretation of (11.13) is that the conﬁguration q must be such that the motor generates a steady state “holding torque” KP (qd − q) suﬃcient to balance the gravitational torque g(q). Thus we see that the steady state error can be reduced by increasing the position gain KP . In order to remove this steady state error we can modify the PD control law as u = KP ˜q − KD ˙q + g(q). (11.14) The modiﬁed control law (11.14), in eﬀect, cancels the eﬀect of the gravitational terms and we achieve the same Equation (11.11) as before. The control law (11.14) requires microprocessor implementation to compute at each instant the gravitational terms g(q) from the Lagrangian equations. In the case that these terms are unknown the control law (11.14) cannot be implemented. We will say more about this and related issues later. 11.3 Inverse Dynamics We now consider the application of more complex nonlinear control techniques for trajectory tracking of rigid manipulators. Consider again the dynamic equations of an n-link robot in matrix form from (11.6) M (q)¨q + C(q, ˙q) ˙q + g(q) = u. (11.15) The idea of inverse dynamics is to seek a nonlinear feedback control law u = f (q, ˙q, t) (11.16) which, when substituted into (11.15), results in a linear closed loop system. For general nonlinear systems such a control law may be quite diﬃcult or impossible to ﬁnd. In the case of the manipulator dynamic equations (11.15), however, the problem is actually easy. By inspecting (11.15) we see that if we choose the control u according to the equation u = M (q)aq + C(q, ˙q) ˙q + g(q) (11.17) then, since the inertia matrix M is invertible, the combined system (11.15)-(11.17) reduces to ¨q = aq (11.18) The term aq represents a new input to the system which is yet to be chosen. Equa- tion (11.18) is known as the double integrator system as it represents n uncoupled double integrators. The nonlinear control law (11.17) is called the inverse dynamics control2 and achieves a rather remarkable result, namely that the “new” system (11.18) is linear, and 2We should point out that in the research literature the control law (11.17) is frequently called computed torque as well. 11.3. INVERSE DYNAMICS 257 decoupled. This means that each input aqk can be designed to control a scalar linear system. Moreover, assuming that aqk is a function only of qk and its derivatives, then aqk will aﬀect qk independently of the motion of the other links. Since aqk can now be designed to control a linear second order system, the obvious choice is to set aq = −K0q − K1 ˙q + r (11.19) where K0 and K1 are diagonal matrices with diagonal elements consisting of position and velocity gains, respectively. The closed loop system is then the linear system ¨q + K1 ˙q + K0q = r. (11.20) Now, given a desired trajectory t → (qd(t), ˙qd(t)). (11.21) if one chooses the reference input r(t) as3 r(t) = ¨qd(t) + K0qd(t) + K1 ˙qd(t) (11.22) then the tracking error e(t) = q − qd satisﬁes ¨e(t) + K1e(t) + K0e(t) = 0. (11.23) A simple choice for the gain matrices K0 and K1 is K0 = diag{ω2 1, . . . , ω2 n} (11.24) K1 = diag{2ω1, . . . , 2ωn} which results in a closed loop system which is globally decoupled, with each joint response equal to the response of a critically damped linear second order system with natural fre- quency ωi. As before, the natural frequency ωi determines the speed of response of the joint, or equivalently, the rate of decay of the tracking error. The inverse dynamics approach is extremely important as a basis for control of robot manipulators and it is worthwhile trying to see it from alternative viewpoints. We can give a second interpretation of the control law (11.17) as follows. Consider again the manipulator dynamic equations (11.15). Since M (q) is invertible for q ∈ Rn we may solve for the acceleration ¨q of the manipulator as ¨q = M −1{u − C(q, ˙q) ˙q − g(q)}. (11.25) Suppose we were able to specify the acceleration as the input to the system. That is, suppose we had actuators capable of producing directly a commanded acceleration (rather 3Compare this with the feedforward expression (10.53). 258 CHAPTER 11. MULTIVARIABLE CONTROL than indirectly by producing a force or torque). Then the dynamics of the manipulator, which is after all a position control device, would be given as ¨q(t) = aq(t) (11.26) where aq(t) is the input acceleration vector. This is again the familiar double integrator system. Note that (11.26) is not an approximation in any sense; rather it represents the actual open loop dynamics of the system provided that the acceleration is chosen as the input. The control problem for the system (11.26) is now easy and the acceleration input aq can be chosen as before according to (11.19). In reality, however, such “acceleration actuators” are not available to us and we must be content with the ability to produce a generalized force (torque) ui at each joint i. Comparing equations (11.25) and (11.26) we see that the torque u and the acceleration aq of the manipulator are related by M −1{u(t) − C(q, ˙q) ˙q − g(q)} = aq (11.27) By the invertibility of the inertia matrix we may solve for the input torque u(t) as u = M (q)aq + C(q, ˙q) ˙q + g(q) (11.28) which is the same as the previously derived expression (11.17). Thus the inverse dynamics can be viewed as an input transformation which transforms the problem from one of choosing torque input commands, which is diﬃcult, to one of choosing acceleration input commands, which is easy. Note that the implementation of this control scheme requires the computation at each sample instant of the inertia matrix M (q) and the vector of Coriolis, centrifugal, and grav- itational. Unlike the computed torque scheme (10.56), however, the inverse dynamics must be computed on-line. In other words, as a feedback control law, it cannot be precom- puted oﬀ-line and stored as can the computed torque (10.57). An important issue therefore in the control system implementation is the design of the computer architecture for the above computations. As processing power continues to increase the computational issues of real-time implementation become less important. An attractive method to implement this scheme is to use a dedicated hardware interface, such as a DSP chip, to perform the required computations in real time. Such a scheme is shown in Figure 11.1. Figure 11.1 illustrates the notion of inner-loop/outer-loop control. By this we mean that the computation of the nonlinear control (11.17) is performed in an inner loop, perhaps with a dedicated hardwire interface, with the vectors q, ˙q, and aq as its inputs and u as output. The outer loop in the system is then the computation of the additional input term aq. Note that the outer loop control aq is more in line with the notion of a feedback control in the usual sense of being error driven. The design of the outer loop feedback control is in theory greatly simpliﬁed since it is designed for the plant represented by the dotted lines in Figure 11.1, which is now a linear or nearly linear system. 11.3. INVERSE DYNAMICS 259 ROBOT LINEARIZED SYSTEM INNER LOOP CONTROLLERCONTROLLER OUTER LOOP PLANNER TRAJECTORY\u0000\u0002\u0001\u0003\u0005\u0004\u0006 Figure 11.1: Inner loop/outer control architecture. 11.3.1 Task Space Inverse Dynamics As an illustration of the importance of the inner loop/outer loop paradigm, we will show that tracking in task space can be achieved by modifying our choice of outer loop control ¨q in (11.18) while leaving the inner loop control unchanged. Let X ∈ R6 represent the end-eﬀector pose using any minimal representation of SO(3). Since X is a function of the joint variables q ∈ C we have ˙X = J(q) ˙q (11.29) ¨X = J(q)¨q + ˙J(q) ˙q. (11.30) where J = Ja is the analytical Jacobian of section 5.8. Given the double integrator system, (11.18), in joint space we see that if aq is chosen as aq = J −1 { aX − ˙J ˙q} (11.31) the result is a double integrator system in task space coordinates ¨X = aX (11.32) Given a task space trajectory X d(t), satisfying the same smoothness and boundedness assumptions as the joint space trajectory qd(t), we may choose aX as aX = ¨X d + KP (X d − X) + KD( ˙X d − ˙X) (11.33) so that the Cartesian space tracking error, ˜X = X − X d, satisﬁes ¨˜X + KD ˙˜X + KP ˜X = 0. (11.34) Therefore, a modiﬁcation of the outer loop control achieves a linear and decoupled system directly in the task space coordinates, without the need to compute a joint space trajectory and without the need to modify the nonlinear inner loop control. 260 CHAPTER 11. MULTIVARIABLE CONTROL Note that we have used a minimal representation for the orientation of the end–eﬀector in order to specify a trajectory X ∈ ℜ6. In general, if the end–eﬀector coordinates are given in SE(3), then the Jacobian J in the above formulation will be the geometric Jacobian J. In this case V = ( v ω ) = ( ˙x ω ) = J(q) ˙q (11.35) and the outer loop control aq = J −1(q){ ( ax aω ) − ˙J(q) ˙q} (11.36) applied to (11.18) results in the system ¨x = ax ∈ ℜ3 (11.37) ˙ω = aω ∈ ℜ3 (11.38) ˙R = S(ω)R, R ∈ SO(3), S ∈ so(3). (11.39) Although, in this latter case, the dynamics have not been linearized to a double integrator, the outer loop terms av and aω may still be used to deﬁned control laws to track end–eﬀector trajectories in SE(3). In both cases we see that non–singularity of the Jacobian is necessary to implement the outer loop control. If the robot has more or fewer than six joints, then the Jacobians are not square. In this case, other schemes have been developed using, for example, the pseudoinverse in place of the inverse of the Jacobian. See [?] for details. The inverse dynamics control approach has been proposed in a number of diﬀerent guises, such as resolved acceleration control [?] and operational space control [?]. These seemingly distinct approaches have all been shown to be equivalent and may be incorporated into the general framework shown above [?]. 11.4 Robust and Adaptive Motion Control A drawback to the implementation of the inverse dynamics control methodology described in the previous section is the requirement that the parameters of the system be known exactly. If the parameters are not known precisely, for example, when the manipulator picks up an unknown load, then the ideal performance of the inverse dynamics controller is no longer guaranteed. This section is concerned with robust and adaptive motion control of manipulators. The goal of both robust and adaptive control to maintain performance in terms of stability, tracking error, or other speciﬁcations, despite parametric uncertainty, external disturbances, unmodeled dynamics, or other uncertainties present in the system. In distinguishing between robust control and adaptive control, we follow the commonly ac- cepted notion that a robust controller is a ﬁxed controller, static or dynamic, designed to satisfy performance speciﬁcations over a given range of uncertainties whereas an adaptive 11.4. ROBUST AND ADAPTIVE MOTION CONTROL 261 controller incorporates some sort of on-line parameter estimation. This distinction is im- portant. For example, in a repetitive motion task the tracking errors produced by a ﬁxed robust controller would tend to be repetitive as well whereas tracking errors produced by an adaptive controller might be expected to decrease over time as the plant and/or control parameters are updated based on runtime information. At the same time, adaptive con- trollers that perform well in the face of parametric uncertainty may not perform well in the face of other types of uncertainty such as external disturbances or unmodeled dynamics. An understanding of the trade-oﬀs involved is therefore important in deciding whether to employ robust or adaptive control design methods in a given situation. Many of the fundamental theoretical problems in motion control of robot manipulators were solved during an intense period of research from about the mid-1980’s until the early- 1990’s during which time researchers ﬁrst began to exploit fundamental structural proper- ties of manipulator dynamics such as feedback linearizability, passivity, multiple time-scale behavior, and other properties that we discuss below. 11.4.1 Robust Feedback Linearization The feedback linearization approach relies on exact cancellation of nonlinearities in the robot equations of motion. Its practical implementation requires consideration of various sources of uncertainties such as modeling errors, unknown loads, and computation errors. Let us return to the Euler-Lagrange equations of motion M (q)¨q + C(q, ˙q) ˙q + g(q) = u (11.40) and write the inverse dynamics control input u as u = ˆM (q)aq + ˆC(q, ˙q) ˙q + ˆg(q) (11.41) where the notation ˆ(·) represents the computed or nominal value of (·) and indicates that the theoretically exact feedback linearization cannot be achieved in practice due to the uncertainties in the system. The error or mismatch ˜(·) = (·) − ˆ(·) is a measure of one’s knowledge of the system dynamics. If we now substitute (11.41) into (11.40) we obtain, after some algebra, ¨q = aq + η(q, ˙q, aq) (11.42) where η = M −1( ˜M aq + ˜C ˙q + ˜g) (11.43) is called the Uncertainty. We note that M −1 ˜M = M −1 ˆM − I =: E (11.44) and so we may decompose η as η = Eaq + M −1( ˜C ˙q + ˜g) (11.45) 262 CHAPTER 11. MULTIVARIABLE CONTROL We note that the system (11.42) is still nonlinear and coupled due to the uncertainty η(q, ˙q, aq). Thus we have no guarantee that the outer loop control given by Equation (11.19) will satisfy desired tracking performance speciﬁcations. In this chapter we discuss several design methods to modify the outer loop control (??) to guarantee global convergence of the tracking error for the system (11.42). Outer Loop Design via Lyapunov’s Second Method There are several approaches to treat the robust feedback linearization problem outlined above. We will discuss only one method, namely the so-called theory of guaranteed stabil- ity of uncertain systems, which is based on Lyapunov’s second method. In this approach we set the outer loop control aq as ¨q = ¨qd(t) + KP (qd − q) + KD( ˙qd − ˙q) + δa (11.46) In terms of the tracking error e = [ ˜q ˙˜q ] = [ q − qd ˙q − ˙qd ] (11.47) we may write ˙e = Ae + B{δa + η} (11.48) where A = [ 0 I −KP −KD ] ; B = [ 0 I ] . (11.49) Thus the double integrator is ﬁrst stabilized by the linear feedback, −KP e − KD ˙e, and δa is an additional control input that must be designed to overcome the potentially destabilizing eﬀect of the uncertainty η. The basic idea is to compute a time–varying scalar bound, ρ(e, t) ≥ 0, on the uncertainty η, i.e., ||η|| ≤ ρ(e, t) (11.50) and design the additional input term δa to guarantee ultimate boundedness of the state trajectory x(t) in (11.48). Returning to our expression for the uncertainty η = E ¨q + M −1( ˜C ˙q + ˜g) (11.51) = Eδa + E(¨qd − KP e − KD ˙e) + M −1( ˜C ˙q + ˜g) (11.52) we assume a bound of the form ||η|| ≤ α||δa|| + γ1||e|| + γ2||e|| 2 + γ3 (11.53) where α = ||E|| = ||M −1 ˆM − I|| and γi are nonnegative constants. Assuming for the moment that ||δa|| ≤ ρ(e, t), which must then be checked a posteriori, we have ||η|| ≤ αρ(e, t) + γ1||e|| + γ2||e|| 2 + γ3 =: ρ(e, t) (11.54) 11.4. ROBUST AND ADAPTIVE MOTION CONTROL 263 which deﬁnes ρ as ρ(e, t) = 1 1 − α (γ1||e|| + γ2||e|| 2 + γ3) (11.55) Since KP and KD are chosen in so that A in (11.48) is a Hurwitz matrix, we choose Q > 0 and let P > 0 be the unique symmetric positive deﬁnite matrix satisfying the Lyapunov equation, A T P + P A = −Q. (11.56) Deﬁning the control δa according to δa =    −ρ(e, t) BT P e ||BT P e|| ; if ||BT P e|| ̸= 0 0 ; if ||BT P e|| = 0 (11.57) it follows that the Lyapunov function V = eT P e satisﬁes ˙V ≤ 0 along solution trajectories of the system (11.48). To show this result, we compute ˙V = −e T Qe + 2e T P B{δa + η} (11.58) For simplicity, set w = BT P e and consider the second term, wT {δa + η} in the above expression. If w = 0 this term vanishes and for w ̸= 0, we have δa = −ρ w ||w|| (11.59) and (11.58) becomes, using the Cauchy-Schwartz inequality, wT (−ρ w ||w|| + η) ≤ −ρ||w|| + ||w||||η|| (11.60) = ||w||(−ρ + ||η||) ≤ 0 (11.61) since ||η|| ≤ ρ and hence ˙V < −e T Qe (11.62) and the result follows. Note that ||δa|| ≤ ρ as required. Since the above control term δa is discontinuous on the manifold deﬁned by BT P e = 0, solution trajectories on this manifold are not well deﬁned in the usual sense. One may deﬁne solutions in a generalized sense, the so-called Filipov solutions [?]. A detailed treatment of discontinuous control systems is beyond the scope of this text. In practice, the discontinuity in the control results in the phenomenon of chattering, as the control switches rapidly across the manifold BT P e = 0. One may implement a continuous approximation to the discontinuous control as δa =    −ρ(e, t) BT P e ||BT P e|| ; if ||BT P e|| > ϵ − ρ(e, t) ϵ BT P e ; if ||BT P e|| ≤ ϵ (11.63) 264 CHAPTER 11. MULTIVARIABLE CONTROL In this case, since the control signal (11.63, a solution to the system (11.48) exists and is uniformly ultimately bounded (u.u.b). Ssee Appendix C for the deﬁnition of uniform ultimate boundedness. Theorem 1 The origin of the system (11.48) is u.u.b. with respect to the set S, deﬁned below, using the continuous control law (11.63). Proof: As before, choose V (e) = eT P e and compute ˙V = −e T Qe + 2wT (δa + η) (11.64) ≤ −e T Qe + 2wT (δa + ρ w ||w|| ) (11.65) with ||w|| = ||BT P e|| as above. For ||w|| ≥ ϵ the argument proceeds as above and ˙V < 0. For ||w|| ≤ ϵ the second term above becomes 2wT (− ρ ϵ w + ρ w ||w|| ) = −2 ρ ϵ ||w|| 2 + 2ρ||w|| This expression attains a maximum value of ϵ ρ 2 when ||w|| = ϵ 2 . Thus we have ˙V = −e T Qe + ϵ ρ 2 < 0 (11.66) provided −e T Qe > ϵ ρ 2 (11.67) Using the relationship λmin(Q)||e|| 2 ≤ e T Qe ≤ λmax(Q)||e|| 2 (11.68) where λmin(Q), λmax(Q) denote the minimum and maximum eigenvalues, respectively, of the matrix Q, we have that ˙V < 0 if λmin(Q)||e|| 2 ≥ ϵ ρ 2 (11.69) or, equivalently ||e|| ≥ ( ϵρ 2λmin(Q) ) 1 2 =: δ (11.70) Let Sδ denote the smallest level set of V containing B(δ), the ball of radius δ and let Br denote the smallest ball containing Sδ. Then all solutions of the closed loop system are u.u.b. with respect to S := Br. The situation is shown in Figure 11.2. All trajectories will eventually enter the ball, Br; in fact, all trajectories will reach the boundary of Sδ since ˙V is negative deﬁnite outside of Sδ. 11.4. ROBUST AND ADAPTIVE MOTION CONTROL 265 Figure 11.2: Uniform Ultimate Boundedness Set 11.4.2 Passivity Based Robust Control In this section we derive an alternative robust control algorithm which exploits the passivity and linearity in the parameters of the rigid robot dynamics. This methods are qualitatively diﬀerent from the previous methods which were based on feedback linearization. In the passivity based approach we modify the inner loop control as u = ˆM (q)a + ˆC(q, ˙q)v + ˆg(q) − Kr. (11.71) where v, a, and r are given as v = ˙qd − Λ˜q a = ˙v = ¨qd − Λ ˙˜q r = ˙qd − v = ˙˜q + Λ˜q with K, Λ diagonal matrices of positive gains. In terms of the linear parametrization of the robot dynamics, the control (11.71) becomes u = Y (q, ˙q, a, v)ˆθ − Kr (11.72) and the combination of (11.71) with (11.40) yields M (q) ˙r + C(q, ˙q)r + Kr = Y (θ − θ0). (11.73) Note that, unlike the inverse dynamics control, the modiﬁed inner loop control (11.40) does not achieve a linear, decoupled system, even in the known parameter case ˆθ = θ. In the robust passivity based approach of [?], the term ˆθ in (11.72) is chosen as ˆθ = θ0 + u (11.74) where θ0 is a ﬁxed nominal parameter vector and u is an additional control term. The system (11.73) then becomes M (q) ˙r + C(q, ˙q)r + Kr = Y (a, v, q, ˙q)(˜θ + u) (11.75) where ˜θ = θ0 − θ is a constant vector and represents the parametric uncertainty in the system. If the uncertainty can be bounded by ﬁnding a nonnegative constant, ρ ≥ 0, such that ∥˜θ∥ = ∥θ0 − θ∥ ≤ ρ, (11.76) then the additional term u can be designed according to the expression, u =    −ρ Y T r ||Y T r|| ; if ||Y T r|| > ϵ − ρ ϵ Y T r ; if ||Y T r|| ≤ ϵ (11.77) 266 CHAPTER 11. MULTIVARIABLE CONTROL The Lyapunov function V = 1 2 rT M (q)r + ˜qT ΛK ˜q (11.78) is used to show uniform ultimate boundedness of the tracking error. Calculating ˙V yields ˙V = rT M ˙r + 1 2 rT ˙M r + 2˜qT ΛK˙˜q (11.79) = −rT Kr + 2˜qT ΛK ˙˜q + 1 2 rT ( ˙M − 2C)r + rT Y (˜θ + u) (11.80) Using the passivity property and the deﬁnition of r, this reduces to ˙V = −˜qT ΛT KΛ˜q − ˙˜qT K ˙˜q + rT Y (˜θ + u) (11.81) Deﬁning w = Y T r and Q = [ ΛT KΛ 0 0 ΛK ] (11.82) and mimicking the argument in the previous section, we have ˙V = −e T Qe + wT (u + ˜θ) (11.83) = −e T Qe + wT (u + ρ w ||w|| ) (11.84) Uniform ultimate boundedness of the tracking error follows with the control u from (11.77) exactly as in the proof of Theorem 1. Comparing this approach with the approach in the section (11.4.1), we see that ﬁnding a constant bound ρ for the constant vector ˜θ is much simpler than ﬁnding a time–varying bound for η in (11.43). The bound ρ in this case depends only on the inertia parameters of the manipulator, while ρ(x, t) in (11.50) depends on the manipulator state vector, the reference trajectory and, in addition, requires some assumptions on the estimated inertia matrix ˆM (q). Example 11.1 TO BE WORKED OUT ⋄ 11.4.3 Passivity Based Adaptive Control In the adaptive approach the vector ˆθ in (11.73) is taken to be a time-varying estimate of the true parameter vector θ. Combining the control law (11.71) with (11.40) yields M (q) ˙r + C(q, ˙q)r + Kr = Y ˜θ. (11.85) The parameter estimate ˆθ may be computed using standard methods such as gradient or least squares. For example, using the gradient update law ˙ˆθ = −Γ −1Y T (q, ˙q, a, v)r (11.86) 11.4. ROBUST AND ADAPTIVE MOTION CONTROL 267 together with the Lyapunov function V = 1 2 rT M (q)r + e T ΛKe + 1 2 ˜θT Γ˜θ (11.87) results in global convergence of the tracking errors to zero and boundedness of the parameter estimates since ˙V = −e T ΛT KΛe − ˙e T K ˙e + ˜θT {Γ ˙ˆθ + Y T r}. (11.88) COMPLETE THE PROOF Example 11.2 TO BE WORKED OUT ⋄ 268 CHAPTER 11. MULTIVARIABLE CONTROL Chapter 12 FORCE CONTROL 12.1 Introduction Position control is adequate for tasks such as materials transfer and spot welding where the manipulator is not interacting signiﬁcantly with objects in the workplace (hereafter referred to as the environment). However, tasks such as assembly, grinding, and deburring, which involve extensive contact with the environment, are often better handled by controlling the forces1 of interaction between the manipulator and the environment directly. For example, consider an application where the manipulator is required to wash a window, or to write with a felt tip marker. In both cases a pure position control scheme is unlikely to work. Slight deviations of the end-eﬀector from a planned trajectory would cause the manipulator either to lose contact with the surface or to press too strongly on the surface. For a highly rigid structure such as a robot, a slight position error could lead to extremely large forces of interaction with disastrous consequences (broken window, smashed pen, damaged end- eﬀector, etc.). The above applications are typical in that they involve both force control and trajectory control. In the window washing application, for example, one clearly needs to control the forces normal to the plane of the window and position in the plane of the window. A force control strategy is one that modiﬁes position trajectories based on the sensed force. There are three main types of sensors for force feedback, wrist force sensors, joint torque sensors, and tactile or hand sensors. A wrist force sensor such as that shown in Figure 12.1 consists of an array of strain gauges and can delineate the three components of the force vector along the three axes of the sensor coordinate frame, and the three components of the torque about these axes. A joint torque sensor consists of strain gauges located on the actuator shaft. Tactile sensors are usually located on the ﬁngers of the gripper and are useful for sensing gripping force and for shape detection. For the purposes of controlling the end-eﬀector/environment interactions, the six-axis wrist sensor usually gives the best results and we shall henceforth assume that the manipulator is equipped with such a device. 1Hereafter we use force to mean force and/or torque and position to mean position and/or orientation. 269 270 CHAPTER 12. FORCE CONTROL Figure 12.1: A Wrist Force Sensor. 12.2 Constrained Dynamics Force control tasks can be thought of in terms of constraints imposed by the robot/environment interaction. A manipulator moving through free space within its workspace is unconstrained in motion and can exert no forces since there is no source of reaction force from the envi- ronment. A wrist force sensor in such a case would record only the inertial forces due to any acceleration of the end-eﬀector. As soon as the manipulator comes in contact with the environment, say a rigid surface as shown in Figure 12.2, one or more degrees of freedom in motion may be lost since the manipulator cannot move through the environment surface. At the same time the manipulator can exert forces against the environment. Figure 12.2: Robot End-Eﬀector in contact with a Rigid Surface In order to describe the robot/environment interaction, let V = (v, ω)T ∈ so(3) represent the instantaneous linear and angular velocity of the end-eﬀector and let F = (f, n)T ∈ so∗(3) represent the instantaneous force and moment. The notation so∗(3) refers to the dual space 12.2. CONSTRAINED DYNAMICS 271 of so(3).2. If e1, . . . , e6 is a basis for the vector space so(3), and f1, . . . , f6 is a basis for so∗(3), we say that these basis vectors are reciprocal provided eifj = 0 if i ̸= j eifj = 1 if i = j Deﬁnition 12.1 The Reciprocal Product V ∈ so(3) and F ∈ so∗(3) is deﬁned as V · F = V T F = vT f + ωT n (12.1) Note that Equation (12.1) is not the same as the usual inner product since V and F lie in diﬀerent vector spaces. The advantage of using reciprocal basis vectors is that the product V T F is then invariant with respect to a linear change of basis from one reciprocal coordinate system to another. This invariance property would, of course, automatically be satisﬁed if V and F were vectors in the same vector space. We note that expressions such as V T 1 V2 or F T 1 F2 for vectors Vi, Fi belonging to so(3) and so∗(3), respectively, are not well deﬁned. For example, the expression V T 1 V2 = vT 1 v2 + ωT 1 ω2 (12.2) is not invariant with respect to either choice of units or basis vectors in so(3). It is pos- sible to deﬁne inner product like operations, i.e. symmetric, bilinear forms on so(3) and so∗(3), which have the necessary invariance properties. These are the so-called Klein Form, KL(V1, V2), and Killing Form, KI(V1, V2), deﬁned according to KL(V1, V2) = vT 1 ω2 + ωT 1 v2 (12.3) KI(V1, V2) = ωT 1 ω2 (12.4) A detailed discussion of these concepts is beyond the scope of this text. As the reader may suspect, the need for a careful treatment of these concepts is related to the geometry of SO(3) as we have seen before in other contexts. Example 12.1 [?] Suppose that V1 = (1, 1, 1, 2, 2, 2) T V2 = (2, 2, 2, −1, −1, −1) T where the linear velocity is in meters/sec and angular velocity is in radians/sec. The clearly, V T 1 V2 = 0 and so one could infer that V1 and V2 are orthogonal vectors in so(3). However, suppose now that the linear velocity is represented in units of centimeters/sec. Then V1 = (1 × 102, 1 × 102, 1 × 102, 2, 2, 2) T V2 = (2 × 102, 2 × 102, 2 × 102, −1, −1, −1) T 2In more advanced texts, the vectors V and F are called Twists and Wrenches [?] although we will continue to refer to them simply as velocity and force. 272 CHAPTER 12. FORCE CONTROL and clearly V T 1 V2 ̸= 0. Thus, usual notion of orthogonality is not meaningful in so(3). It is easy to show that the equality KL(V1, V2) = 0 (respectively, KI(V1, V2) = 0) is indepen- dent of the units or the basis chosen to represent V1 and V2. For example, the condition KI(V1, V2) = 0 means that the axes of rotation deﬁning ω1 and ω2 are orthogonal. ⋄ We will utilize the reciprocal product V T F in later sections to derive force control strategies. 12.2.1 Static Force/Torque Relationships Forces at the end-eﬀector due to robot/environment interaction induce torques about the joint axes of the robot. Similarly, torques applied at the joint axes will produce forces at the robot/environment interface. Let τ denote the vector of joint torques induced by an end-eﬀector force, F , and let δX represent a virtual end-eﬀector displacement caused by the force F . Let δq represent the corresponding virtual joint displacement. These virtual displacements are related through the manipulator Jacobian J(q) according to δX = J(q)δq. (12.5) The virtual work δw of the system is δw = F T δX − τ T δq. (12.6) Substituting (12.5)) into (12.6) yields δw = (F T J − τ T )δq (12.7) which is equal to zero if the manipulator is in equilibrium. Since the generalized coordinates q are independent we have the equality τ = J(q) T F. (12.8) In other words the end-eﬀector forces are related to the joint torques by the transpose of the manipulator Jacobian according to (12.8). Example 12.2 Consider the two-link planar manipulator of Figure 12.3, with a force F = (Fx, Fy)T applied at the end of link two as shown. The Jacobian of this manipulator is given by Equation (5.93). The resulting joint torques τ = (τ1, τ2) are then given as [ τ1 τ2 ] = [ −a1s1 − a2s12 a1c1 + a2c12 0 0 0 1 −a2s12 a2c12 0 0 0 1 ]         Fx Fy Fz nx ny nz         . (12.9) ⋄ 12.2. CONSTRAINED DYNAMICS 273 Figure 12.3: Two-link planar robot. When the manipulator is in contact with the environment, the dynamic equations of Chapter 9 must be modiﬁed to include the reaction torque J T Fe corresponding to the end- eﬀector force Fe. Thus the equations of motion of the manipulator in joint space are given by M (q)¨q + C(q, ˙q) ˙q + g(q) + J T (q)Fe = u (12.10) 12.2.2 Constraint Surfaces Let us assume that the force Fe in Equation (12.10) is due to the contact between the end-eﬀector and a rigid environment. Supppose the robot/environment constraint can be expressed in conﬁguration space by nf < n algebraic equations of the form φq(q) =    φq1 ... φqnf    =    0 ... 0    (12.11) where φq : IR n → IRn is a continuously diﬀerentiable function. Assume that the constraints are independent so that the Jacobian Jφq = ( ∂φqi ∂qj ) for i = 1, . . . , nf , j = 1, . . . , n has full rank equal to nf In the Lagrangian approach to the derivation of the robot dynamics, the standard way to incorporate such constraint functions is to modify the Lagrangian function as L = K − P − nf∑ j=1 λjφqj(q) (12.12) where λ = [λ1, . . . , λnf ]T is a vector of Lagrange Multipliers. The solution to the Euler- Lagrange equations d dt ∂L ∂ ˙qk − ∂L ∂qk = uk k = 1, . . . , n (12.13) 274 CHAPTER 12. FORCE CONTROL then results in (Problem ??) M (q)¨q + C(q, ˙q) ˙q + g(q) + J T φq (q)λ = u (12.14) Comparing Equations (12.10) and (12.14) gives J T Fe = J T φq λ = J T J −T J T φq λ = J T J T φxλ (12.15) where we deﬁne Jφx = Jφq J −1 (12.16) Thus, as long as the manipulator Jacobian, J(q), is invertible we may write the environment force, Fe, as Fe = J T φxλ (12.17) Equation (12.17) means that the reaction forces, Fe, belong to an nf dimensional subspace spanned by the column vectors of Jφx. Let Sf denote a basis for this vector space. Then any constraint force, Fe, may be expressed as Fe = Sf β (12.18) where β = [β1, . . . , βnf ]T is a vector of dimensionless scalars. We refer to the vector space spanned by Sf as the Force Controlled Subspace. Example 12.3 Suppose the robot is constrained to follow the circular surface shown in Figure 12.4 With the coordinates as shown in the Figure, the constraint can be written as Figure 12.4: End Eﬀector Constrainted to Follow a Circle φx = (x − a) 2 + (y − b) 2 − r2 = 0 (12.19) 12.2. CONSTRAINED DYNAMICS 275 or, using the forward kinematic equations, φq = (a1c1 + a2c12 − a) 2 + (a1s1 + a2s12 − b) 2 − r2 = 0 (12.20) The Jacobian, Jφx, is therefore given by Jφx = [2(x − a), 2(y − b)] (12.21) It can be veriﬁed by direct calculation (Problem ??) that Jφq is given by Jφq = [2(a1c1 + a2c12 − a), 2(a1s2 + a2s12 − b)] [ −a2s1 − a2s12 −a2s12 a1c1 + a2c12 a2c12 ] (12.22) Therefore Jφx = Jφq J (12.23) where J is the Jacobian of the two-link planar robot derived in Chapter 1. If we take Sf = [ x − a y − b ] (12.24) then the contact force between the robot and the environment may be expressed as Fe = Sf β = [ x − a y − b ] β (12.25) where β is an arbitrary scalar. Note that Fe is always directed along the line through the center of the circle, i.e. perpendicular to the tangent to the circle. ⋄ We may therefore assume that so∗(3) = span(Sf ) ⊕ span(Sf ) ⊥ (12.26) We can similarly describe the end-eﬀector velocity subject to the constraints (12.11). With φq(q) identically zero we have 0 = ˙φq(q) = ∂φq ∂q ˙q = Jφq ˙q (12.27) Thus 0 = Jφq ˙q = (Jφq J −1)J ˙q = JφxV (12.28) where V = (v, ω) is the usual end-eﬀector linear and angular velocity. It follows from (12.17) and (12.28) that the reciprocal product satisﬁes V T Fe = F T e V = 0 (12.29) Equation (12.29) is called the Reciprocity Condition. This means that we can deﬁne a set of nx = n − nf basis vectors so that V = Sxγ, for some γ (12.30) Furthermore, the reciprocity condition (12.29) implies that ST x Sf = 0 (12.31) 276 CHAPTER 12. FORCE CONTROL 12.2.3 Natural and Artiﬁcial Constraints In this section we discuss so-called Natural Constraints which are deﬁned using the reci- procity condition (12.1). We then discuss the notion of Artiﬁcial Constraints, which are used to deﬁne reference inputs for motion and force control tasks. We begin by deﬁning a so-called Compliance Frame ocxcyczc (also called a Constraint Frame) in which the task to be performed is easily described. For example in the window washing application we can deﬁne a frame at the tool with the zc-axis along the surface normal direction. The task speciﬁcation would then be expressed in terms of maintaining a constant force in the zc direction while following a prescribed trajectory in the xc − yc plane. Such a position constraint in the zc direction arising from the presence of a rigid surface is a natural constraint. The force that the robot exerts against the rigid surface in the zc direction, on the other hand, is not constrained by the environment. A desired force in the zc direction would then be considered as an artiﬁcial constraint that must be maintained by the control system. Figure 12.5 shows a typical task, that of inserting a peg into a hole. With respect to a compliance frame ocxcyczc as shown at the end of the peg, we may take the the standard orthonormal basis in ℜ6 for both so(3) and so∗(3), in which case V T F = vxfx + vyfy + vzfz + ωxnx + ωyny + ωznz (12.32) If we assume that the walls of the hole and the peg are perfectly rigid and there is no friction, it is easy to see that vx = 0 vy = 0 fz = 0 ωx = 0 ωy = 0 nz = 0 (12.33) and thus the reciprocity condition V T F = 0 is satisﬁed. These relationships (12.33) are termed Natural Constraints. Figure 12.5: Inserting a peg into a hole. Examining Equation (12.32) we see that the variables fx fy vz nx ny ωz (12.34) 12.2. CONSTRAINED DYNAMICS 277 are unconstrained by the environment, i.e. given the natural constraints (12.33), the reci- procity condition V T F = 0 holds for all values of the above variables (12.34). We may therefore assign reference values, called Artiﬁcial Constraints, for these variables that may then be enforced by the control system to carry out the task at hand. For example, in the peg-in-hole task we may deﬁne artiﬁcial constraints as fx = 0 fy = 0 vz = vd nx = 0 ny = 0 ωz = 0 (12.35) where vd is the desired speed of insertion of the peg in the z-direction. Figures 12.6 and 12.7 show natural and artiﬁcial constraints for two additional tasks, that of turning a crank and and turning a screw, respectively. Figure 12.6: Turning a crank Figure 12.7: Turning a screw. 278 CHAPTER 12. FORCE CONTROL 12.3 Network Models and Impedance The reciprocity condition V T F = 0 means that the forces of constraint do no work in directions compatible with motion constraints and holds under the ideal conditions of no friction and perfect rigidity of both the robot and environment. In practice, compliance and friction present at the robot/environment interface will alter the strict separation between motion constraints and force constraints. For example, consider the situation in Figure 12.8. Since the environment deforms in response to a force there is clearly both motion and force Figure 12.8: Compliant Environment in the same direction, i.e. normal to the surface. Thus the product V (t)F (t) along this direction will not be zero. Let k represent the stiﬀness of the surface so that F = kx. Then ∫ t 0 V (u)F (u)du = ∫ t 0 ˙x(u)kx(u)du = k ∫ t 0 d du 1 2 kx 2(u)du = 1 2 k(x 2(t) − x 2(0)) (12.36) is the change of the potential energy. The environment stiﬀness, k, determines the amount of force needed to produce a given motion. The higher the value of k the more the environment “impedes” the motion of the end-eﬀector. In this section we introduce the notion of Mechanical Impedance which captures the relation between force and motion. We introduce so-called Network Models, which are particularly useful for modeling the robot/environment interaction. We model the robot and environment as One Port Networks as shown in Figure 12.9. The dynamics of the robot and environment, respectively, determine the relation between the Port Variables, Vr, Fr, and Ve, Fe, respectively. Fr, Fe are known as Eﬀort or Across variables while Vr, Ve are known as Flow or Through variables. In a mechanical system, such as a robot, force and velocity are the eﬀort and ﬂow variables while in an electrical system, voltage and current are the eﬀort and ﬂow variables, respectively. With this description, the “product” of the port variables, V T F , represents instantaneous power and the integral of this product ∫ t 0 V T (σ)F (σ)dσ 12.3. NETWORK MODELS AND IMPEDANCE 279 Figure 12.9: One-Port Networks is the Energy dissipated by the Network over the time interval [0, t]. The robot and the environment are then coupled through their interaction ports, as shown in Figure 12.10, which describes the energy exchange between the robot and the environment. Figure 12.10: Robot/Environment Interaction 12.3.1 Impedance Operators The relationship between the eﬀort and ﬂow variables may be described in terms of an Impedance Operator. For linear, time invariant systems, we may utilize the s-domain or Laplace domain to deﬁne the Impedance. Deﬁnition 12.2 Given the one-port network 12.9 the Impedance, Z(s) is deﬁned as the ratio of the Laplace Transform of the eﬀort to the Laplace Transform of the ﬂow, i.e. Z(s) = F (s) V (s) (12.37) 280 CHAPTER 12. FORCE CONTROL Example 12.4 Suppose a mass-spring-damper system is described by the diﬀerential equa- tion M ¨x + B ˙x + Kx = F (12.38) Taking Laplace Transforms of both sides (assuming zero initial conditions) it follows that Z(s) = F (s)/V (s) = M s + B + K/s (12.39) ⋄ 12.3.2 Classiﬁcation of Impedance Operators Deﬁnition 12.3 An impedance Z(s) in the Laplace variable s is said to be 1. Inertial if and only if |Z(0)| = 0 2. Resistive if and only if |Z(0)| = B for some constant 0 < B < ∞ 3. Capacitive if and only if |Z(0)| = ∞ Thus we classify impedance operators based on their low frequency or DC-gain, which will prove useful in the steady state analysis to follow. Example 12.5 Figure 12.11 shows examples of environment types. Figure 12.11(a) shows a mass on a frictionless surface. The impedance is Z(s) = M s, which is iner- tial. Figure 12.11(b) shows a mass moving in a viscous medium with resistance B. Then Z(s) = M s + B, which is resistive. Figure 12.11(c) shows a linear spring with stiﬀness K. Then Z(s) = K/s, which is capacitive. ⋄ Figure 12.11: Inertial, Resistive, and Capacitive Environment Examples 12.4. FORCE CONTROL STRATEGIES 281 12.3.3 Th´evenin and Norton Equivalents In linear circuit theory it is common to use so-called Th´evenin and Norton equivalent circuits for analysis and design. It is easy to show that any one-port network consisting of passive elements (resistors, capacitors, inductors) and active current or voltage sources can be represented either as an impedance, Z(s), in series with an eﬀort source (Th´evenin Equivalent) or as an impedance, Z(s), in parallel with a ﬂow source (Norton Equivalent). The independent sources, Fs and Vs may be used to represent reference signal generators Figure 12.12: Th´evenin and Norton Equivalent Networks for force and velocity, respectively, or they may represent external disturbances. 12.4 Force Control Strategies Let us consider a modiﬁed inverse dynamics control law of the form u = M (q)aq + C(q, ˙q) ˙q + g(q) + J T (q)af (12.40) where aq and af are outer look controls with units of acceleration and force, respectively. Using the relationship between joint space and task space variables derived in Chapter 11 ¨x = J(q)¨q + ˙J(q) ˙q (12.41) ax = J(q)aq + ˙J(q) ˙q (12.42) we substitute (12.40)-(12.42) into (12.10) to obtain ¨x = ax + W (q)(Fe − af ) (12.43) where W (q) = J(q)M −1(q)J T (q) is called the Mobility Tensor. There is often a conceptual advantage to separate the position and force control terms by assuming that ax is a function only of position and velocity and af is a function only of force [?]. However, for simplicity, 282 CHAPTER 12. FORCE CONTROL we shall take af = Fe to cancel the environment force, Fe and thus recover the task space double integrator system ¨x = ax (12.44) and we will assume that any additional force feedback terms are included in the outer loop term ax. This entails no loss of generality as long as the Jacobian (hence W (q)) is invertible. This will become clear in the sequel. 12.4.1 Impedance Control In this section we discuss the notion of Impedance Control. We begin with an example that illustrates in a simple way the eﬀect of force feedback Example 12.6 Consider the one-dimensional system in Figure 12.13 consisting of a mass, Figure 12.13: One Dimensional System M , on a frictionless surface subject to an environmental force F and control input u. The equation of motion of the system is M ¨x = u − F (12.45) With u = 0, the object “appears to the environment” as a pure inertia with mass M . Suppose the control input u is chosen as a force feedback term u = −mF . Then the closed loop system is M ¨x = −(1 + m)F =⇒ M 1 + m ¨x = −F (12.46) Hence, the object now appears to the environment as an inertia with mass M 1 + m . Thus the force feedback has the eﬀect of changing the apparent inertia of the system. ⋄ The idea behind Impedance Control is to regulate the mechanical impedance, i.e., the apparent inertia, damping, and stiﬀness, through force feedback as in the above example. 12.4. FORCE CONTROL STRATEGIES 283 For example, in a grinding operation, it may be useful to reduce the apparent stiﬀness of the end-eﬀector normal to the part so that excessively large normal forces are avoided. We may formulate Impedance Control within our standard inner loop/outer loop control architecture by specifying the outer loop term, ax, in Equation (12.44). Let xd(t) be a reference trajectory deﬁned in task space coordinates and let Md, Bd, Kd, be 6 × 6 matrices specifying desired inertia, damping, and stiﬀness, respectively. Let e(t) = x(t) − xd(t) be the tracking error in task space and set ax = ¨x d − M −1 d (Bd ˙e + Kde + F ) (12.47) where F is the measured environmental force. Substituting (12.47) into (12.44) yields the closed loop system Md¨e + Bd ˙e + Kde = −F (12.48) which results in desired impedance properties of the end-eﬀector. Note that for F = 0 tracking of the reference trajectory, xd(t), is achieved, whereas for nonzero environmental force, tracking is not necessarily achieved. We will address this diﬃculty in the next section. 12.4.2 Hybrid Impedance Control In this section we introduce the notion of Hybrid Impedance Control following the treatment of [?]. We again take as our starting point the linear, decoupled system (12.44). The impedance control formulation in the previous section is independent of the environment dynamics. It is reasonable to expect that stronger results may be obtained by incorporating a model of the environment dynamics into the design. For example, we will see below that one may regulate both position and impedance simultaneously which is not possible with the pure impedance control law (12.47). We consider a one-dimensional system representing one component of the outer loop system (12.44) ¨xi = axi (12.49) and we henceforth drop the subscript, i, for simplicity. We assume that the impedance of the environment in this direction, Ze is ﬁxed and known, a priori. The impedance of the robot, Zr, is of course determined by the control input. The Hybrid Impedance Control design proceeds as follows based on the classiﬁcation of the environment impedance into inertial, resistive, or capacitive impedances: 1. If the environment impedance, Ze(s), is capacitive, use a Norton network representa- tion. Otherwise, use a Th´evenin network representation3. 2. Represent the robot impedance as the Dual to the environment impedance. Th´evenin and Norton networks are considered dual to one another. 3. In the case that the environment impedance is capacitive we have the robot/environment interconnection as shown in Figure 12.14 where the environment one-port is the Nor- 3In fact, for a resistive environment, either representation may be used 284 CHAPTER 12. FORCE CONTROL Figure 12.14: Capacitive Environment Case ton network and the robot on-port is the Th´evenin network. Suppose that Vs = 0, i.e. there are no environmental disturbances, and that Fs represents a reference force. From the circuit diagram it is straightforward to show that F Fs = Ze(s) Ze(s) + Zr(s) (12.50) Then the steady state force error, ess, to a step reference force, Fs = F d s is given by the Final Value Theorem as ess = −Zr(0) Zr(0) + Ze(0) = 0 (12.51) since Ze(0) = ∞ (capacitive environment) and Zr ̸= 0 (non-capacitive robot). The implications of the above calculation are that we can track a constant force reference value, while simultaneously specifying a given impedance, Zr, for the robot. In order to realize this result we need to design outer loop control term ax in (12.49) using only position, velocity, and force feedback. This imposes a practical limitation on the the achievable robot impedance functions, Zr. Suppose Z−1 r has relative degree one. This means that Zr(s) = Mcs + Zrem(s) (12.52) where Zrem(s) is a proper rational function. If we now choose ax = − 1 Mc Zrem ˙x + 1 mc (Fs − F ) (12.53) Substituting this into the double integrator system ¨x = ax yields Zr(s) ˙x = Fs − F (12.54) Thus we have shown that, for a capacitive environment, force feedback can be used to regulate contact force and specify a desired robot impedance. 12.4. FORCE CONTROL STRATEGIES 285 4. In the case that the environment impedance is inertial we have the robot/environment interconnection as shown in Figure 12.15 where the environment one-port is a Th´evenin Figure 12.15: Inertial Environment Case network and the robot on-port is a Norton network. Suppose that Fs = 0, and that Vs represents a reference velocity. From the circuit diagram it is straightforward to show that V Vs = Zr(s) Ze(s) + Zr(s) (12.55) Then the steady state force error, ess, to a step reference velocity command, Vs = V d s is given by the Final Value Theorem as ess = −Ze(0) Zr(0) + Ze(0) = 0 (12.56) since Ze(0) = 0 (inertial environment) and Zr ̸= 0 (non-inertial robot). To achieve this non-inertia robot impedance we take, as before, Zr(s) = Mcs + Zrem(s) (12.57) and set ax = ¨x d + 1 Mc Zrem( ˙x d − ˙x) + 1 Mc F (12.58) Then, substituting this into the double integrator equation, ¨x = ax, yields Zr(s)( ˙x d − x) = F (12.59) Thus we have shown that, for a capacitive environment, position control can be used to regulate a motion reference and specify a desired robot impedance. 286 CHAPTER 12. FORCE CONTROL Chapter 13 FEEDBACK LINEARIZATION 13.1 Introduction In this chapter we discuss the notion of feedback linearization of nonlinear systems. This approach generalizes the concept of inverse dynamics of rigid manipulators discussed in Chapter 11. The basic idea of feedback linearization is to construct a nonlinear control law as a so-called inner loop control which, in the ideal case, exactly linearizes the nonlinear system after a suitable state space change of coordinates. The designer can then design a second stage or outer loop control in the new coordinates to satisfy the traditional control design speciﬁcations such as tracking, disturbance rejection, and so forth. In the case of rigid manipulators the inverse dynamics control of Chapter 11 and the feedback linearizing control are the same. However, as we shall see, the full power of the feedback linearization technique for manipulator control becomes apparent if one includes in the dynamic description of the manipulator the transmission dynamics, such as elasticity resulting from shaft windup, gear elasticity, etc. To introduce the idea of feedback linearization consider the following simple system, ˙x1 = a sin(x2) (13.1) ˙x2 = −x 2 1 + u. (13.2) Note that we cannot simply choose u in the above system to cancel the nonlinear term a sin(x2). However, if we ﬁrst change variables by setting y1 = x1 (13.3) y2 = a sin(x2) = ˙x1 (13.4) then, by the chain rule, y1 and y2 satisfy ˙y1 = y2 (13.5) ˙y2 = a cos(x2)(−x 2 1 + u). (13.6) 287 288 CHAPTER 13. FEEDBACK LINEARIZATION We see that the nonlinearities can now be cancelled by the input u = 1 a cos(x2) v + x 2 1 (13.7) which result in the linear system in the (y1, y2) coordinates ˙y1 = y2 (13.8) ˙y2 = v. (13.9) The term v has the interpretation of an outer loop control and can be designed to place the poles of the second order linear system (13.6) in the coordinates (y1, y2). For example the outer loop control v = −k1y1 − k2y2 (13.10) applied to (13.6) results in the closed loop system ˙y1 = y2 (13.11) ˙y2 = −k1y1 − k2y2 which has characteristic polynomial p(s) = s 2 + k2s + k1 (13.12) and hence the closed loop poles of the system with respect to the coordinates (y1, y2) are completely speciﬁed by the choice of k1 and k2. Figure 13.1 illustrates the inner loop/outer Figure 13.1: Architecture of feedback linearization controller. loop implementation of the above control strategy. The response in the y variables is easy to determine. The corresponding response of the system in the original coordinates (x1, x2) can be found by inverting the transformation (13.2), in this case x1 = y1 (13.13) x2 = sin −1(y2/a) − a < y2 < +a. 13.2. BACKGROUND: THE FROBENIUS THEOREM 289 This example illustrates several important features of feedback linearization. The ﬁrst thing to note is the local nature of the result. We see from (13.3) and (13.4) that the transformation and the control make sense only in the region −∞ < x1 < ∞, − π 2 < x2 < π 2 . Second, in order to control the linear system (13.6), the coordinates (y1, y2) must be available for feedback. This can be accomplished by measuring them directly if they are physically meaningful variables, or by computing them from the measured (x1, x2) coordinates using the transformation (13.2). In the latter case the parameter a must be known precisely. In Section 13.3 give necessary and suﬃcient conditions under which a general singl- input nonlinear system can be transformed into a linear system in the above fashion, using a nonlinear change of variables and nonlinear feedback as in the above example. 13.2 Background: The Frobenius Theorem In this section we give some background from diﬀerential geometry that is necessary to un- derstand the feedback linearization results to follow. In recent years an impressive volume of literature has emerged in the area of diﬀerential geometric methods for nonlinear sys- tems, treating not only feedback linearization but also other problems such as disturbance decoupling, estimation, etc. The reader is referred to [?] for a comprehensive treatment of the subject. Most of the results in this area are intended to give abstract, coordinate-free descriptions of various geometric properties of nonlinear systems and as such are diﬃcult for the non-mathematician to follow. It is our intent here to give only that portion of the theory that ﬁnds an immediate application to the manipulator control problem, and even then to give only the simplest versions of the results. We restrict our attention here to single-input nonlinear systems of the form ˙x = f (x) + g(x)u (13.14) where f (x), g(x) are smooth vector ﬁelds on Rn. By a smooth vector ﬁeld on Rn we will mean a function f : Rn → Rn which is inﬁnitely diﬀerentiable. Henceforth, whenever we use the term function or vector ﬁeld, it is assumed that the given function or vector ﬁeld is smooth. Deﬁnition 13.1 Let f and g be two vector ﬁelds on Rn. The Lie Bracket of f and g, denoted by [f, g], is a vector ﬁeld deﬁned by [f, g] = ∂g ∂x f − ∂f ∂x g (13.15) where ∂g ∂x (respectively, ∂f ∂x ) denotes the n × n Jacobian matrix whose ij-th entry is ∂gi ∂xj (respectively, ∂fi ∂xj ). 290 CHAPTER 13. FEEDBACK LINEARIZATION Example 13.1 Suppose that vector ﬁelds f (x) and g(x) on R3 are given as f (x) =   x2 sin x1 x2 3 + x1   g(x) =   0 x2 2 0   . Then the vector ﬁeld [f, g] is computed according to (13.15) as [f, g] =   0 0 0 0 2x2 0 0 0 0     x2 sin x1 x1 + x2 3   −   0 1 0 cos x1 0 0 1 0 2x3     0 x2 2 1   =   −x2 2 2x2 sin s1 −2x3   . ⋄ We also denote [f, g] as adf (g) and deﬁne adk f (g) inductively by adk f (g) = [f, adk−1 f (g)] (13.16) with ad0 f (g) = g. Deﬁnition 13.2 Let f : Rn → Rn be a smooth vector ﬁeld on Rn and let h : Rn → R be a scalar function. The Lie Derivative of h, with respect to f , denoted Lf h, is deﬁned as Lf h = ∂h ∂x f (x) = n∑ i=1 ∂h ∂xi fi(x) (13.17) The Lie derivative is simply the directional derivative of h in the direction of f (x), equiva- lently the inner product of the gradient of h and f . We denote by L2 f h the Lie Derivative of Lf h with respect to f , i.e. L 2 f h = Lf (Lf h) (13.18) In general we deﬁne L k f h = Lf (L k−1 f h) for k = 1, . . . , n (13.19) with L0 f h = h. The following technical lemma gives an important relationship between the Lie Bracket and Lie derivative and is crucial to the subsequent development. Lemma 13.1 Let h : Rn → R be a scalar function and f and g be vector ﬁelds on Rn. Then we have the following identity L[f,g]h = Lf Lgh − LgLf h (13.20) 13.2. BACKGROUND: THE FROBENIUS THEOREM 291 Proof: Expand Equation (13.20) in terms of the coordinates x1, . . . , xn and equate both sides. The i-th component [f, g]i of the vector ﬁeld [f, g] is given as [f, g]i = n∑ j=1 ∂gi ∂xj fj − n∑ j=1 ∂fi ∂xj gj. Therefore, the left-hand side of (13.20) is L[f,g]h = n∑ i=1 ∂h ∂xi [f, g]i = n∑ i=1 ∂h ∂xi   n∑ j=1 ∂gi ∂xj fj − n∑ j=1 ∂fi ∂xj gj   = n∑ i=1 n∑ j=1 ∂h ∂xi ( ∂gi ∂xj fj − ∂fi ∂xj gj ) . If the right hand side of (13.20) is expanded similarly it can be shown, with a little algebraic manipulation, that the two sides are equal. The details are left as an exercise (Problem 12- 1). In order to discuss the idea of feedback linearization we ﬁrst present a basic result in diﬀerential geometry known as the Frobenius Theorem. The Frobenius Theorem can be thought of as an existence theorem for solutions to certain systems of ﬁrst order partial diﬀerential equations. Although a rigorous proof of this theorem is beyond the scope of this text, we can gain an intuitive understanding of it by considering the following system of partial diﬀerential equations ∂z ∂x = f (x, y, z) (13.21) ∂z ∂y = g(x, y, z) (13.22) In this example there are two partial diﬀerential equations in a single unknown z. A solution to (13.21)-(13.22) is a function z = φ(x, y) satisfying ∂φ ∂x = f (x, y, φ(x, y)) (13.23) ∂φ ∂y = g(x, y, φ(x, y)) (13.24) We can think of the function z = φ(x, y) as deﬁning a surface in R3 as in Figure 13.2. The function Φ : R2 → R3 deﬁned by Φ(x, y) = (x, y, φ(x, y)) (13.25) 292 CHAPTER 13. FEEDBACK LINEARIZATION Figure 13.2: Integral manifold in R3. then characterizes both the surface and the solution to the system of Equations (13.21). At each point (x, y) the tangent plane to the surface is spanned by two vectors found by taking partial derivatives of Φ in the x and y directions, respectively, that is, by X1 = (1, 0, f (x, y, φ(x, y))) T (13.26) X2 = (0, 1, g(x, y, φ(x, y))) T . (13.27) The vector ﬁelds X1 and X2 are linearly independent and span a two dimensional sub- space at each point. Notice that X1 and X2 are completely speciﬁed by the system of Equations (13.21). Geometrically, one can now think of the problem of solving the system of ﬁrst order partial diﬀerential Equations (13.21) as the problem of ﬁnding a surface in R3 whose tangent space at each point is spanned by the vector ﬁelds X1 and X2. Such a surface, if it can be found, is called an integral manifold for the system (13.21). If such an integral manifold exists then the set of vector ﬁelds, equivalently, the system of partial diﬀerential equations, is called completely integrable. Let us reformulate this problem in yet another way. Suppose that z = φ(x, y) is a solution of (13.21). Then it is a simple computation (Problem 12-2) to check that the function h(x, y, z) = z − φ(x, y) (13.28) satisﬁes the system of partial diﬀerential equations LX1h = 0 (13.29) LX2h = 0 (13.30) Conversely, suppose a scalar function h can be found satisfying (13.29)-(13.30), and suppose that we can solve the equation h(x, y, z) = 0 (13.31) 13.3. SINGLE-INPUT SYSTEMS 293 for z, as z = φ(x, y).1 Then it can be shown that φ satisﬁes (13.21). (Problem 12-3) Hence, complete integrability of the set of vector ﬁelds (X1, X2) is equivalent to the existence of h satisfying (13.29). With the preceding discussion as background we state the following Deﬁnition 13.3 A linearly independent set of vector ﬁelds {X1, . . . , Xm} on Rn is said to be completely integrable if and only if there are n − m linearly independent functions h1, . . . , hn−m satisfying the system of partial diﬀerential equations LXihj = 0 for 1 ≤ i ≤ n ; 1 ≤ j ≤ m (13.32) Deﬁnition 13.4 A linearly independent set of vector ﬁelds {X1, . . . , Xm} is said to be involutive if and only if there are scalar functions αijk : Rn → R such that [Xi, Xj] = m∑ k=1 αijkXk for all i, j, k. (13.33) Involutivity simply means that if one forms the Lie Bracket of any pair of vector ﬁelds from the set {X1, . . . , Xm} then the resulting vector ﬁeld can be expressed as a linear combination of the original vector ﬁelds X1, . . . , Xm. Note that the coeﬃcients in this linear combination are allowed to be smooth functions on Rn. In the simple case of (13.21) one can show that if there is a solution z = φ(x, y) of (13.21) then involutivity of the set {X1, X2} deﬁned by (13.32) is equivalent to interchangeability of the order of partial derivatives of φ, that is, ∂2φ ∂x∂y = ∂2φ ∂y∂x . The Frobenius Theorem, stated next, gives the conditions for the existence of a solution to the system of partial diﬀerential Equations (13.32). Theorem 2 Let {X1, . . . , Xm} be a set of vector ﬁelds that are linearly independent at each point. Then the set of vector ﬁelds is completely integrable if and only if it is involutive. Proof: See, for example, Boothby [?]. 13.3 Single-Input Systems The idea of feedback linearization is easiest to understand in the context of single-input systems. In this section we derive the feedback linearization result of Su [?] for single-input nonlinear systems. As an illustration we apply this result to the control of a single-link manipulator with joint elasticity. Deﬁnition 13.5 A single-input nonlinear system ˙x = f (x) + g(x)u (13.34) 1The so-called Implicit Function Theorem states that (13.31) can be solved for z as long as ∂h ∂z ̸= 0. 294 CHAPTER 13. FEEDBACK LINEARIZATION where f (x) and g(x) are smooth vector ﬁelds on Rn, f (0) = 0, and u ∈ R, is said to be feed- back linearizable if there exists a region U in Rn containing the origin, a diﬀeomorphism2 T : U → Rn, and nonlinear feedback u = α(x) + β(x)v (13.35) with β(x) ̸= 0 on U such that the transformed variables y = T (x) (13.36) satisfy the system of equations ˙y = Ay + bv (13.37) where A =         0 1 0 0 0 0 1 · · · · · · · · · · · · · · 1 0 0 · · 0 0         b =         0 0 · · · 1         . (13.38) Remark 13.1 The nonlinear transformation (13.36) and the nonlinear control law (13.35), when applied to the nonlinear system (13.34), result in a linear controllable system (13.37). The diﬀeomorphism T (x) can be thought of as a nonlinear change of coordinates in the state space. The idea of feedback linearization is then that if one ﬁrst changes to the coordinate system y = T (x), then there exists a nonlinear control law to cancel the nonlinearities in the system. The feedback linearization is said to be global if the region U is all of Rn. We next derive necessary and suﬃcient conditions on the vector ﬁelds f and g in (13.34) for the existence of such a transformation. Let us set y = T (x) (13.39) and see what conditions the transformation T (x) must satisfy. Diﬀerentiating both sides of (13.39) with respect to time yields ˙y = ∂T ∂x ˙x (13.40) where ∂T ∂x is the Jacobian matrix of the transformation T (x). Using (13.34) and (13.37), Equation (13.40) can be written as ∂T ∂x (f (x) + g(x)u) = Ay + bv. (13.41) 2A diﬀeomorphism is simply a diﬀerentiable function whose inverse exists and is also diﬀerentiable. We shall assume both the function and its inverse to be inﬁnitely diﬀerentiable. Such functions are customarily referred to as C ∞ diﬀeomorphisms. 13.3. SINGLE-INPUT SYSTEMS 295 In component form with T =       T1 · · · Tn       A =         0 1 0 0 0 0 1 · · · · · · · · · · · · · · 1 0 0 · · 0 0         b =         0 0 · · · 1         (13.42) we see that the ﬁrst equation in (13.41) is ∂T1 ∂x1 ˙x1 + · · · + ∂T1 ∂xn ˙xn = T2 (13.43) which can be written compactly as Lf T1 + LgT1u = T2 (13.44) Similarly, the other components of T satisfy Lf T2 + LgT2u = T3 (13.45) · · · Lf Tn + LgTnu = v. Since we assume that T1, . . . , Tn are independent of u while v is not independent of u we conclude from (13.45) that LgT1 = LgT2 = · · · = LgTn−1 = 0 (13.46) LgTn ̸= 0 (13.47) This leads to the system of partial diﬀerential equations Lf Ti = Ti+1 i = 1, . . . n − 1 (13.48) together with Lf Tn + LgTnu = v (13.49) Using Lemma 13.1 and the conditions (13.46) and (13.47) we can derive a system of partial diﬀerential equations in terms of T1 alone as follows. Using h = T1 in Lemma 13.1 we have L[f,g]T1 = Lf LgT1 − LgLf T1 = 0 − LgT2 = 0 (13.50) 296 CHAPTER 13. FEEDBACK LINEARIZATION Thus we have shown L[f,g]T1 = 0 (13.51) By proceeding inductively it can be shown (Problem 12-4) that Ladk f gT1 = 0 k = 0, 1, . . . n − 2 (13.52) Ladn−1 f gT1 ̸= 0 (13.53) If we can ﬁnd T1 satisfying the system of partial diﬀerential Equations (13.52), then T2, . . . , Tn are found inductively from (13.48) and the control input u is found from Lf Tn + LgTnu = v (13.54) as u = 1 LgTn (v − Lf Tn) (13.55) We have thus reduced the problem to solving the system (13.52) for T1. When does such a solution exist? First note that the vector ﬁelds g, adf (g), . . . , adn−1 f (g) must be linearly independent. If not, that is, if for some index i adi f (g) = i−1∑ k=0 αkadk f (g) (13.56) then adn−1 f (g) would be a linear combination of g, adf (g), . . . , adn−2 f (g) and (13.53) could not hold. Now by the Frobenius Theorem (13.52) has a solution if and only if the set of vector ﬁelds {g, adf (g), . . . , adn−2 f (g)} is involutive. Putting this together we have shown the following. Theorem 3 The nonlinear system ˙x = f (x) + g(x)u (13.57) with f (x), g(x) smooth vector ﬁelds, and f (0) = 0 is feedback linearizable if and only if there exists a region U containing the origin in Rn in which the following conditions hold: 1. The vector ﬁelds {g, adf (g), . . . , adn−1 f (g)} are linearly independent in U . 2. The set {g, adf (g), . . . , adn−2 f (g)} is involutive in U . Example 13.2 Consider the single link manipulator with ﬂexible joint shown in Fig- ure 13.3. Ignoring damping for simplicity, the equations of motion are 13.3. SINGLE-INPUT SYSTEMS 297 Figure 13.3: Single-Link Flexible Joint Robot I ¨q1 + M gl sin(q1) + k(q1 − q2) = 0 (13.58) J ¨q2 + k(q2 − q1) = u (13.59) Note that since the nonlinearity enters into the ﬁrst equation the control u cannot simply be chosen to cancel it as in the case of the rigid manipulator equations. In state space we set x1 = q1 x2 = ˙q1 (13.60) x3 = q2 x4 = ˙q2 and write the system (13.58) as ˙x1 = x2 (13.61) ˙x2 = − M gL I sin(x1) − k I (x1 − x3) ˙x3 = x4 ˙x4 = k J (x1 − x3) + 1 J u. The system is thus of the form (13.34) with f (x) =     x2 − M gL I sin(x1) − k I (x1 − x3) x4 k J (x1 − x3)     g(x) =     0 0 0 1 J     . (13.62) Therefore n = 4 and the necessary and suﬃcient conditions for feedback linearization of this system are that rank [ g, adf (g), ad2 f (g), ad3 f (g) ] = 4 (13.63) 298 CHAPTER 13. FEEDBACK LINEARIZATION and that the set {g, adf (g), ad2 f (g)} (13.64) be involutive. Performing the indicated calculations it is easy to check that (Problem 12-7) [g, adf (g), ad2 f (g), ad3 f (g)] =     0 0 0 k IJ 0 0 k IJ 0 0 1 J 0 − k J 2 1 J 0 − k J 2 0     (13.65) which has rank 4 for k > 0, I, J < ∞. Also, since the vector ﬁelds {g, adf (g), ad2 f (g)} are constant, they form an involutive set. To see this it suﬃces to note that the Lie Bracket of two constant vector ﬁelds is zero. Hence the Lie Bracket of any two members of the set of vector ﬁelds in (13.64) is zero which is trivially a linear combination of the vector ﬁelds themselves. It follows that the system (13.58) is feedback linearizable. The new coordinates yi = Ti i = 1, . . . , 4 (13.66) are found from the conditions (13.52), with n = 4, that is LgT1 = 0 L[f,g]T1 = 0 Lad2 f gT1 = 0 Lad3 f gT1 = 0 Carrying out the above calculations leads to the system of equations (Problem 12-8) ∂T1 ∂x2 = 0 ; ∂T1 ∂x3 = 0 ; ∂T1 ∂x4 = 0 (13.67) and ∂T1 ∂x1 ̸= 0. (13.68) From this we see that the function T1 should be a function of x1 alone. Therefore, we take the simplest solution y1 = T1 = x1 (13.69) and compute from (13.48) (Problem 12-9) y2 = T2 = Lf T1 = x2 (13.70) y3 = T3 = Lf T2 = − M gL I sin(x1) − k I (x1 − x3) (13.71) y4 = T4 = Lf T3 = − M gL I cos(x1) − K I (x2 − x4). (13.72) 13.3. SINGLE-INPUT SYSTEMS 299 The feedback linearizing control input u is found from the condition u = 1 LgT4 (v − Lf T4) (13.73) as (Problem 12-10) u = IJ k (v − a(x)) = β(x)v + α(x) (13.74) where a(x) := M gL I sin(x1) (x 2 2 + M gL I cos(x1) + k I ) (13.75) + k I (x1 − x3) ( k I + k J + M gL I cos(x1) ) . ⋄ Therefore in the coordinates y1, . . . , y4 with the control law (13.74) the system becomes ˙y1 = y2 (13.76) ˙y2 = y3 ˙y3 = y4 ˙y4 = v or, in matrix form, ˙y = Ay + bv (13.77) where A =     0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0     b =     0 0 0 1     . (13.78) Remark 13.2 The above feedback linearization is actually global. In order to see this we need only compute the inverse of the change of variables (13.69)-(13.72). Inspecting (13.69)(13.72) we see that x1 = y1 (13.79) x2 = y2 x3 = y1 + I k (y3 + M gL I sin(y1) ) x4 = y2 + I k (y4 + M gL I cos(y1)y2 ) . (13.80) 300 CHAPTER 13. FEEDBACK LINEARIZATION The inverse transformation is well deﬁned and diﬀerentiable everywhere and, hence, the feedback linearization for the system (13.58) holds globally. The transformed variables y1, . . . , y4 are themselves physically meaningful. We see that y1 = x1 = link position (13.81) y2 = x2 = link velocity y3 = ˙y2 = link acceleration y4 = ˙y3 = link jerk. Since the motion trajectory of the link is typically speciﬁed in terms of these quantities they are natural variables to use for feedback. Example 13.3 One way to execute a step change in the link position while keeping the manipulator motion smooth would be to require a constant jerk during the motion. This can be accomplished by a cubic polynomial trajectory using the methods of Chapter 8. Therefore, let us specify a trajectory θd ℓ (t) = yd 1 = a1 + a2t + a3t2 + a4t3 (13.82) so that yd 2 = ˙yd 1 = a2 + 2a3t + 3a4t2 yd 3 = ˙yd 2 = 2a3 + 6a4t yd 4 = ˙yd 3 = 6a4. Then a linear control law that tracks this trajectory and that is essentially equivalent to the feedforward/feedback scheme of Chapter 11 is given by v = ˙yd 4 − k1(y1 − yd 1) − k2(y2 − yd 2) − k3(y3 − yd 3) − k4(y4 − yd 4) (13.83) Applying this control law to the fourth order linear system (13.74) we see that the tracking error e(t) = y1 − yd 1 satisﬁes the fourth order linear equation d4e dt4 + k4 d3e dt3 + k3 d2e dt2 + k2 de dt + k1e = 0 (13.84) and, hence, the error dynamics are completely determined by the choice of gains k1, . . . , k4. ⋄ Notice that the feedback control law (13.83) is stated in terms of the variables y1, . . . , y4. Thus, it is important to consider how these variables are to be determined so that they may be used for feedback in case they cannot be measured directly. Although the ﬁrst two variables, representing the link position and velocity, are easy to measure, the remaining variables, representing link acceleration and jerk, are diﬃcult 13.4. FEEDBACK LINEARIZATION FOR N -LINK ROBOTS 301 to measure with any degree of accuracy using present technology. One could measure the original variables x1, . . . , x4 which represent the motor and link positions and velocities, and compute y1, . . . , y4 using the transformation Equations (13.69)-(13.72). In this case the parameters appearing in the transformation equations would have to be known precisely. Another, and perhaps more promising, approach is to construct a dynamic observer to estimate the state variables y1, . . . , y4. 13.4 Feedback Linearization for N -Link Robots In the general case of an n-link manipulator the dynamic equations represent a multi-input nonlinear system. The conditions for feedback linearization of multi-input systems are more diﬃcult to state, but the conceptual idea is the same as the single-input case. That is, one seeks a coordinate systems in which the nonlinearities can be exactly canceled by one or more of the inputs. In the multi-input system we can also decouple the system, that is, linearize the system in such a way that the resulting linear system is composed of subsystems, each of which is aﬀected by only a single one of the outer loop control inputs. Since we are concerned only with the application of these ideas to manipulator control we will not need the most general results in multi-input feedback linearization. Instead, we will use the physical insight gained by our detailed derivation of this result in the single-link case to derive a feedback linearizing control both for n-link rigid manipulators and for n-link manipulators with elastic joints directly. Example 13.4 We will ﬁrst verify what we have stated previously, namely that for an n-link rigid manipulator the feedback linearizing control is identical to the inverse dynamics control of Chapter 11. To see this, consider the rigid equations of motion (11.6), which we write in state space as ˙x1 = x2 (13.85) ˙x2 = −M (x1) −1(C(x1, x2)x2 + g(x1)) + M (x1) −1u with X1 = q; X2 = ˙q. In this case a feedback linearizing control is found by simply inspecting (13.85) as u = M (x1)v + C(x1, x2)x2 + g(x1) (13.86) Substituting (13.86) into (13.85) yields ˙x1 = x2 (13.87) ˙x2 = v. Equation (13.97) represents a set of n-second order systems of the form ˙x1i = x2i (13.88) ˙x2i = vi, i = 1, . . . , n. 302 CHAPTER 13. FEEDBACK LINEARIZATION Comparing (13.86) with (11.17) we see indeed that the feedback linearizing control for a rigid manipulator is precisely the inverse dynamics control of Chapter 11. ⋄ Example 13.5 If the joint ﬂexibility is included in the dynamic description of an n-link robot the equations of motion can be written as D(q1)¨q1 + C(q1, ˙q1) ˙q1 + g(q1) + K(q1 − q2) = 0 (13.89) J ¨q2 − K(q1 − q2) = u. (13.90) In state space, which is now R4n, we deﬁne state variables in block form ˙x1 = q1 x2 = ˙q1 (13.91) ˙x3 = q2 x4 = ˙q2. Then from (13.89)-(13.90) we have: ˙x1 = x2 (13.92) ˙x2 = −D(x1) −1{h(x1, x2) + K(x1 − x3)} (13.93) ˙x3 = x4 (13.94) ˙x4 = J −1K(x1 − x3) + J −1u. (13.95) where we deﬁne h(x1, x2) = C(x1, x2)x2 + g(x1) for simplicity. This system is then of the form ˙x = f (x) + G(x)u. (13.96) In the single-link case we saw that the appropriate state variables with which to deﬁne the system so that it could be linearized by nonlinear feedback were the link position, velocity, acceleration, and jerk. Following the single-input example, then, we can attempt to do the same thing in the multi-link case and derive a feedback linearizing transformation blockwise as follows: Set y1 = T1(x1) := x1 (13.97) y2 = T2(x) := ˙y1 = ˙x2 (13.98) y3 = T3(x) := ˙y2 = ˙x2 (13.99) = −D(x1) −1{h(x1, x2) + K(x1 − x3)} y4 = T4(x) := ˙y3 (13.100) = − d dt [D(x1) −1]{h(x1, x2) + K(x1 − x3)} − D(x1) −1 { ∂h ∂x1 x2 + ∂h ∂x2 [−D(x1) −1(h(x1, x2) + K(x1 − x3))] + K(x2 − x4) } := a4(x1, x2, x3) + D(x1) −1Kx4 13.4. FEEDBACK LINEARIZATION FOR N -LINK ROBOTS 303 where for simplicity we deﬁne the function a4 to be everything in the deﬁnition of y4 except the last term, which is D−1Kx4. Note that x4 appears only in this last term so that a4 depends only on x1, x2, x3. As in the single-link case, the above mapping is a global diﬀeomorphism. Its inverse can be found by inspection to be x1 = y1 (13.101) x2 = y2 (13.102) x3 = y1 + K−1(D(y1)y3 + h(y1, y2)) (13.103) x4 = K−1D(y1)(y4 − a4(y1, y2, y3)). (13.104) The linearizing control law can now be found from the condition ˙y4 = v (13.105) where v is a new control input. Computing ˙y4 from (13.100) and suppressing function arguments for brevity yields v = ∂a4 ∂x1 x2 − ∂a4 ∂x2 D−1(h + K(x1 − x3)) (13.106) + ∂a4 ∂x3 x4 + d dt [D−1]Kx4 + D−1K(J −1K(x1 − x3) + J −1u) =: a(x) + b(x)u where a(x) denotes all the terms in (13.106) but the last term, which involves the input u, and b(x) := D−1(x)KJ −1. Solving the above expression for u yields u = b(x)−1(v − a(x)) (13.107) =: alpha(x) + β(x)v (13.108) where β(x) = JK−1D(x) and alpha(x) = −b(x)−1a(x). With the nonlinear change of coordinates (13.97)-(13.100) and nonlinear feedback (13.107) the transformed system now has the linear block form ˙y =     0 I 0 0 0 0 I 0 0 0 0 I 0 0 0 0     y +     0 0 0 I     v (13.109) =: Ay + Bv where I = n × n identity matrix, 0 = n × n zero matrix, yT = (yT 1 , yT 2 , yT 3 , yT 4 ) ∈ R4n, and v ∈ Rn. The system (13.109) represents a set of n decoupled quadruple integrators. The outer loop design can now proceed as before, because not only is the system linearized, but it consists of n subsystems each identical to the fourth order system (13.76). ⋄","libVersion":"0.3.2","langs":""}